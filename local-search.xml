<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/article/0.html"/>
    <url>/article/0.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>n8n知识点总结</title>
    <link href="/article/31bb5e7c.html"/>
    <url>/article/31bb5e7c.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>1.n8n流程表达式能读取系统环境变量吗</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">是的，n8n 流程表达式（Expressions）可以读取系统环境变量。您可以在表达式或代码中通过内置变量访问环境变量。例如，可以使用如下方式读取环境变量：<br><br>- 用表达式来说：`&#123;&#123;<span class="hljs-variable">$env</span>.YOUR_ENV_VARIABLE&#125;&#125;`<br>    <br>- 在代码节点中：`<span class="hljs-variable">$env</span>.YOUR_ENV_VARIABLE`<br>    <br><br>需要注意的是，管理员可以通过设置`N8N_BLOCK_ENV_ACCESS_IN_NODE`环境变量来在表达式和代码节点中访问环境变量。如果该变量设置为`true`，则无法在表达式和代码节点中访问[环境变量安全环境变量](https:<span class="hljs-regexp">//</span>docs.n8n.io<span class="hljs-regexp">/hosting/</span>configuration<span class="hljs-regexp">/environment-variables/</span>security/<span class="hljs-comment">#security-environment-variables)。</span><br><br></code></pre></td></tr></table></figure><p>2.为什么我在一个节点设置了export环境变量，在下一个节点读取不到呢</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">在n8n中，节点之间并不会共享你在某个节点中通过<span class="hljs-keyword">export</span>或set命令设置的环境变量。n8n的环境变量是在启动n8n服务时由网络传递给整个n8n进程的，而不是在单个节点执行时动态设置和传递的。<br><br>也就是说：<br><br>- 你需要在启动 n8n 服务（比如 docker run、docker-compose、或者直接在 shell 启动 n8n 前）就设置好环境变量，这样 n8n 的所有节点才能读取到这些变量。<br>    <br>- 在某个节点（比如执行命令或代码节点）里用导出设置的环境变量，只在该节点的子进程或当前脚本中有效，不会影响n8n进程本身，也不会被其他节点读取到。<br></code></pre></td></tr></table></figure><p>3.n8n $var定义的环境变量怎么修改</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">n8n</span> 中通过 <span class="hljs-variable">$vars</span> 定义的环境变量（即自定义变量）是可以修改**的**，不能在工作流或代码节点中直接修改。你只能通过 n8n 的 UI（界面）进行添加、编辑或删除这些变量，不能在流执行过程中用代码或表达式动态更改其值。<br></code></pre></td></tr></table></figure><p>4.n8n 怎么引用变量</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">选择表达式，使用</span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">变量</span> &#125;&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>n8n</tag>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github Action 同步fork分支</title>
    <link href="/article/1ff04a9a.html"/>
    <url>/article/1ff04a9a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Upstream</span> <span class="hljs-string">Sync</span><br><br><span class="hljs-attr">permissions:</span><br>  <span class="hljs-attr">contents:</span> <span class="hljs-string">write</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&quot;0 0 * * *&quot;</span> <span class="hljs-comment"># every day</span><br>  <span class="hljs-attr">workflow_dispatch:</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">sync_latest_from_upstream:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">latest</span> <span class="hljs-string">commits</span> <span class="hljs-string">from</span> <span class="hljs-string">upstream</span> <span class="hljs-string">repo</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">if:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">github.event.repository.fork</span> <span class="hljs-string">&#125;&#125;</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># Step 1: run a standard checkout action</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">target</span> <span class="hljs-string">repo</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br><br>      <span class="hljs-comment"># Step 2: run the sync action</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">upstream</span> <span class="hljs-string">changes</span><br>        <span class="hljs-attr">id:</span> <span class="hljs-string">sync</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">aormsby/Fork-Sync-With-Upstream-action@v3.4</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">upstream_sync_repo:</span> <span class="hljs-string">qist/tvbox</span><br>          <span class="hljs-attr">upstream_sync_branch:</span> <span class="hljs-string">master</span><br>          <span class="hljs-attr">target_sync_branch:</span> <span class="hljs-string">master</span><br>          <span class="hljs-attr">target_repo_token:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITHUB_TOKEN</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-comment"># automatically generated, no need to set</span><br><br>          <span class="hljs-comment"># Set test_mode true to run tests instead of the true action!!</span><br>          <span class="hljs-attr">test_mode:</span> <span class="hljs-literal">false</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">check</span><br>        <span class="hljs-attr">if:</span> <span class="hljs-string">failure()</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          echo &quot;[Error] 由于上游仓库的 workflow 文件变更，导致 GitHub 自动暂停了本次自动更新，你需要手动 Sync Fork 一次，详细教程请查看：https://github.com/Yidadaa/ChatGPT-Next-Web/blob/main/README_CN.md#%E6%89%93%E5%BC%80%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0&quot;</span><br><span class="hljs-string">          echo &quot;[Error] Due to a change in the workflow file of the upstream repository, GitHub has automatically suspended the scheduled automatic update. You need to manually sync your fork. Please refer to the detailed tutorial for instructions: https://github.com/Yidadaa/ChatGPT-Next-Web#enable-automatic-updates&quot;</span><br><span class="hljs-string">          exit 1</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AI知识词</title>
    <link href="/article/7ebf4bf3.html"/>
    <url>/article/7ebf4bf3.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />可视化客户端- cherry studio- chatbox可视化流程工具- Dify- RAGFlow- FastGptJAVA AI框架- LangChain4J- Spring AI]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat+eclipse+jsp乱码</title>
    <link href="/article/5698545a.html"/>
    <url>/article/5698545a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /># [在eclipse中使用Tomcat启动项目乱码](https://www.cnblogs.com/breeze-zZ/p/17614593.html "发布于 2023-08-08 15:49")<p>修改tomcat的配置文件</p><p>1）修改Tomcat的server.xml配置（config目录下）</p><p>先找到第一处添加URIEncoding&#x3D;“UTF-8”</p><p><Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/></p><p>再找到第二处添加URIEncoding&#x3D;“UTF-8”</p><Connector port="8009" protocol="AJP/1.3" redirectPort="8443" URIEncoding="UTF-8"/><p>2）修改catalina.bat配置（bin目录下）</p><p>找到”JAVA_OPTS&#x3D;%JAVA_OPTS% %JSSE_OPTS%”换行添加</p><p><strong>-Dfile.encoding&#x3D;UTF8 -Dsun.jnu.encoding&#x3D;UTF8</strong></p><p>if not “%JSSE_OPTS%” &#x3D;&#x3D; “” goto gotJsseOpts<br>set “JSSE_OPTS&#x3D;-Djdk.tls.ephemeralDHKeySize&#x3D;2048”<br>:gotJsseOpts<br>set “JAVA_OPTS&#x3D;%JAVA_OPTS% %JSSE_OPTS%”<br>-Dfile.encoding&#x3D;UTF8 -Dsun.jnu.encoding&#x3D;UTF8</p><p>————–以上都不行———-</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> servlets;<br><br>  <br><br><span class="hljs-keyword">import</span> javax.servlet.*;<br><br><span class="hljs-keyword">import</span> javax.servlet.annotation.WebFilter;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-meta">@WebFilter(&quot;/*&quot;)</span> <span class="hljs-comment">// 过滤所有请求</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharacterEncodingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException &#123;&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><br><span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br><span class="hljs-comment">// 设置请求和响应编码</span><br><br>request.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>response.setContentType(<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br><br>chain.doFilter(request, response);<br><br>&#125;<br><br><span class="hljs-meta">@Override</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guava LoadingCache的get和getIfPresent</title>
    <link href="/article/33c98566.html"/>
    <url>/article/33c98566.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p>我们在使用LoadingCache类的适合，builder中会传入一个CacheLoader，这个load方法是用来从别的地方取值保存在内存中的。</p><p>使用get时，如果内存中没有值，会自动调用load方法，如果load方法返回的是null，那么get会抛出异常。</p><p>使用getIfPresent时，如果内存中没有值，不会调用load方法，而是直接返回null。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 普通用户 通过信任关系 切换root</title>
    <link href="/article/74cace2a.html"/>
    <url>/article/74cace2a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />1、登录普通su - admin<p>2、执行命令</p><p>ssh-keygen -t rsa</p><p>3、生成如下目录</p><p><img src="https://img2020.cnblogs.com/blog/1616156/202107/1616156-20210727161552811-1400724794.png"></p><p> 4、切换到root用户，执行命令</p><p>ssh-keygen -t rsa</p><p>5、私钥不动id_rsa，普通用户公钥id_rsa.pub内容追加至 .ssh&#x2F;authorized_keys </p><p>cat &#x2F;home&#x2F;admin&#x2F;.ssh&#x2F;id_rsa.pub &gt;.ssh&#x2F;authorized_keys</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DeepSeek免费使用渠道大全 🚀</title>
    <link href="/article/3f69882.html"/>
    <url>/article/3f69882.html</url>
    
    <content type="html"><![CDATA[<h1 id="🔥-DeepSeek免费使用渠道大全-🚀"><a href="#🔥-DeepSeek免费使用渠道大全-🚀" class="headerlink" title="🔥 DeepSeek免费使用渠道大全 🚀"></a>🔥 DeepSeek免费使用渠道大全 🚀</h1><h2 id="一、支持联网搜索渠道-电脑和手机都可用-🌐"><a href="#一、支持联网搜索渠道-电脑和手机都可用-🌐" class="headerlink" title="一、支持联网搜索渠道 (电脑和手机都可用) 🌐"></a>一、支持联网搜索渠道 (电脑和手机都可用) 🌐</h2><ul><li>华为小艺 : <a href="https://xiaoyi.huawei.com/">https://xiaoyi.huawei.com</a></li><li>MiniMax : <a href="https://chat.minimax.io/">https://chat.minimax.io</a></li><li>QQ浏览器 : <a href="https://aisearch.qq.com/">https://aisearch.qq.com</a></li><li>天工AI : <a href="https://www.tiangong.cn/">https://www.tiangong.cn</a></li><li>当贝AI : <a href="https://ai.dangbei.com/">https://ai.dangbei.com</a></li><li>WPS灵犀 : <a href="https://copilot.wps.cn/">https://copilot.wps.cn</a></li><li>腾讯元宝 : <a href="https://yuanbao.tencent.com/">https://yuanbao.tencent.com</a></li><li>Get笔记 : <a href="https://www.biji.com/">https://www.biji.com</a></li><li>有道翻译 : <a href="https://fanyi.youdao.com/">https://fanyi.youdao.com</a></li><li>心流AI助手 : <a href="https://www.iflow.cn/">https://www.iflow.cn</a></li><li>ima : <a href="https://ima.qq.com/">https://ima.qq.com</a></li><li>跃问 : <a href="https://www.yuewen.cn/">https://www.yuewen.cn</a></li><li>问小白 : <a href="https://www.wenxiaobai.com/">https://www.wenxiaobai.com</a></li><li>AskManyAI : <a href="https://www.askmanyai.cn/">https://www.askmanyai.cn</a></li><li>秘塔AI搜索 : <a href="https://www.metaso.cn/">https://www.metaso.cn</a></li><li>纳米AI搜索 : <a href="https://www.n.cn/">https://www.n.cn</a></li><li>Poe : <a href="https://www.poe.com/DeepSeek-R1">https://www.poe.com/DeepSeek-R1</a></li><li>Perplexity : <a href="https://www.perplexity.ai/">https://www.perplexity.ai</a></li><li>Monica : <a href="https://www.monica.cn/">https://www.monica.cn</a></li><li>百度文库 : <a href="https://wenku.baidu.com/">https://wenku.baidu.com</a></li><li>讯飞智文 : <a href="https://zhiwen.xfyun.cn/">https://zhiwen.xfyun.cn</a></li><li>腾讯文档 : <a href="https://docs.qq.com/">https://docs.qq.com</a></li><li>知乎直答 : <a href="https://zhida.zhihu.com/">https://zhida.zhihu.com</a></li><li>无涯问知AI : <a href="https://www.wuya-ai.com/">https://www.wuya-ai.com</a></li><li>腾讯云AI代码助手 : <a href="https://copilot.tencent.com/chat">https://copilot.tencent.com/chat</a></li><li>deepseek-r1-online : <a href="https://deepseek-r1-online.com/chat/">https://deepseek-r1-online.com/chat/</a></li></ul><hr><h2 id="二、提供免费API额度-可调整参数-⚙️"><a href="#二、提供免费API额度-可调整参数-⚙️" class="headerlink" title="二、提供免费API额度 (可调整参数) ⚙️"></a>二、提供免费API额度 (可调整参数) ⚙️</h2><ul><li>火山方舟 : <a href="https://console.volcengine.com/">https://console.volcengine.com</a></li><li>硅基流动 : <a href="https://cloud.siliconflow.cn/">https://cloud.siliconflow.cn</a></li><li>无问芯穹 : <a href="https://cloud.infini-ai.com/">https://cloud.infini-ai.com</a></li><li>模力方舟 : <a href="https://ai.gitee.com/models">https://ai.gitee.com/models</a></li><li>英伟达 : <a href="https://build.nvidia.com/deepseek-ai/deepseek-r1">https://build.nvidia.com/deepseek-ai/deepseek-r1</a></li><li>Deep Infra : <a href="https://deepinfra.com/deepseek-ai/DeepSeek-R1">https://deepinfra.com/deepseek-ai/DeepSeek-R1</a></li><li>阿里云百炼 : <a href="https://bailian.console.aliyun.com/">https://bailian.console.aliyun.com</a></li><li>讯飞星辰MaaS平台 : <a href="https://training.xfyun.cn/">https://training.xfyun.cn</a></li></ul><hr><h2 id="三、创建智能体选择R1模型-可调参数-🤖"><a href="#三、创建智能体选择R1模型-可调参数-🤖" class="headerlink" title="三、创建智能体选择R1模型 (可调参数) 🤖"></a>三、创建智能体选择R1模型 (可调参数) 🤖</h2><ul><li>扣子 : <a href="https://www.coze.cn/">https://www.coze.cn</a></li><li>FastGPT : <a href="https://cloud.tryfastgpt.ai/">https://cloud.tryfastgpt.ai</a></li><li>支付宝百宝箱 : <a href="https://tbox.alipay.com/">https://tbox.alipay.com</a></li><li>OpenRouter : <a href="https://openrouter.ai/deepseek/deepseek-r1">https://openrouter.ai/deepseek/deepseek-r1</a></li><li>腾讯云大模型知识引擎 : <a href="https://lke.cloud.tencent.com/">https://lke.cloud.tencent.com</a></li><li>百度智能云千帆AppBuilder : <a href="https://qianfan.cloud.baidu.com/appbuilder">https://qianfan.cloud.baidu.com/appbuilder</a></li></ul><hr><h2 id="四、接入DeepSeek-R1的各类平台-🔌"><a href="#四、接入DeepSeek-R1的各类平台-🔌" class="headerlink" title="四、接入DeepSeek R1的各类平台 🔌"></a>四、接入DeepSeek R1的各类平台 🔌</h2><h3 id="在线平台"><a href="#在线平台" class="headerlink" title="在线平台"></a>在线平台</h3><ul><li>超算互联网 : <a href="https://www.scnet.cn/ui/console">https://www.scnet.cn/ui/console</a></li><li>Hugging Face : <a href="https://huggingface.co/deepseek-ai/DeepSeek-R1">https://huggingface.co/deepseek-ai/DeepSeek-R1</a></li><li>Groq : <a href="https://www.groq.com/">https://www.groq.com</a></li><li>腾讯云DeepSeek联网助手 : <a href="https://lke.cloud.tencent.com/lke#/experience-center">https://lke.cloud.tencent.com/lke#/experience-center</a></li><li>火山方舟DeepSeek模型体验 : <a href="https://www.volcengine.com/experience/ark">https://www.volcengine.com/experience/ark</a></li></ul><h3 id="写作平台"><a href="#写作平台" class="headerlink" title="写作平台"></a>写作平台</h3><ul><li>作家助手 : <a href="https://zuojia.write.qq.com/">https://zuojia.write.qq.com</a></li></ul><h3 id="开发平台"><a href="#开发平台" class="headerlink" title="开发平台"></a>开发平台</h3><ul><li>Trae : <a href="https://www.trae.com.cn/">https://www.trae.com.cn</a></li></ul><h3 id="数据分析平台"><a href="#数据分析平台" class="headerlink" title="数据分析平台"></a>数据分析平台</h3><ul><li>ChatExcel : <a href="https://www.chatexcel.com/">https://www.chatexcel.com</a></li></ul><h3 id="PPT制作平台"><a href="#PPT制作平台" class="headerlink" title="PPT制作平台"></a>PPT制作平台</h3><ul><li>笔格PPT : <a href="https://bigppt.cn/">https://bigppt.cn</a></li><li>美图设计师Live PPT : <a href="https://www.designkit.com/ppt">https://www.designkit.com/ppt</a></li></ul><hr><p><em>注：以上链接均为直接可用的DeepSeek资源，建议收藏备用。</em></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile 之最小化 Java 镜像的常用技巧</title>
    <link href="/article/91fe9850.html"/>
    <url>/article/91fe9850.html</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着<a href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065">容器</a>技术的普及，越来越多的应用被容器化。人们使用容器的频率越来越高，但常常忽略一个基本但又非常重要的问题 - <a href="https://cloud.tencent.com/product/tcr?from_column=20065&from=20065">容器镜像</a>的体积。本文将介绍精简容器镜像的必要性并以基于 spring boot 的 java 应用为例描述最小化容器镜像的常用技巧。</p><h2 id="精简容器镜像的必要性"><a href="#精简容器镜像的必要性" class="headerlink" title="精简容器镜像的必要性"></a>精简容器镜像的必要性</h2><p>精简容器镜像是非常必要的，下面分别从安全性和敏捷性两个角度进行阐释。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>基于安全方面的考虑，将不必要的组件从镜像中移除可以减少攻击面、降低安全风险。虽然 docker 支持用户通过 Seccomp 限制容器内可以执行操作或者使用 AppArmor 为容器配置安全策略，但它们的使用门槛较高，要求用户具备安全领域的专业素养。</p><h3 id="敏捷性"><a href="#敏捷性" class="headerlink" title="敏捷性"></a>敏捷性</h3><p>精简的容器镜像能提高容器的部署速度。假设某一时刻访问流量激增，您需要通过增加容器副本数以应对突发压力。如果某些<a href="https://cloud.tencent.com/product/cdh?from_column=20065&from=20065">宿主机</a>不包含目标镜像，需要先拉取镜像，然后启动容器，这时使用体积较小的镜像能加速这一过程、缩短扩容时间。另外，镜像体积越小，其构建速度也越快，同时还能减少存储和传输的成本。</p><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><p>将一个 java 应用容器化所需的步骤可归纳如下：</p><ol><li>编译 java 源码并生成 jar 包。</li><li>将应用 jar 包和依赖的第三方 jar 包移动到合适的位置。</li></ol><p>本章所用的样例是一个基于 spring boot 的 java 应用 spring-boot-docker，所用的未经优化的 dockerfile 如下：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> maven:<span class="hljs-number">3.5</span>-jdk-<span class="hljs-number">8</span><br><span class="hljs-keyword">COPY</span> src <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>src<br><span class="hljs-keyword">COPY</span> pom.xml <span class="hljs-regexp">/usr/</span>src/app<br>RUN mvn -f <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>pom.xml clean <span class="hljs-keyword">package</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/usr/src/app/target/spring-boot-docker-1.0.0.jar&quot;</span>]<br></code></pre></td></tr></table></figure><p>由于应用使用 maven 构建，dockerfile 中指定<code>maven:3.5-jdk-8</code>作为基础镜像，该镜像的大小为 635MB。通过这种方式最终构建出的镜像非常大，达到了 719MB，这是因为一方面基础镜像本身就很大，另一方面 maven 在构建过程中会下载许多用于执行构建任务的 jar 包。</p><h3 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h3><p>Java 程序的运行只依赖 JRE，并不需要 maven 或者 JDK 中众多用于编译、调试、运行的工具，因此一个明显的优化方法是将用于编译构建 java 源码的镜像和用于运行 java 应用的镜像分开。为了达到这一目的，在 docker 17.05 版本之前需要用户维护 2 个 dockerfile 文件，这无疑增加了构建的复杂性。好在自 17.05 开始，docker 引入了多阶段构建的概念，它允许用户在一个 dockerfile 中使用多个 From 语句。每个 From 语句可以指定不同的基础镜像并将开启一个全新的构建流程。您可以选择性地将前一阶段的构建产物复制到另一个阶段，从而只将必要的内容保留在最终的镜像里。优化后的 dockerfile 如下：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> maven:<span class="hljs-number">3.5</span>-jdk-<span class="hljs-number">8</span> AS build<br><span class="hljs-keyword">COPY</span> src <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>src<br><span class="hljs-keyword">COPY</span> pom.xml <span class="hljs-regexp">/usr/</span>src/app<br>RUN mvn -f <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>pom.xml clean <span class="hljs-keyword">package</span><br><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jre<br>ARG DEPENDENCY=<span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>target/dependency<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/BOOT-INF/</span>lib <span class="hljs-regexp">/app/</span>lib<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/META-INF /</span>app/META-INF<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/BOOT-INF/</span>classes /app<br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-cp&quot;</span>,<span class="hljs-string">&quot;app:app/lib/*&quot;</span>,<span class="hljs-string">&quot;hello.Application&quot;</span>]<br></code></pre></td></tr></table></figure><p>该 dockerfile 选用<code>maven:3.5-jdk-8</code>作为第一阶段的构建镜像，选用<code>openjdk:8-jre</code>作为运行 java 应用的基础镜像并且只拷贝了第一阶段编译好的<code>.claass</code>文件和依赖的第三方 jar 包到最终的镜像里。通过这种方式优化后的镜像大小为 459MB。</p><h3 id="使用-distroless-作为基础镜像"><a href="#使用-distroless-作为基础镜像" class="headerlink" title="使用 distroless 作为基础镜像"></a>使用 distroless 作为基础镜像</h3><p>虽然通过多阶段构建能减小最终生成的镜像的大小，但 459MB 的体积仍相对过大。经调查发现，这是因为使用的基础镜像<code>openjdk:8-jre</code>体积过大，到达了 443MB，因此下一步的优化方向是减小基础镜像的体积。</p><p>Google 开源的项目 distroless 正是为了解决基础镜像体积过大这一问题。Distroless 镜像只包含应用程序及其运行时依赖项，不包含包管理器、shell 以及在标准 Linux 发行版中可以找到的任何其他程序。目前，distroless 为依赖 java、python、nodejs、dotnet 等环境的应用提供了基础镜像。</p><p>使用 distroless 的 dockerfile 如下：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> maven:<span class="hljs-number">3.5</span>-jdk-<span class="hljs-number">8</span> AS build<br><span class="hljs-keyword">COPY</span> src <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>src<br><span class="hljs-keyword">COPY</span> pom.xml <span class="hljs-regexp">/usr/</span>src/app<br>RUN mvn -f <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>pom.xml clean <span class="hljs-keyword">package</span><br><br><span class="hljs-keyword">FROM</span> gcr.io<span class="hljs-regexp">/distroless/</span>java<br>ARG DEPENDENCY=<span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>target/dependency<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/BOOT-INF/</span>lib <span class="hljs-regexp">/app/</span>lib<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/META-INF /</span>app/META-INF<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/BOOT-INF/</span>classes /app<br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-cp&quot;</span>,<span class="hljs-string">&quot;app:app/lib/*&quot;</span>,<span class="hljs-string">&quot;hello.Application&quot;</span>]<br></code></pre></td></tr></table></figure><p>该 dockerfile 和上一版的唯一区别在于将运行阶段依赖的基础镜像由<code>openjdk:8-jre</code>（443 MB）替换成了<code>gcr.io/distroless/java</code>（119 MB）。经过这一优化，最终镜像的大小为 135MB。</p><p>使用 distroless 的唯一不便是您无法 attach 到一个正在运行的容器上排查问题，因为镜像中不包含 shell。虽然 distroless 的 debug 镜像提供 busybox shell，但需要用户重新打包镜像、部署容器，对于那些已经基于非 debug 镜像部署的容器无济于事。 但从安全角度来看，无法 attach 容器并不完全是坏事，因为攻击者无法通过 shell 进行攻击。</p><h3 id="使用-alpine-作为基础镜像"><a href="#使用-alpine-作为基础镜像" class="headerlink" title="使用 alpine 作为基础镜像"></a>使用 alpine 作为基础镜像</h3><p>如果您确实有 attach 容器的需求，又希望最小化镜像的大小，可以选用 alpine 作为基础镜像。Alpine 镜像的特点是体积非常下，基础款镜像的体积仅 4 MB 左右。</p><p>使用 alpine 后的 dockerfile 如下：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>运行</p><p>AI代码解释</p><p>复制</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> maven:<span class="hljs-number">3.5</span>-jdk-<span class="hljs-number">8</span> AS build<br><span class="hljs-keyword">COPY</span> src <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>src<br><span class="hljs-keyword">COPY</span> pom.xml <span class="hljs-regexp">/usr/</span>src/app<br>RUN mvn -f <span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>pom.xml clean <span class="hljs-keyword">package</span><br><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jre-alpine<br>ARG DEPENDENCY=<span class="hljs-regexp">/usr/</span>src<span class="hljs-regexp">/app/</span>target/dependency<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/BOOT-INF/</span>lib <span class="hljs-regexp">/app/</span>lib<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/META-INF /</span>app/META-INF<br><span class="hljs-keyword">COPY</span> --<span class="hljs-keyword">from</span>=build $&#123;DEPENDENCY&#125;<span class="hljs-regexp">/BOOT-INF/</span>classes /app<br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-cp&quot;</span>,<span class="hljs-string">&quot;app:app/lib/*&quot;</span>,<span class="hljs-string">&quot;hello.Application&quot;</span>]<br></code></pre></td></tr></table></figure><p>这里并未直接继承基础款 alpine，而是选用从 alpine 构建出的包含 java 运行时的<code>openjdk:8-jre-alpine</code>（83MB）作为基础镜像。使用该 dockerfile 构建出的镜像体积为 99.2MB，比基于 distroless 的还要小。</p><p>执行命令<code>docker exec -ti &lt;container_id&gt; sh</code>可以成功 attach 到运行的容器中。</p><h3 id="distroless-vs-alpine"><a href="#distroless-vs-alpine" class="headerlink" title="distroless vs alpine"></a>distroless vs alpine</h3><p>既然 distroless 和 alpine 都能提供非常小的基础镜像，那么在生产环境中到底应该选择哪一种呢？如果安全性是您的首要考虑因素，建议选用 distroless，因为它唯一可运行的二进制文件就是您打包的应用；如果您更关注镜像的体积，可以选用 alpine。</p><h3 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h3><p>除了可以通过上述技巧精简镜像外，还有以下方式：</p><ol><li>将 dockerfile 中的多条指令合并成一条，通过减少镜像层数的方式达到精简镜像体积的目的。</li><li>将稳定且体积较大的内容置于镜像下层，将变动频繁且体积较小的内容置于镜像上层。虽然该方式无法直接精简镜像体积，但充分利用了镜像的缓存机制，同样可以达到加快镜像构建和容器部署的目的。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>本文通过一系列的优化，将 java 应用的镜像体积由最初的 719MB 缩小到 100MB 左右。如果您的应用依赖其他环境，也可以用类似的原则进行优化。</li><li>针对 java 镜像，google 提供的另一款工具 jib 能为您屏蔽镜像构建过程中的复杂细节，自动构建出精简的 java 镜像。使用它您无须编写 dockerfile，甚至不需要安装 docker。</li><li>对于类似 distroless 这样无法 attach 或者不方便 attach 的容器，建议您将它们的日志中心化存储，以便问题的追踪和排查。</li></ol><!-- toc --><meta name="referrer" content="no-referrer" />]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot三种方法接口返回日期格式化</title>
    <link href="/article/a5d2a699.html"/>
    <url>/article/a5d2a699.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />### 方法一：@[JsonFormat注解](https://so.csdn.net/so/search?q=JsonFormat%E6%B3%A8%E8%A7%A3&spm=1001.2101.3001.7020)<p>在返回实体的字段上添加@JsonFormat注解。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">JsonFormat(<span class="hljs-params">pattern</span> = <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, <span class="hljs-params">timezone</span> = <span class="hljs-string">&quot;GMT+8&quot;</span>)</span><br><span class="hljs-keyword">private</span> Date createDate;<br><br></code></pre></td></tr></table></figure><p>pattern是<a href="https://so.csdn.net/so/search?q=%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F&spm=1001.2101.3001.7020">日期格式</a>，timezone是时间分区。格式具体可以参考下图：<br><img src="https://i-blog.csdnimg.cn/direct/027c0dd81c53430e8eeb503f68afbdec.png" alt="在这里插入图片描述"></p><h3 id="方法二：JsonConfig配置"><a href="#方法二：JsonConfig配置" class="headerlink" title="方法二：JsonConfig配置"></a>方法二：JsonConfig配置</h3><p>全局配置。好处：无需每个类配置日期格式坏处：不灵活，只能统一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xy.config;<br><br><span class="hljs-keyword">import</span> com.fasterxml.jackson.databind.SerializationFeature;<br><span class="hljs-keyword">import</span> com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.jackson.Jackson2ObjectMapperBuilderCustomizer;<br><span class="hljs-keyword">import</span> org.springframework.boot.jackson.JsonComponent;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.TimeZone;<br><br><span class="hljs-comment">//jackson日期</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@JsonComponent</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JacksonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;my.jackson.date-format:yyyy-MM-dd HH:mm:ss&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String pattern;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="hljs-title function_">jackson2ObjectMapperBuilder</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> builder -&gt; &#123;<br>            <span class="hljs-type">TimeZone</span> <span class="hljs-variable">tz</span> <span class="hljs-operator">=</span> TimeZone.getTimeZone(<span class="hljs-string">&quot;GMT+8&quot;</span>);<br>            <span class="hljs-type">DateFormat</span> <span class="hljs-variable">df</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(pattern);<br>            df.setTimeZone(tz);<br>            builder.failOnEmptyBeans(<span class="hljs-literal">false</span>)<br>                    .failOnUnknownProperties(<span class="hljs-literal">false</span>)<br>                    .featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)<br>                    .dateFormat(df);<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> LocalDateTimeSerializer <span class="hljs-title function_">localDateTimeDeserializer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(pattern));<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="hljs-title function_">jackson2ObjectMapperBuilderCustomizer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> builder -&gt; builder.serializerByType(LocalDateTime.class, localDateTimeDeserializer());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后配置文件里配置好格式就行。</p><h3 id="方法三：yml配置"><a href="#方法三：yml配置" class="headerlink" title="方法三：yml配置"></a>方法三：yml配置</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">jackson</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">date-format</span><span class="hljs-punctuation">:</span> <span class="hljs-string">yyyy-MM-dd HH:mm:ss</span><br>    <span class="hljs-attribute">time-zone</span><span class="hljs-punctuation">:</span> <span class="hljs-string">GMT+8</span><br></code></pre></td></tr></table></figure><p>UTC和 GMT区别UTC‌：协调世界时间（UTC）是基于原子时钟的时间计量系统，旨在尽量接近世界时（UT）。UTC的时间尺度是均匀的，不考虑地球自转速度的变化‌。‌GMT+8‌：格林威治平均时间加8小时，即东八区的本地时间。GMT+8通常用于表示中国北京时间‌‌UTC‌：在国际无线电通信、卫星导航等需要高精度时间计量的场合广泛使用‌。‌GMT+8‌：常用于表示中国北京时间，在电子邮件信头、软件显示时间等场合使用‌。总结：UTC和GMT+8基本相同，UTC更精确而GMT+8常代表北京时间。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三种方法个人推荐第三种。为什么，因为太方便了，另外如果有特殊格式，可以再加@JsonFormat单独注解，会优先以添加了@JsonFormat注解的为准。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务回滚后，自增ID仍然增加</title>
    <link href="/article/3214cdba.html"/>
    <url>/article/3214cdba.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />## [事务回滚](https://so.csdn.net/so/search?q=%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A&spm=1001.2101.3001.7020)后，自增ID仍然增加<p>回滚后，自增ID仍然增加。</p><p>比如当前ID是7，插入一条数据后，又回滚了。<br>然后你再插入一条数据，此时插入成功，这时候你的ID不是8，而是9.<br>因为虽然你之前插入回滚，但是ID还是自增了。</p><p>如果你认为自增ID不应该被事务化，那么其他事务不得不等待着，检查自增ID是被使用还是被回滚，这就导致阻塞。比如下面的例子，A表使用自增ID。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">User</span> <span class="hljs-number">1</span><br><span class="hljs-comment">------------</span><br><span class="hljs-keyword">begin</span> transaction<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> A ...<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> B ...<br><span class="hljs-keyword">update</span> C ...<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> D ...<br><span class="hljs-keyword">commit</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-section">User 2</span><br><span class="hljs-section">-----------</span><br>begin transaction<br>insert into A ...<br>insert into B ...<br>commit<br></code></pre></td></tr></table></figure><p>看以上的例子代码，如果自增ID也要被事务化，那么假设user 2 的事务在user 1执行后的1毫秒后执行，那么他的插入到A表不得不等待User 1的整个事务结束，检查第一个自增ID是不是被使用了。这就导致阻塞。</p><p><strong>自增ID不被事务化是设计使然，不是bug，如果需要紧密连续的自增序列，建议采用其他方法生成。</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">--不連續沒關係,需要時候生成一列</span><br><span class="hljs-keyword">if</span> object_id(<span class="hljs-string">&#x27;tb&#x27;</span>)<span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> tb<br>go<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb(ID <span class="hljs-type">int</span> )<br><span class="hljs-keyword">insert</span> tb <span class="hljs-keyword">select</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">insert</span> tb <span class="hljs-keyword">select</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">insert</span> tb <span class="hljs-keyword">select</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">insert</span> tb <span class="hljs-keyword">select</span> <span class="hljs-number">18</span><br><span class="hljs-keyword">insert</span> tb <span class="hljs-keyword">select</span> <span class="hljs-number">13</span><br><span class="hljs-keyword">select</span> id ,[newid]=(<span class="hljs-keyword">select</span> count(*) <span class="hljs-keyword">from</span> tb <span class="hljs-keyword">where</span> id&lt;=t.id) <span class="hljs-keyword">from</span> tb t <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> [newid]<br><span class="hljs-comment">/*id     newid   </span><br><span class="hljs-comment">----------- -----------</span><br><span class="hljs-comment">1      1</span><br><span class="hljs-comment">2      2</span><br><span class="hljs-comment">5      3</span><br><span class="hljs-comment">13     4</span><br><span class="hljs-comment">18     5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">(影響 5 個資料列)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="为什么mysql事务回滚后，自增ID依然自增"><a href="#为什么mysql事务回滚后，自增ID依然自增" class="headerlink" title="为什么mysql事务回滚后，自增ID依然自增"></a>为什么mysql事务回滚后，自增ID依然自增</h2><p>因为innodb的auto_increament的计数器记录的当前值是保存在存内 存中的，并不是存在于磁盘上，当mysql<br>server处于运行的时候，这个计数值只会随着<a href="https://so.csdn.net/so/search?q=insert&spm=1001.2101.3001.7020">insert</a>改增长，不会随着delete而减少。而当mysql<br>server启动时，当我们需要去查询auto_increment计数值时，mysql便会自动执行：SELECT MAX(id) FROM 表名<br>FOR UPDATE;语句来获得当前auto_increment列的最大值，然后将这个值放到auto_increment计数器中。所以就算<br>Rollback MySQL的auto_increament计数器也不会作负运算。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 经典缓存问题：一致性、穿透、击穿、雪崩与污染</title>
    <link href="/article/1c3f5ec1.html"/>
    <url>/article/1c3f5ec1.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p>Redis 是一种广泛应用的高性能内存数据库，常用于缓存场景以提升系统性能和用户体验。然而，使用 Redis 缓存时，可能会遇到一些经典问题，比如一致性问题、缓存穿击、缓存穿透、缓存雪崩，以及缓存污染等。这些问题如果不加以有效处理，可能导致系统性能下降，甚至引发服务不可用的严重后果。</p><p><img src="https://oscimg.oschina.net/oscnet/c2f99605-adfa-4d4b-b592-9abb4171a039.jpg"></p><p>本文主要探讨 Redis 作为缓存，在实践中可能会有哪些问题。</p><p><strong>本文目录：</strong></p><ul><li><p>为什么要理解 Redis 缓存问题</p></li><li><p>缓存穿透</p></li><li><p>缓存击穿</p></li><li><p>缓存雪崩</p></li><li><p>缓存污染</p></li><li><p>数据库和缓存一致性</p></li></ul><p> <strong>1. 为什么要理解 Redis 缓存问题</strong></p><hr><p>Redis 缓存能够显著提升数据访问速度，但其问题常与实际业务场景相关。深入理解这些问题及其解决方案，能够帮助开发者设计更加健壮和高效的系统架构。</p><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用 redis 做一个缓冲操作，让请求先访问到 redis，而不是直接访问 Mysql 等数据库。这样可以大大缓解数据库的压力。</p><p>当缓存库出现时，必须要考虑如下问题：</p><ul><li><p>缓存穿透</p></li><li><p>缓存穿击</p></li><li><p>缓存雪崩</p></li><li><p>缓存污染</p></li><li><p>缓存和数据库一致性</p></li></ul><p><strong>2. 缓存穿透</strong></p><hr><h3 id="问题定义："><a href="#问题定义：" class="headerlink" title="问题定义："></a><strong>问题定义：</strong></h3><p>缓存穿透指的是客户端频繁请求数据库中根本不存在的键，由于缓存中无法命中（因为数据不存在，无法写入缓存），每次请求都会直接访问数据库，导致数据库负载增加。</p><p><img src="https://oscimg.oschina.net/oscnet/c65e3f89-d69d-4d6b-9755-617e6e79042a.jpg"></p><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><p><strong>布隆过滤器</strong></p><p>在缓存层增加布隆过滤器，将可能的合法数据提前存储在布隆过滤器中，拦截非法请求。</p><p><img src="https://oscimg.oschina.net/oscnet/593a4a05-b12c-457d-adba-49a08df485c1.png"></p></li><li><p><strong>缓存空值</strong></p><p>对于不存在的键，也将其值设置为  <code>null</code>  并缓存一定时间，但需要注意避免缓存污染（详见后文）。</p></li></ol><p><strong>3. 缓存击穿</strong></p><hr><h3 id="问题定义：-1"><a href="#问题定义：-1" class="headerlink" title="问题定义："></a><strong>问题定义：</strong></h3><p>缓存击穿发生在某个热点缓存键过期时，大量请求同时涌向数据库，造成数据库瞬时压力过高。</p><p><img src="https://oscimg.oschina.net/oscnet/20d818ae-56f8-4670-b615-864d84a706d2.jpg"></p><h4 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><p><strong>设置热点数据不过期</strong></p><p>将热点数据的过期时间设置为极长，或者动态更新热点数据的过期时间。</p></li><li><p><strong>互斥锁</strong></p><p>对访问过期缓存的请求加锁，只有获取锁的请求可以加载数据并更新缓存，其余请求等待。</p></li></ol><p><strong>4. 缓存雪崩</strong></p><hr><h3 id="问题定义：-2"><a href="#问题定义：-2" class="headerlink" title="问题定义："></a>问题定义：</h3><p>缓存雪崩指的是大量缓存数据在同一时间段失效，导致所有请求都涌向数据库，引发数据库崩溃。</p><p><img src="https://oscimg.oschina.net/oscnet/16a0b50a-e17d-426f-b208-0455c31f055c.jpg"></p><h4 id="解决方法：-2"><a href="#解决方法：-2" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><p><strong>缓存过期时间分布化</strong></p><p>为不同的缓存键设置随机过期时间，避免同一时间大批量缓存失效。</p></li><li><p><strong>多级缓存</strong></p><p>在 Redis 缓存前增加本地缓存层，减轻数据库直接压力。</p></li><li><p><strong>降级限流</strong></p><p>在数据库压力过大时，开启服务降级或请求限流机制。</p></li></ol><p><strong>5. 缓存污染</strong></p><hr><h3 id="问题定义：-3"><a href="#问题定义：-3" class="headerlink" title="问题定义："></a>问题定义：</h3><p>缓存污染是指缓存中存储了低命中率或无意义的数据，占用了大量内存资源，降低缓存效率。</p><p><img src="https://oscimg.oschina.net/oscnet/466f5442-daac-413d-a1c1-84380bc348cf.jpg"></p><h4 id="解决方法：-3"><a href="#解决方法：-3" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><p><strong>设置缓存淘汰策略</strong></p><p>根据业务需求选择合适的淘汰策略（如 LRU、LFU）。</p></li><li><p><strong>过滤低价值数据</strong></p><p>对可能影响缓存效率的数据进行预处理，避免写入缓存。</p></li></ol><p><strong>6. 数据库和缓存一致性</strong></p><hr><h3 id="问题定义：-4"><a href="#问题定义：-4" class="headerlink" title="问题定义："></a>问题定义：</h3><p>Redis 缓存和数据库中的数据可能出现不一致的问题，尤其是在数据更新时，可能导致缓存中的数据陈旧。</p><p><img src="https://oscimg.oschina.net/oscnet/0699db42-903c-4de3-9d41-03e66c80bc8e.jpg"></p><h4 id="解决方法：-4"><a href="#解决方法：-4" class="headerlink" title="解决方法："></a>解决方法：</h4><ol><li><p><strong>删除缓存策略</strong></p><p>在更新数据库后立即删除缓存，使下一次访问重新加载最新数据。</p><p>注意，我们的更新是先更新数据库，成功后，让缓存失效。</p></li><li><p><strong>延时双删策略</strong></p><p>在更新数据库后，删除缓存，并在一定延时后再次删除缓存，确保缓存数据更新。</p><p><img src="https://oscimg.oschina.net/oscnet/45ef7f3f-0832-46c1-84f5-65a58ae0aacf.jpg"></p></li><li><p><strong>订阅通知</strong></p><p>通过 Redis 的 Pub&#x2F;Sub 功能或类似工具（如 Canal）监听数据库变更并同步更新缓存。</p></li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h3><hr><p>Redis 是一个强大的缓存工具，但在高并发场景中，缓存相关问题如穿透、击穿和雪崩可能严重影响系统的稳定性。了解这些问题并采用合适的解决方案，是设计高性能系统的关键。希望本文能为您解决实际问题提供帮助！</p><hr>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>@Transactional 失效场景</title>
    <link href="/article/e0bb1c9a.html"/>
    <url>/article/e0bb1c9a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />  <p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据或者执行多条sql。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd5de7a66d2a919e9210b222a7dce169.png" alt="强大的spring框架，为我们提供了一个简单的注解：@Transactional，就能轻松搞定事务，一直用一直爽啊！！"></p><h2 id="一-、事务不生效【七种】"><a href="#一-、事务不生效【七种】" class="headerlink" title="一 、事务不生效【七种】"></a>一 、事务不生效【七种】</h2><h3 id="1-访问权限问题-只有public方法会生效"><a href="#1-访问权限问题-只有public方法会生效" class="headerlink" title="1.访问权限问题 (只有public方法会生效)"></a>1.访问权限问题 (只有public方法会生效)</h3><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    private void add(UserModel userModel) &#123;<br>         <span class="hljs-built_in">saveData</span>(userModel);<br>         <span class="hljs-built_in">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须得是public的。</p><p>说白了，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，<strong>如果目标方法不是public</strong>，则TransactionAttribute返回null，即不支持事务。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected TransactionAttribute compute<span class="hljs-constructor">TransactionAttribute(Method <span class="hljs-params">method</span>, @Nullable Class&lt;?&gt; <span class="hljs-params">targetClass</span>)</span> &#123;<br>    <span class="hljs-comment">// Don&#x27;t allow no-public methods as required.可以看到， 这里不支持public类型的方法</span><br>    <span class="hljs-keyword">if</span> (allow<span class="hljs-constructor">PublicMethodsOnly()</span><span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Public(<span class="hljs-params">method</span>.<span class="hljs-params">getModifiers</span>()</span>)) &#123;<br>      return null;<br>    &#125;<br><br>    <span class="hljs-comment">// The method may be on an interface, but we need attributes from the target class.</span><br>    <span class="hljs-comment">// If the target class is null, the method will be unchanged.</span><br>    Method specificMethod = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AopUtils</span>.</span></span>get<span class="hljs-constructor">MostSpecificMethod(<span class="hljs-params">method</span>, <span class="hljs-params">targetClass</span>)</span>;<br><br>    <span class="hljs-comment">// First try is the method in the target class.</span><br>    TransactionAttribute txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">specificMethod</span>)</span>;<br>    <span class="hljs-keyword">if</span> (txAttr != null) &#123;<br>      return txAttr;<br>    &#125;<br><br>    <span class="hljs-comment">// Second try is the transaction attribute on the target class.</span><br>    txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">specificMethod</span>.<span class="hljs-params">getDeclaringClass</span>()</span>);<br>    <span class="hljs-keyword">if</span> (txAttr != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>is<span class="hljs-constructor">UserLevelMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>      return txAttr;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (specificMethod != <span class="hljs-keyword">method</span>) &#123;<br>      <span class="hljs-comment">// Fallback is to look at the original method.</span><br>      txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>)</span>;<br>      <span class="hljs-keyword">if</span> (txAttr != null) &#123;<br>        return txAttr;<br>      &#125;<br>      <span class="hljs-comment">// Last fallback is the class of the original method.</span><br>      txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>);<br>      <span class="hljs-keyword">if</span> (txAttr != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>is<span class="hljs-constructor">UserLevelMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>        return txAttr;<br>      &#125;<br>    &#125;<br>    return null;<br>  &#125;<br></code></pre></td></tr></table></figure><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是public，而是private、default或protected的话，spring则不会提供事务功能。</p><h3 id="2-方法用final修饰，不会生效"><a href="#2-方法用final修饰，不会生效" class="headerlink" title="2.方法用final修饰，不会生效"></a>2.方法用final修饰，不会生效</h3><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span></span>&#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法被定义成了final的，这样会导致<a href="https://so.csdn.net/so/search?q=%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88&spm=1001.2101.3001.7020">事务失效</a>。</p><p>为什么？</p><p>如果你看过<a href="https://so.csdn.net/so/search?q=spring%E4%BA%8B%E5%8A%A1&spm=1001.2101.3001.7020">spring事务</a>的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。<strong>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法</strong>，而添加事务功能。</p><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p><h3 id="3-同一个类中的方法直接内部调用，会导致事务失效"><a href="#3-同一个类中的方法直接内部调用，会导致事务失效" class="headerlink" title="3.同一个类中的方法直接内部调用，会导致事务失效"></a>3.同一个类中的方法直接内部调用，会导致事务失效</h3><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        <span class="hljs-title function_">updateStatus</span>(userModel);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        <span class="hljs-title function_">doSameThing</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。<a href="https://blog.csdn.net/yyoc97/article/details/81911744">根本原因</a> <a href="https://blog.csdn.net/mccand1234/article/details/124578233">根本原因2</a></p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h4 id="3-1-新加一个Service方法"><a href="#3-1-新加一个Service方法" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h4><p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br>   <span class="hljs-keyword">@Autowired</span><br>   prvate ServiceB serviceB;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         serviceB<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">@Servcie</span><br> public class ServiceB &#123;<br><br>    <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>    public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-在该Service类中注入自己"><a href="#3-2-在该Service类中注入自己" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h4><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br>   <span class="hljs-keyword">@Autowired</span><br>   prvate ServiceA serviceA;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         serviceA<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br><br>   <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>   public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的<a href="https://blog.csdn.net/mccand1234/article/details/116403266">三级缓存</a>保证了它，不会出现循环依赖问题。</p><h4 id="3-3-通过AopContent类"><a href="#3-3-通过AopContent类" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h4><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         ((ServiceA)AopContext<span class="hljs-selector-class">.currentProxy</span>())<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br><br>   <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>   public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="4-类本身-未被spring管理"><a href="#4-类本身-未被spring管理" class="headerlink" title="4.(类本身) 未被spring管理"></a>4.(类本身) 未被spring管理</h3><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。当然创建bean实例的方法还有很多，不一一说了。有兴趣的小伙伴可以参考这篇文章：@Autowired的这些骚操作，你都知道吗？</p><p>如下所示, 开发了一个Service类，但忘了加@Service注解，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>         <span class="hljs-title function_">saveData</span>(userModel);<br>         <span class="hljs-title function_">updateData</span>(userModel);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子，我们可以看到UserService类没有加@Service注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p><h3 id="5-多线程调用"><a href="#5-多线程调用" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h3><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        userMapper.insertUser(userModel);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            roleService.doOtherThing();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doOtherThing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt;&gt; resources =<br><br>  <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">&quot;Transactional resources&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h3 id="6-存储引擎-表不支持事务"><a href="#6-存储引擎-表不支持事务" class="headerlink" title="6.(存储引擎)表不支持事务"></a>6.(存储引擎)表不支持事务</h3><p>周所周知，在mysql5之前，默认的数据库引擎是myisam。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把ENGINE参数设置成MyISAM即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `category` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `one_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `two_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `three_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `four_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_bin<br></code></pre></td></tr></table></figure><p>myisam好用，但有个很致命的问题是：<strong>不支持事务</strong>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p><h3 id="7-未开启事务"><a href="#7-未开启事务" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h3><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的帮你开启了事务。</p><p>你所要做的事情很简单，只需要配置spring.datasource相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- 用切点把事务切进去 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.susan.*.*(..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span> <br><br></code></pre></td></tr></table></figure><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p><h2 id="二、事务不回滚【五种】"><a href="#二、事务不回滚【五种】" class="headerlink" title="二、事务不回滚【五种】"></a>二、事务不回滚【五种】</h2><h3 id="1-错误的传播特性"><a href="#1-错误的传播特性" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h3><p>其实，我们在使用@Transactional注解时，是可以指定propagation参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><p>REQUIRED 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。<br>SUPPORTS 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。<br>MANDATORY 如果当前上下文中存在事务，否则抛出异常。<br>REQUIRES_NEW 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。<br>NOT_SUPPORTED 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。<br>NEVER 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。<br>NESTED 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。<br>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.NEVER)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UserModel userModel)</span> &#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h3 id="2-自己吞了异常"><a href="#2-自己吞了异常" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h3><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。比如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) &#123;<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">saveData</span>(userModel);<br>            <span class="hljs-selector-tag">updateData</span>(userModel);<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.error</span>(e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下spring事务当然不会回滚，因为开发者<strong>自己捕获了异常</strong>，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h3 id="3-手动抛了别的异常"><a href="#3-手动抛了别的异常" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h3><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>             saveData(userModel);<br>             updateData(userModel);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.<span class="hljs-keyword">error</span>(e.getMessage(), e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。  </p><p>因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），对于普通的Exception（<a href="https://blog.csdn.net/mccand1234/article/details/51579425?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165164871416780357228953%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165164871416780357228953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-51579425.nonecase&utm_term=error&spm=1018.2226.3001.4450">非运行时异常</a>），它不会回滚。比如常见的IOExeption和SQLException</p><h3 id="4-自定义了回滚异常"><a href="#4-自定义了回滚异常" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h3><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置rollbackFor参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-variable">@Transactional</span>(rollbackFor = BusinessException.class)<br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-selector-tag">saveData</span>(userModel);<br>       <span class="hljs-selector-tag">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>这是为什么呢？</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h3 id="5-嵌套事务回滚多了"><a href="#5-嵌套事务回滚多了" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        userMapper.insertUser(userModel);<br>        roleService.doOtherThing();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOtherThing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。但事实是，insertUser也回滚了。</p><p>why?</p><p>因为doOtherThing方法出现了异常，<strong>没有手动捕获</strong>，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private UserMapper userMapper;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private RoleService roleService;<br><br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) throws Exception &#123;<br><br>        <span class="hljs-selector-tag">userMapper</span><span class="hljs-selector-class">.insertUser</span>(userModel);<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">roleService</span><span class="hljs-selector-class">.doOtherThing</span>();<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.error</span>(e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将内部嵌套事务放在try&#x2F;catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h2 id="三、大事务与编程式事务"><a href="#三、大事务与编程式事务" class="headerlink" title="三、大事务与编程式事务"></a>三、大事务与编程式事务</h2><h3 id="1-大事务问题"><a href="#1-大事务问题" class="headerlink" title="1. 大事务问题"></a>1. 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。<br>关于大事务可参考：<a href="https://blog.csdn.net/mccand1234/article/details/124560532">大事务问题</a></p><p>通常情况下，我们会在方法上@Transactional注解，填加事务功能，比如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span> <br>    private RoleService roleService;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    public void add(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-built_in">query1</span>();<br>       <span class="hljs-built_in">query2</span>();<br>       <span class="hljs-built_in">query3</span>();<br>       roleService<span class="hljs-selector-class">.save</span>(userModel);<br>       <span class="hljs-built_in">update</span>(userModel);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">@Service</span><br>public class RoleService &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span> <br>    private RoleService roleService;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    public void save(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-built_in">query4</span>();<br>       <span class="hljs-built_in">query5</span>();<br>       <span class="hljs-built_in">query6</span>();<br>       <span class="hljs-built_in">saveData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但@Transactional注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">roleService<span class="hljs-selector-class">.save</span>(userModel);<br><span class="hljs-built_in">update</span>(userModel);<br></code></pre></td></tr></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">save<span class="hljs-constructor">Data(<span class="hljs-params">userModel</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><h3 id="2-编程式事务"><a href="#2-编程式事务" class="headerlink" title="2. 编程式事务"></a>2. 编程式事务</h3><p>上面的这些内容都是基于@Transactional注解的，主要讲的是它的事务问题，我们把这种事务叫做：声明式事务。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：编程式事务。例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Autowired</span><br>private TransactionTemplate transactionTemplate;<br><br>public void <span class="hljs-built_in">save</span>(final User user) &#123;<br>      <span class="hljs-built_in">queryData1</span>();<br>      <span class="hljs-built_in">queryData2</span>();<br>      transactionTemplate<span class="hljs-selector-class">.execute</span>(transactionStatus -&gt; &#123;<br>         addData1();<br>         <span class="hljs-built_in">updateData2</span>();<br>         return Boolean<span class="hljs-selector-class">.TRUE</span>;<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于@Transactional注解声明式事务，更建议大家使用，基于TransactionTemplate的编程式事务。主要原因如下：</p><p>避免由于spring aop问题，导致事务失效的问题。<br>能够更小粒度的控制事务的范围，更直观。<br>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p><p>参考:<br><a href="https://blog.csdn.net/wang/_luwei/article/details/121549005">https://blog.csdn.net/wang\_luwei/article/details/121549005</a> (spring事务（注解 @Transactional ）失效的12种场景)<br><a href="https://www.bilibili.com/video/BV1fR4y1u7N8?spm%5C_id%5C_from=333.337.search-card.all.click(%E5%88%86%E6%9E%90spring%E4%BA%8B%E5%8A%A1@Transactional%E6%B3%A8%E8%A7%A3,%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)">https://www.bilibili.com/video/BV1fR4y1u7N8?spm\_id\_from=333.337.search-card.all.click(分析spring事务@Transactional注解,事务不生效的场景及原因，和解决方案)</a></p><p>   </p><p>显示推荐内容# spring事务（注解 @Transactional ）失效的12种场景</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/mccand1234" title="春天的早晨">春天的早晨</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newUpTime2.png"> 已于 2022-05-04 21:52:01 修改</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png"> 阅读量3.4w <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png"> 收藏 788</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png"> 点赞数 104</p><p>分类专栏： <a href="https://blog.csdn.net/mccand1234/category_8743333.html">面试</a> <a href="https://blog.csdn.net/mccand1234/category_6432539.html">Spring</a> 文章标签： <a href="https://so.csdn.net/so/search/s.do?q=spring&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art">spring</a> <a href="https://so.csdn.net/so/search/s.do?q=%E4%BA%8B%E5%8A%A1&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art">事务</a></p><p>于 2022-05-04 15:57:04 首次发布</p><p>原文链接：<a href="https://blog.csdn.net/wang_luwei/article/details/121549005">https://blog.csdn.net/wang_luwei&#x2F;article&#x2F;details&#x2F;121549005</a></p><p>版权</p><p> <a href="javascript:;" title="GitCode 开源社区"><img src="https://devpress.csdnimg.cn/8bc8dd1a2bc24184a16a142654c4a49e.png"> GitCode 开源社区 文章已被社区收录</a></p><p>加入社区</p><p> <a href="https://blog.csdn.net/mccand1234/category_8743333.html" title="面试"><img src="https://i-blog.csdnimg.cn/columns/default/20201014180756928.png?x-oss-process=image/resize,m_fixed,h_224,w_224"> 面试 同时被 2 个专栏收录<img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newArrowDown1White.png"></a></p><p>57 篇文章 4 订阅</p><p>订阅专栏</p><p> <a href="https://blog.csdn.net/mccand1234/category_6432539.html" title="Spring"><img src="https://i-blog.csdnimg.cn/columns/default/20201014180756780.png?x-oss-process=image/resize,m_fixed,h_224,w_224"> Spring</a></p><p>31 篇文章 1 订阅</p><p>订阅专栏</p><p><img src="https://img-home.csdnimg.cn/images/20240711042549.png"> 本文详细分析了Spring事务管理中@Transactional注解失效的七种情况，包括访问权限、final修饰、内部调用、未被管理、多线程、存储引擎不支持事务以及未开启事务。同时，探讨了事务不回滚的五种原因，如错误的传播特性、异常处理不当等。最后，讨论了大事务问题和编程式事务的优势，强调了如何更好地控制事务范围和避免大事务问题。</p><p>摘要由CSDN通过智能技术生成</p><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#__6">一 、事务不生效【七种】</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#1_public_7">1.访问权限问题 (只有public方法会生效)</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#2final_65">2.方法用final修饰，不会生效</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#3_86">3.同一个类中的方法直接内部调用，会导致事务失效</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#31_Service_113">3.1 新加一个Service方法</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#32_Service_139">3.2 在该Service类中注入自己</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#33_AopContent_166">3.3 通过AopContent类</a></li></ul></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#4_spring_187">4.(类本身) 未被spring管理</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#5_206">5.多线程调用</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#6_249">6.(存储引擎)表不支持事务</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#7_277">7.未开启事务</a></li></ul></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#_318">二、事务不回滚【五种】</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#1_319">1.错误的传播特性</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#2_347">2.自己吞了异常</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#3_369">3.手动抛了别的异常</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#4_392">4.自定义了回滚异常</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#5_416">5.嵌套事务回滚多了</a></li></ul></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#_474">三、大事务与编程式事务</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#1__475">1. 大事务问题</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#2__528">2. 编程式事务</a></li></ul></li></ul><p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据或者执行多条sql。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd5de7a66d2a919e9210b222a7dce169.png" alt="强大的spring框架，为我们提供了一个简单的注解：@Transactional，就能轻松搞定事务，一直用一直爽啊！！"></p><h2 id="一-、事务不生效【七种】-1"><a href="#一-、事务不生效【七种】-1" class="headerlink" title="一 、事务不生效【七种】"></a>一 、事务不生效【七种】</h2><h3 id="1-访问权限问题-只有public方法会生效-1"><a href="#1-访问权限问题-只有public方法会生效-1" class="headerlink" title="1.访问权限问题 (只有public方法会生效)"></a>1.访问权限问题 (只有public方法会生效)</h3><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    private void add(UserModel userModel) &#123;<br>         <span class="hljs-built_in">saveData</span>(userModel);<br>         <span class="hljs-built_in">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须得是public的。</p><p>说白了，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，<strong>如果目标方法不是public</strong>，则TransactionAttribute返回null，即不支持事务。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected TransactionAttribute compute<span class="hljs-constructor">TransactionAttribute(Method <span class="hljs-params">method</span>, @Nullable Class&lt;?&gt; <span class="hljs-params">targetClass</span>)</span> &#123;<br>    <span class="hljs-comment">// Don&#x27;t allow no-public methods as required.可以看到， 这里不支持public类型的方法</span><br>    <span class="hljs-keyword">if</span> (allow<span class="hljs-constructor">PublicMethodsOnly()</span><span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Public(<span class="hljs-params">method</span>.<span class="hljs-params">getModifiers</span>()</span>)) &#123;<br>      return null;<br>    &#125;<br><br>    <span class="hljs-comment">// The method may be on an interface, but we need attributes from the target class.</span><br>    <span class="hljs-comment">// If the target class is null, the method will be unchanged.</span><br>    Method specificMethod = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AopUtils</span>.</span></span>get<span class="hljs-constructor">MostSpecificMethod(<span class="hljs-params">method</span>, <span class="hljs-params">targetClass</span>)</span>;<br><br>    <span class="hljs-comment">// First try is the method in the target class.</span><br>    TransactionAttribute txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">specificMethod</span>)</span>;<br>    <span class="hljs-keyword">if</span> (txAttr != null) &#123;<br>      return txAttr;<br>    &#125;<br><br>    <span class="hljs-comment">// Second try is the transaction attribute on the target class.</span><br>    txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">specificMethod</span>.<span class="hljs-params">getDeclaringClass</span>()</span>);<br>    <span class="hljs-keyword">if</span> (txAttr != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>is<span class="hljs-constructor">UserLevelMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>      return txAttr;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (specificMethod != <span class="hljs-keyword">method</span>) &#123;<br>      <span class="hljs-comment">// Fallback is to look at the original method.</span><br>      txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>)</span>;<br>      <span class="hljs-keyword">if</span> (txAttr != null) &#123;<br>        return txAttr;<br>      &#125;<br>      <span class="hljs-comment">// Last fallback is the class of the original method.</span><br>      txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>);<br>      <span class="hljs-keyword">if</span> (txAttr != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>is<span class="hljs-constructor">UserLevelMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>        return txAttr;<br>      &#125;<br>    &#125;<br>    return null;<br>  &#125;<br></code></pre></td></tr></table></figure><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是public，而是private、default或protected的话，spring则不会提供事务功能。</p><h3 id="2-方法用final修饰，不会生效-1"><a href="#2-方法用final修饰，不会生效-1" class="headerlink" title="2.方法用final修饰，不会生效"></a>2.方法用final修饰，不会生效</h3><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span></span>&#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法被定义成了final的，这样会导致<a href="https://so.csdn.net/so/search?q=%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88&spm=1001.2101.3001.7020">事务失效</a>。</p><p>为什么？</p><p>如果你看过<a href="https://so.csdn.net/so/search?q=spring%E4%BA%8B%E5%8A%A1&spm=1001.2101.3001.7020">spring事务</a>的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。<strong>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法</strong>，而添加事务功能。</p><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p><h3 id="3-同一个类中的方法直接内部调用，会导致事务失效-1"><a href="#3-同一个类中的方法直接内部调用，会导致事务失效-1" class="headerlink" title="3.同一个类中的方法直接内部调用，会导致事务失效"></a>3.同一个类中的方法直接内部调用，会导致事务失效</h3><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        <span class="hljs-title function_">updateStatus</span>(userModel);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        <span class="hljs-title function_">doSameThing</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。<a href="https://blog.csdn.net/yyoc97/article/details/81911744">根本原因</a> <a href="https://blog.csdn.net/mccand1234/article/details/124578233">根本原因2</a></p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h4 id="3-1-新加一个Service方法-1"><a href="#3-1-新加一个Service方法-1" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h4><p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br>   <span class="hljs-keyword">@Autowired</span><br>   prvate ServiceB serviceB;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         serviceB<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">@Servcie</span><br> public class ServiceB &#123;<br><br>    <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>    public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-在该Service类中注入自己-1"><a href="#3-2-在该Service类中注入自己-1" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h4><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br>   <span class="hljs-keyword">@Autowired</span><br>   prvate ServiceA serviceA;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         serviceA<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br><br>   <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>   public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的<a href="https://blog.csdn.net/mccand1234/article/details/116403266">三级缓存</a>保证了它，不会出现循环依赖问题。</p><h4 id="3-3-通过AopContent类-1"><a href="#3-3-通过AopContent类-1" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h4><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         ((ServiceA)AopContext<span class="hljs-selector-class">.currentProxy</span>())<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br><br>   <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>   public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="4-类本身-未被spring管理-1"><a href="#4-类本身-未被spring管理-1" class="headerlink" title="4.(类本身) 未被spring管理"></a>4.(类本身) 未被spring管理</h3><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。当然创建bean实例的方法还有很多，不一一说了。有兴趣的小伙伴可以参考这篇文章：@Autowired的这些骚操作，你都知道吗？</p><p>如下所示, 开发了一个Service类，但忘了加@Service注解，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>         <span class="hljs-title function_">saveData</span>(userModel);<br>         <span class="hljs-title function_">updateData</span>(userModel);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子，我们可以看到UserService类没有加@Service注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p><h3 id="5-多线程调用-1"><a href="#5-多线程调用-1" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h3><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        userMapper.insertUser(userModel);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            roleService.doOtherThing();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doOtherThing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt;&gt; resources =<br><br>  <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">&quot;Transactional resources&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h3 id="6-存储引擎-表不支持事务-1"><a href="#6-存储引擎-表不支持事务-1" class="headerlink" title="6.(存储引擎)表不支持事务"></a>6.(存储引擎)表不支持事务</h3><p>周所周知，在mysql5之前，默认的数据库引擎是myisam。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把ENGINE参数设置成MyISAM即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `category` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `one_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `two_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `three_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `four_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_bin<br></code></pre></td></tr></table></figure><p>myisam好用，但有个很致命的问题是：<strong>不支持事务</strong>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p><h3 id="7-未开启事务-1"><a href="#7-未开启事务-1" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h3><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的帮你开启了事务。</p><p>你所要做的事情很简单，只需要配置spring.datasource相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- 用切点把事务切进去 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.susan.*.*(..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span> <br><br></code></pre></td></tr></table></figure><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p><h2 id="二、事务不回滚【五种】-1"><a href="#二、事务不回滚【五种】-1" class="headerlink" title="二、事务不回滚【五种】"></a>二、事务不回滚【五种】</h2><h3 id="1-错误的传播特性-1"><a href="#1-错误的传播特性-1" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h3><p>其实，我们在使用@Transactional注解时，是可以指定propagation参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><p>REQUIRED 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。<br>SUPPORTS 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。<br>MANDATORY 如果当前上下文中存在事务，否则抛出异常。<br>REQUIRES_NEW 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。<br>NOT_SUPPORTED 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。<br>NEVER 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。<br>NESTED 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。<br>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.NEVER)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UserModel userModel)</span> &#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h3 id="2-自己吞了异常-1"><a href="#2-自己吞了异常-1" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h3><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。比如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) &#123;<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">saveData</span>(userModel);<br>            <span class="hljs-selector-tag">updateData</span>(userModel);<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.error</span>(e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下spring事务当然不会回滚，因为开发者<strong>自己捕获了异常</strong>，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h3 id="3-手动抛了别的异常-1"><a href="#3-手动抛了别的异常-1" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h3><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>             saveData(userModel);<br>             updateData(userModel);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.<span class="hljs-keyword">error</span>(e.getMessage(), e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。  </p><p>因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），对于普通的Exception（<a href="https://blog.csdn.net/mccand1234/article/details/51579425?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165164871416780357228953%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165164871416780357228953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-51579425.nonecase&utm_term=error&spm=1018.2226.3001.4450">非运行时异常</a>），它不会回滚。比如常见的IOExeption和SQLException</p><h3 id="4-自定义了回滚异常-1"><a href="#4-自定义了回滚异常-1" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h3><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置rollbackFor参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-variable">@Transactional</span>(rollbackFor = BusinessException.class)<br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-selector-tag">saveData</span>(userModel);<br>       <span class="hljs-selector-tag">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>这是为什么呢？</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h3 id="5-嵌套事务回滚多了-1"><a href="#5-嵌套事务回滚多了-1" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        userMapper.insertUser(userModel);<br>        roleService.doOtherThing();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOtherThing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。但事实是，insertUser也回滚了。</p><p>why?</p><p>因为doOtherThing方法出现了异常，<strong>没有手动捕获</strong>，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private UserMapper userMapper;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private RoleService roleService;<br><br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) throws Exception &#123;<br><br>        <span class="hljs-selector-tag">userMapper</span><span class="hljs-selector-class">.insertUser</span>(userModel);<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">roleService</span><span class="hljs-selector-class">.doOtherThing</span>();<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.error</span>(e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将内部嵌套事务放在try&#x2F;catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h2 id="三、大事务与编程式事务-1"><a href="#三、大事务与编程式事务-1" class="headerlink" title="三、大事务与编程式事务"></a>三、大事务与编程式事务</h2><h3 id="1-大事务问题-1"><a href="#1-大事务问题-1" class="headerlink" title="1. 大事务问题"></a>1. 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。<br>关于大事务可参考：<a href="https://blog.csdn.net/mccand1234/article/details/124560532">大事务问题</a></p><p>通常情况下，我们会在方法上@Transactional注解，填加事务功能，比如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span> <br>    private RoleService roleService;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    public void add(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-built_in">query1</span>();<br>       <span class="hljs-built_in">query2</span>();<br>       <span class="hljs-built_in">query3</span>();<br>       roleService<span class="hljs-selector-class">.save</span>(userModel);<br>       <span class="hljs-built_in">update</span>(userModel);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">@Service</span><br>public class RoleService &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span> <br>    private RoleService roleService;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    public void save(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-built_in">query4</span>();<br>       <span class="hljs-built_in">query5</span>();<br>       <span class="hljs-built_in">query6</span>();<br>       <span class="hljs-built_in">saveData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但@Transactional注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">roleService<span class="hljs-selector-class">.save</span>(userModel);<br><span class="hljs-built_in">update</span>(userModel);<br></code></pre></td></tr></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">save<span class="hljs-constructor">Data(<span class="hljs-params">userModel</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><h3 id="2-编程式事务-1"><a href="#2-编程式事务-1" class="headerlink" title="2. 编程式事务"></a>2. 编程式事务</h3><p>上面的这些内容都是基于@Transactional注解的，主要讲的是它的事务问题，我们把这种事务叫做：声明式事务。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：编程式事务。例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Autowired</span><br>private TransactionTemplate transactionTemplate;<br><br>public void <span class="hljs-built_in">save</span>(final User user) &#123;<br>      <span class="hljs-built_in">queryData1</span>();<br>      <span class="hljs-built_in">queryData2</span>();<br>      transactionTemplate<span class="hljs-selector-class">.execute</span>(transactionStatus -&gt; &#123;<br>         addData1();<br>         <span class="hljs-built_in">updateData2</span>();<br>         return Boolean<span class="hljs-selector-class">.TRUE</span>;<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于@Transactional注解声明式事务，更建议大家使用，基于TransactionTemplate的编程式事务。主要原因如下：</p><p>避免由于spring aop问题，导致事务失效的问题。<br>能够更小粒度的控制事务的范围，更直观。<br>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p><p>参考:<br><a href="https://blog.csdn.net/wang/_luwei/article/details/121549005">https://blog.csdn.net/wang\_luwei/article/details/121549005</a> (spring事务（注解 @Transactional ）失效的12种场景)<br><a href="https://www.bilibili.com/video/BV1fR4y1u7N8?spm%5C_id%5C_from=333.337.search-card.all.click(%E5%88%86%E6%9E%90spring%E4%BA%8B%E5%8A%A1@Transactional%E6%B3%A8%E8%A7%A3,%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%8C%E5%92%8C%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)">https://www.bilibili.com/video/BV1fR4y1u7N8?spm\_id\_from=333.337.search-card.all.click(分析spring事务@Transactional注解,事务不生效的场景及原因，和解决方案)</a></p><p>   </p><p>显示推荐内容# spring事务（注解 @Transactional ）失效的12种场景</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png"></p><p><a href="https://blog.csdn.net/mccand1234" title="春天的早晨">春天的早晨</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newUpTime2.png"> 已于 2022-05-04 21:52:01 修改</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png"> 阅读量3.4w <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png"> 收藏 788</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png"> 点赞数 104</p><p>分类专栏： <a href="https://blog.csdn.net/mccand1234/category_8743333.html">面试</a> <a href="https://blog.csdn.net/mccand1234/category_6432539.html">Spring</a> 文章标签： <a href="https://so.csdn.net/so/search/s.do?q=spring&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art">spring</a> <a href="https://so.csdn.net/so/search/s.do?q=%E4%BA%8B%E5%8A%A1&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art">事务</a></p><p>于 2022-05-04 15:57:04 首次发布</p><p>原文链接：<a href="https://blog.csdn.net/wang_luwei/article/details/121549005">https://blog.csdn.net/wang_luwei&#x2F;article&#x2F;details&#x2F;121549005</a></p><p>版权</p><p> <a href="javascript:;" title="GitCode 开源社区"><img src="https://devpress.csdnimg.cn/8bc8dd1a2bc24184a16a142654c4a49e.png"> GitCode 开源社区 文章已被社区收录</a></p><p>加入社区</p><p> <a href="https://blog.csdn.net/mccand1234/category_8743333.html" title="面试"><img src="https://i-blog.csdnimg.cn/columns/default/20201014180756928.png?x-oss-process=image/resize,m_fixed,h_224,w_224"> 面试 同时被 2 个专栏收录<img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newArrowDown1White.png"></a></p><p>57 篇文章 4 订阅</p><p>订阅专栏</p><p> <a href="https://blog.csdn.net/mccand1234/category_6432539.html" title="Spring"><img src="https://i-blog.csdnimg.cn/columns/default/20201014180756780.png?x-oss-process=image/resize,m_fixed,h_224,w_224"> Spring</a></p><p>31 篇文章 1 订阅</p><p>订阅专栏</p><p><img src="https://img-home.csdnimg.cn/images/20240711042549.png"> 本文详细分析了Spring事务管理中@Transactional注解失效的七种情况，包括访问权限、final修饰、内部调用、未被管理、多线程、存储引擎不支持事务以及未开启事务。同时，探讨了事务不回滚的五种原因，如错误的传播特性、异常处理不当等。最后，讨论了大事务问题和编程式事务的优势，强调了如何更好地控制事务范围和避免大事务问题。</p><p>摘要由CSDN通过智能技术生成</p><h4 id="文章目录-1"><a href="#文章目录-1" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#__6">一 、事务不生效【七种】</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#1_public_7">1.访问权限问题 (只有public方法会生效)</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#2final_65">2.方法用final修饰，不会生效</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#3_86">3.同一个类中的方法直接内部调用，会导致事务失效</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#31_Service_113">3.1 新加一个Service方法</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#32_Service_139">3.2 在该Service类中注入自己</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#33_AopContent_166">3.3 通过AopContent类</a></li></ul></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#4_spring_187">4.(类本身) 未被spring管理</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#5_206">5.多线程调用</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#6_249">6.(存储引擎)表不支持事务</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#7_277">7.未开启事务</a></li></ul></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#_318">二、事务不回滚【五种】</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#1_319">1.错误的传播特性</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#2_347">2.自己吞了异常</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#3_369">3.手动抛了别的异常</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#4_392">4.自定义了回滚异常</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#5_416">5.嵌套事务回滚多了</a></li></ul></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#_474">三、大事务与编程式事务</a></li><li><ul><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#1__475">1. 大事务问题</a></li><li><a href="https://blog.csdn.net/mccand1234/article/details/124571619#2__528">2. 编程式事务</a></li></ul></li></ul><p>在某些业务场景下，如果一个请求中，需要同时写入多张表的数据或者执行多条sql。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd5de7a66d2a919e9210b222a7dce169.png" alt="强大的spring框架，为我们提供了一个简单的注解：@Transactional，就能轻松搞定事务，一直用一直爽啊！！"></p><h2 id="一-、事务不生效【七种】-2"><a href="#一-、事务不生效【七种】-2" class="headerlink" title="一 、事务不生效【七种】"></a>一 、事务不生效【七种】</h2><h3 id="1-访问权限问题-只有public方法会生效-2"><a href="#1-访问权限问题-只有public方法会生效-2" class="headerlink" title="1.访问权限问题 (只有public方法会生效)"></a>1.访问权限问题 (只有public方法会生效)</h3><p>众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。</p><p>但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    private void add(UserModel userModel) &#123;<br>         <span class="hljs-built_in">saveData</span>(userModel);<br>         <span class="hljs-built_in">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须得是public的。</p><p>说白了，在AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，<strong>如果目标方法不是public</strong>，则TransactionAttribute返回null，即不支持事务。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected TransactionAttribute compute<span class="hljs-constructor">TransactionAttribute(Method <span class="hljs-params">method</span>, @Nullable Class&lt;?&gt; <span class="hljs-params">targetClass</span>)</span> &#123;<br>    <span class="hljs-comment">// Don&#x27;t allow no-public methods as required.可以看到， 这里不支持public类型的方法</span><br>    <span class="hljs-keyword">if</span> (allow<span class="hljs-constructor">PublicMethodsOnly()</span><span class="hljs-operator"> &amp;&amp; </span>!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Modifier</span>.</span></span>is<span class="hljs-constructor">Public(<span class="hljs-params">method</span>.<span class="hljs-params">getModifiers</span>()</span>)) &#123;<br>      return null;<br>    &#125;<br><br>    <span class="hljs-comment">// The method may be on an interface, but we need attributes from the target class.</span><br>    <span class="hljs-comment">// If the target class is null, the method will be unchanged.</span><br>    Method specificMethod = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AopUtils</span>.</span></span>get<span class="hljs-constructor">MostSpecificMethod(<span class="hljs-params">method</span>, <span class="hljs-params">targetClass</span>)</span>;<br><br>    <span class="hljs-comment">// First try is the method in the target class.</span><br>    TransactionAttribute txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">specificMethod</span>)</span>;<br>    <span class="hljs-keyword">if</span> (txAttr != null) &#123;<br>      return txAttr;<br>    &#125;<br><br>    <span class="hljs-comment">// Second try is the transaction attribute on the target class.</span><br>    txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">specificMethod</span>.<span class="hljs-params">getDeclaringClass</span>()</span>);<br>    <span class="hljs-keyword">if</span> (txAttr != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>is<span class="hljs-constructor">UserLevelMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>      return txAttr;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (specificMethod != <span class="hljs-keyword">method</span>) &#123;<br>      <span class="hljs-comment">// Fallback is to look at the original method.</span><br>      txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>)</span>;<br>      <span class="hljs-keyword">if</span> (txAttr != null) &#123;<br>        return txAttr;<br>      &#125;<br>      <span class="hljs-comment">// Last fallback is the class of the original method.</span><br>      txAttr = find<span class="hljs-constructor">TransactionAttribute(<span class="hljs-params">method</span>.<span class="hljs-params">getDeclaringClass</span>()</span>);<br>      <span class="hljs-keyword">if</span> (txAttr != null<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>is<span class="hljs-constructor">UserLevelMethod(<span class="hljs-params">method</span>)</span>) &#123;<br>        return txAttr;<br>      &#125;<br>    &#125;<br>    return null;<br>  &#125;<br></code></pre></td></tr></table></figure><p>也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是public，而是private、default或protected的话，spring则不会提供事务功能。</p><h3 id="2-方法用final修饰，不会生效-2"><a href="#2-方法用final修饰，不会生效-2" class="headerlink" title="2.方法用final修饰，不会生效"></a>2.方法用final修饰，不会生效</h3><p>有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span></span>&#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法被定义成了final的，这样会导致<a href="https://so.csdn.net/so/search?q=%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88&spm=1001.2101.3001.7020">事务失效</a>。</p><p>为什么？</p><p>如果你看过<a href="https://so.csdn.net/so/search?q=spring%E4%BA%8B%E5%8A%A1&spm=1001.2101.3001.7020">spring事务</a>的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。<strong>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法</strong>，而添加事务功能。</p><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p><h3 id="3-同一个类中的方法直接内部调用，会导致事务失效-2"><a href="#3-同一个类中的方法直接内部调用，会导致事务失效-2" class="headerlink" title="3.同一个类中的方法直接内部调用，会导致事务失效"></a>3.同一个类中的方法直接内部调用，会导致事务失效</h3><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">UserMapper</span> userMapper;<br><br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        userMapper.<span class="hljs-title function_">insertUser</span>(userModel);<br>        <span class="hljs-title function_">updateStatus</span>(userModel);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">updateStatus</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>        <span class="hljs-title function_">doSameThing</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。<a href="https://blog.csdn.net/yyoc97/article/details/81911744">根本原因</a> <a href="https://blog.csdn.net/mccand1234/article/details/124578233">根本原因2</a></p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><p>那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？</p><h4 id="3-1-新加一个Service方法-2"><a href="#3-1-新加一个Service方法-2" class="headerlink" title="3.1 新加一个Service方法"></a>3.1 新加一个Service方法</h4><p>这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br>   <span class="hljs-keyword">@Autowired</span><br>   prvate ServiceB serviceB;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         serviceB<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br> &#125;<br><br> <span class="hljs-keyword">@Servcie</span><br> public class ServiceB &#123;<br><br>    <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>    public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br><br> &#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-在该Service类中注入自己-2"><a href="#3-2-在该Service类中注入自己-2" class="headerlink" title="3.2 在该Service类中注入自己"></a>3.2 在该Service类中注入自己</h4><p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br>   <span class="hljs-keyword">@Autowired</span><br>   prvate ServiceA serviceA;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         serviceA<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br><br>   <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>   public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p><p>答案：不会。</p><p>其实spring ioc内部的<a href="https://blog.csdn.net/mccand1234/article/details/116403266">三级缓存</a>保证了它，不会出现循环依赖问题。</p><h4 id="3-3-通过AopContent类-2"><a href="#3-3-通过AopContent类-2" class="headerlink" title="3.3 通过AopContent类"></a>3.3 通过AopContent类</h4><p>在该Service类中使用AopContext.currentProxy()获取代理对象</p><p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Servcie</span><br>public class ServiceA &#123;<br><br>   public void <span class="hljs-built_in">save</span>(User user) &#123;<br>         <span class="hljs-built_in">queryData1</span>();<br>         <span class="hljs-built_in">queryData2</span>();<br>         ((ServiceA)AopContext<span class="hljs-selector-class">.currentProxy</span>())<span class="hljs-selector-class">.doSave</span>(user);<br>   &#125;<br><br>   <span class="hljs-keyword">@Transactional</span>(rollbackFor=Exception.class)<br>   public void doSave(User user) &#123;<br>       <span class="hljs-built_in">addData1</span>();<br>       <span class="hljs-built_in">updateData2</span>();<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="4-类本身-未被spring管理-2"><a href="#4-类本身-未被spring管理-2" class="headerlink" title="4.(类本身) 未被spring管理"></a>4.(类本身) 未被spring管理</h3><p>在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。</p><p>通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。当然创建bean实例的方法还有很多，不一一说了。有兴趣的小伙伴可以参考这篇文章：@Autowired的这些骚操作，你都知道吗？</p><p>如下所示, 开发了一个Service类，但忘了加@Service注解，比如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">UserModel userModel</span>) &#123;<br>         <span class="hljs-title function_">saveData</span>(userModel);<br>         <span class="hljs-title function_">updateData</span>(userModel);<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子，我们可以看到UserService类没有加@Service注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。</p><h3 id="5-多线程调用-2"><a href="#5-多线程调用-2" class="headerlink" title="5.多线程调用"></a>5.多线程调用</h3><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        userMapper.insertUser(userModel);<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            roleService.doOtherThing();<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">doOtherThing</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart">private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;<span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">Object</span>, <span class="hljs-built_in">Object</span>&gt;&gt; resources =<br><br>  <span class="hljs-keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="hljs-string">&quot;Transactional resources&quot;</span>);<br><br></code></pre></td></tr></table></figure><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h3 id="6-存储引擎-表不支持事务-2"><a href="#6-存储引擎-表不支持事务-2" class="headerlink" title="6.(存储引擎)表不支持事务"></a>6.(存储引擎)表不支持事务</h3><p>周所周知，在mysql5之前，默认的数据库引擎是myisam。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>有些老项目中，可能还在用它。</p><p>在创建表的时候，只需要把ENGINE参数设置成MyISAM即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `category` (<br>  `id` <span class="hljs-type">bigint</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `one_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `two_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `three_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `four_category` <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">COLLATE</span> utf8mb4_bin <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`id`)<br>) ENGINE<span class="hljs-operator">=</span>MyISAM AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 <span class="hljs-keyword">COLLATE</span><span class="hljs-operator">=</span>utf8mb4_bin<br></code></pre></td></tr></table></figure><p>myisam好用，但有个很致命的问题是：<strong>不支持事务</strong>。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。</p><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p><h3 id="7-未开启事务-2"><a href="#7-未开启事务-2" class="headerlink" title="7.未开启事务"></a>7.未开启事务</h3><p>有时候，事务没有生效的根本原因是没有开启事务。</p><p>你看到这句话可能会觉得好笑。</p><p>开启事务不是一个项目中，最最最基本的功能吗？</p><p>为什么还会没有开启事务？</p><p>没错，如果项目已经搭建好了，事务功能肯定是有的。</p><p>但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？</p><p>当然原因有很多，但没有开启事务，这个原因极其容易被忽略。</p><p>如果你使用的是springboot项目，那么你很幸运。因为springboot通过DataSourceTransactionManagerAutoConfiguration类，已经默默的帮你开启了事务。</p><p>你所要做的事情很简单，只需要配置spring.datasource相关参数即可。</p><p>但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。</p><p>具体配置如下信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置事务管理器 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span> <br><span class="hljs-comment">&lt;!-- 用切点把事务切进去 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.susan.*.*(..))&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;pointcut&quot;</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span> <br><br></code></pre></td></tr></table></figure><p>默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。</p><h2 id="二、事务不回滚【五种】-2"><a href="#二、事务不回滚【五种】-2" class="headerlink" title="二、事务不回滚【五种】"></a>二、事务不回滚【五种】</h2><h3 id="1-错误的传播特性-2"><a href="#1-错误的传播特性-2" class="headerlink" title="1.错误的传播特性"></a>1.错误的传播特性</h3><p>其实，我们在使用@Transactional注解时，是可以指定propagation参数的。</p><p>该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：</p><p>REQUIRED 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。<br>SUPPORTS 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。<br>MANDATORY 如果当前上下文中存在事务，否则抛出异常。<br>REQUIRES_NEW 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。<br>NOT_SUPPORTED 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。<br>NEVER 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。<br>NESTED 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。<br>如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.NEVER)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UserModel userModel)</span> &#123;<br>        saveData(userModel);<br>        updateData(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。</p><p>目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。</p><h3 id="2-自己吞了异常-2"><a href="#2-自己吞了异常-2" class="headerlink" title="2.自己吞了异常"></a>2.自己吞了异常</h3><p>事务不会回滚，最常见的问题是：开发者在代码中手动try…catch了异常。比如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) &#123;<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">saveData</span>(userModel);<br>            <span class="hljs-selector-tag">updateData</span>(userModel);<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.error</span>(e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况下spring事务当然不会回滚，因为开发者<strong>自己捕获了异常</strong>，又没有手动抛出，换句话说就是把异常吞掉了。</p><p>如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。</p><h3 id="3-手动抛了别的异常-2"><a href="#3-手动抛了别的异常-2" class="headerlink" title="3.手动抛了别的异常"></a>3.手动抛了别的异常</h3><p>即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>             saveData(userModel);<br>             updateData(userModel);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.<span class="hljs-keyword">error</span>(e.getMessage(), e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。  </p><p>因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），对于普通的Exception（<a href="https://blog.csdn.net/mccand1234/article/details/51579425?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165164871416780357228953%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=165164871416780357228953&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-51579425.nonecase&utm_term=error&spm=1018.2226.3001.4450">非运行时异常</a>），它不会回滚。比如常见的IOExeption和SQLException</p><h3 id="4-自定义了回滚异常-2"><a href="#4-自定义了回滚异常-2" class="headerlink" title="4.自定义了回滚异常"></a>4.自定义了回滚异常</h3><p>在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置rollbackFor参数，来完成这个功能。</p><p>但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-variable">@Transactional</span>(rollbackFor = BusinessException.class)<br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-selector-tag">saveData</span>(userModel);<br>       <span class="hljs-selector-tag">updateData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。</p><p>即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。</p><p>这是为什么呢？</p><p>因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。</p><h3 id="5-嵌套事务回滚多了-2"><a href="#5-嵌套事务回滚多了-2" class="headerlink" title="5.嵌套事务回滚多了"></a>5.嵌套事务回滚多了</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RoleService roleService;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(UserModel userModel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        userMapper.insertUser(userModel);<br>        roleService.doOtherThing();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RoleService</span> &#123;<br><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.NESTED)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOtherThing</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;保存role表数据&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。但事实是，insertUser也回滚了。</p><p>why?</p><p>因为doOtherThing方法出现了异常，<strong>没有手动捕获</strong>，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。</p><p>怎么样才能只回滚保存点呢？</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Slf4j</span><br><span class="hljs-variable">@Service</span><br>public class UserService &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private UserMapper userMapper;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private RoleService roleService;<br><br>    <span class="hljs-variable">@Transactional</span><br>    public void <span class="hljs-built_in">add</span>(UserModel userModel) throws Exception &#123;<br><br>        <span class="hljs-selector-tag">userMapper</span><span class="hljs-selector-class">.insertUser</span>(userModel);<br>        <span class="hljs-selector-tag">try</span> &#123;<br>            <span class="hljs-selector-tag">roleService</span><span class="hljs-selector-class">.doOtherThing</span>();<br>        &#125; <span class="hljs-selector-tag">catch</span> (Exception e) &#123;<br>            <span class="hljs-selector-tag">log</span><span class="hljs-selector-class">.error</span>(e.<span class="hljs-built_in">getMessage</span>(), e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以将内部嵌套事务放在try&#x2F;catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。</p><h2 id="三、大事务与编程式事务-2"><a href="#三、大事务与编程式事务-2" class="headerlink" title="三、大事务与编程式事务"></a>三、大事务与编程式事务</h2><h3 id="1-大事务问题-2"><a href="#1-大事务问题-2" class="headerlink" title="1. 大事务问题"></a>1. 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。<br>关于大事务可参考：<a href="https://blog.csdn.net/mccand1234/article/details/124560532">大事务问题</a></p><p>通常情况下，我们会在方法上@Transactional注解，填加事务功能，比如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Service</span><br>public class UserService &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span> <br>    private RoleService roleService;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    public void add(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-built_in">query1</span>();<br>       <span class="hljs-built_in">query2</span>();<br>       <span class="hljs-built_in">query3</span>();<br>       roleService<span class="hljs-selector-class">.save</span>(userModel);<br>       <span class="hljs-built_in">update</span>(userModel);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">@Service</span><br>public class RoleService &#123;<br>    <br>    <span class="hljs-keyword">@Autowired</span> <br>    private RoleService roleService;<br>    <br>    <span class="hljs-keyword">@Transactional</span><br>    public void save(UserModel userModel) throws Exception &#123;<br>       <span class="hljs-built_in">query4</span>();<br>       <span class="hljs-built_in">query5</span>();<br>       <span class="hljs-built_in">query6</span>();<br>       <span class="hljs-built_in">saveData</span>(userModel);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但@Transactional注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。</p><p>上面的这个例子中，在UserService类中，其实只有这两行才需要事务：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">roleService<span class="hljs-selector-class">.save</span>(userModel);<br><span class="hljs-built_in">update</span>(userModel);<br></code></pre></td></tr></table></figure><p>在RoleService类中，只有这一行需要事务：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">save<span class="hljs-constructor">Data(<span class="hljs-params">userModel</span>)</span>;<br></code></pre></td></tr></table></figure><p>现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。</p><p>如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><h3 id="2-编程式事务-2"><a href="#2-编程式事务-2" class="headerlink" title="2. 编程式事务"></a>2. 编程式事务</h3><p>上面的这些内容都是基于@Transactional注解的，主要讲的是它的事务问题，我们把这种事务叫做：声明式事务。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：编程式事务。例如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Autowired</span><br>private TransactionTemplate transactionTemplate;<br><br>public void <span class="hljs-built_in">save</span>(final User user) &#123;<br>      <span class="hljs-built_in">queryData1</span>();<br>      <span class="hljs-built_in">queryData2</span>();<br>      transactionTemplate<span class="hljs-selector-class">.execute</span>(transactionStatus -&gt; &#123;<br>         addData1();<br>         <span class="hljs-built_in">updateData2</span>();<br>         return Boolean<span class="hljs-selector-class">.TRUE</span>;<br>     &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于@Transactional注解声明式事务，更建议大家使用，基于TransactionTemplate的编程式事务。主要原因如下：</p><p>避免由于spring aop问题，导致事务失效的问题。<br>能够更小粒度的控制事务的范围，更直观。<br>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引失效场景</title>
    <link href="/article/77f73530.html"/>
    <url>/article/77f73530.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p>explain 使用如下，只需要在查询的 SQL 前面添加上 explain 关键字即可，如下图所示：</p><p><img src="https://s2.51cto.com/oss/202401/05/c98243459b3d07235b86190a0b1484c26eeca4.png" alt="图片" title="图片">图片</p><p>而以上查询结果的列中，我们最主要观察 key 这一列，key 这一列表示实际使用的索引，如果为 NULL 则表示未使用索引，反之则使用了索引。</p><p>以上所有结果列说明如下：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行；</li><li>select_type — 表示查询的类型；</li><li>table — 输出结果集的表；</li><li>partitions — 匹配的分区；</li><li>type — 表示表的连接类型；</li><li>possible_keys — 表示查询时，可能使用的索引；</li><li>key — 表示实际使用的索引；</li><li>key_len — 索引字段的长度；</li><li>ref—  列与索引的比较；</li><li>rows — 大概估算的行数；</li><li>filtered — 按表条件过滤的行百分比；</li><li>Extra — 执行情况的描述和说明。</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据；</li><li>index — 遍历索引；</li><li>range — 索引范围查找；</li><li>index_subquery — 在子查询中使用 ref；</li><li>unique_subquery — 在子查询中使用 eq_ref；</li><li>ref_or_null — 对 null 进行索引的优化的 ref；</li><li>fulltext — 使用全文索引；</li><li>ref — 使用非唯一索引查找数据；</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联；</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点。</li></ul><h2 id="创建测试表和数据"><a href="#创建测试表和数据" class="headerlink" title="创建测试表和数据"></a>创建测试表和数据</h2><p>为了演示和测试那种情况下会导致索引失效，我们先创建一个测试表和相应的数据：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> auto_increment <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;主键&#x27;</span>,<br>  sn <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;学号&#x27;</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  age <span class="hljs-type">int</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  sex <span class="hljs-type">bit</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;性别&#x27;</span>,<br>  address <span class="hljs-type">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;家庭地址&#x27;</span>,<br>  key idx_address (address),<br>  key idx_sn_name_age (sn,<span class="hljs-type">name</span>,age)<br>)ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br><span class="hljs-comment">-- 添加测试数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,sn,<span class="hljs-type">name</span>,age,sex,address) <br>  <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;cn001&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;高老庄&#x27;</span>),<br>  (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cn002&#x27;</span>,<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;花果山&#x27;</span>),<br>  (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;cn003&#x27;</span>,<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;水帘洞&#x27;</span>);<br></code></pre></td></tr></table></figure><p>当前表中总共有 3 个索引，如下图所示：</p><p><img src="https://s9.51cto.com/oss/202401/05/3806d4a9089f58dbd3b641618e1def4c648fbc.png" alt="图片" title="图片">图片</p><blockquote><p>PS：本文以下内容基于 MySQL 5.7 InnoDB 数据引擎下。</p></blockquote><h2 id="索引失效情况1：非最左匹配"><a href="#索引失效情况1：非最左匹配" class="headerlink" title="索引失效情况1：非最左匹配"></a>索引失效情况1：非最左匹配</h2><p>最左匹配原则指的是，以最左边的为起点字段查询可以使用联合索引，否则将不能使用联合索引。我们本文的联合索引的字段顺序是 sn + name + age，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下：</p><p><img src="https://s2.51cto.com/oss/202401/05/529c1db624f52d1e7d597156acc2ba4edc02d9.png" alt="图片" title="图片">图片</p><p>从上述结果可以看出，如果是以最左边开始匹配的字段都可以使用上联合索引，比如：</p><ul><li>A+B+C</li><li>A+B</li><li>A+C</li></ul><p>其中：A 等于字段 sn，B 等于字段 name，C 等于字段 age。</p><p>而 B+C 却不能使用到联合索引，这就是最左匹配原则。</p><h2 id="索引失效情况2：错误模糊查询"><a href="#索引失效情况2：错误模糊查询" class="headerlink" title="索引失效情况2：错误模糊查询"></a>索引失效情况2：错误模糊查询</h2><p>模糊查询 like 的常见用法有 3 种：</p><ol><li>模糊匹配后面任意字符：like ‘张%’</li><li>模糊匹配前面任意字符：like ‘%张’</li><li>模糊匹配前后任意字符：like ‘%张%’</li></ol><p>而这 3 种模糊查询中只有第 1 种查询方式可以使用到索引，具体执行结果如下：</p><p><img src="https://s4.51cto.com/oss/202401/05/a4710fc55f261bb9c7b906d333145243664f8b.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况3：列运算"><a href="#索引失效情况3：列运算" class="headerlink" title="索引失效情况3：列运算"></a>索引失效情况3：列运算</h2><p>如果索引列使用了运算，那么索引也会失效，如下图所示：</p><p><img src="https://s9.51cto.com/oss/202401/05/a963cdb838e68bcc651773b024f8993f2b76af.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况4：使用函数"><a href="#索引失效情况4：使用函数" class="headerlink" title="索引失效情况4：使用函数"></a>索引失效情况4：使用函数</h2><p>查询列如果使用任意 MySQL 提供的函数就会导致索引失效，比如以下列使用了 ifnull 函数之后的执行计划如下：</p><p><img src="https://s6.51cto.com/oss/202401/05/e8d7d8421b0f5b5efa083794173cadc3eda521.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况5：类型转换"><a href="#索引失效情况5：类型转换" class="headerlink" title="索引失效情况5：类型转换"></a>索引失效情况5：类型转换</h2><p>如果索引列存在类型转换，那么也不会走索引，比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示：</p><p><img src="https://s4.51cto.com/oss/202401/05/51d31085298744d53a2404a4a67ca315ccc92c.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况6：使用-is-not-null"><a href="#索引失效情况6：使用-is-not-null" class="headerlink" title="索引失效情况6：使用 is not null"></a>索引失效情况6：使用 is not null</h2><p>当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示：</p><p><img src="https://s3.51cto.com/oss/202401/05/181383c59fd058393171363a28a3a6f5fba130.png" alt="图片" title="图片">图片</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>导致 MySQL 索引失效的常见场景有以下 6 种：</p><ol><li>联合索引不满足最左匹配原则。</li><li>模糊查询最前面的为不确定匹配字符。</li><li>索引列参与了运算。</li><li>索引列使用了函数。</li><li>索引列存在类型转换。</li><li>索引列使用 is not null 查询。为了验证 MySQL 中哪些情况下会导致索引失效，我们可以借助 explain 执行计划来分析索引失效的具体场景。</li></ol><p>explain 使用如下，只需要在查询的 SQL 前面添加上 explain 关键字即可，如下图所示：</p><p><img src="https://s2.51cto.com/oss/202401/05/c98243459b3d07235b86190a0b1484c26eeca4.png" alt="图片" title="图片">图片</p><p>而以上查询结果的列中，我们最主要观察 key 这一列，key 这一列表示实际使用的索引，如果为 NULL 则表示未使用索引，反之则使用了索引。</p><p>以上所有结果列说明如下：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行；</li><li>select_type — 表示查询的类型；</li><li>table — 输出结果集的表；</li><li>partitions — 匹配的分区；</li><li>type — 表示表的连接类型；</li><li>possible_keys — 表示查询时，可能使用的索引；</li><li>key — 表示实际使用的索引；</li><li>key_len — 索引字段的长度；</li><li>ref—  列与索引的比较；</li><li>rows — 大概估算的行数；</li><li>filtered — 按表条件过滤的行百分比；</li><li>Extra — 执行情况的描述和说明。</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据；</li><li>index — 遍历索引；</li><li>range — 索引范围查找；</li><li>index_subquery — 在子查询中使用 ref；</li><li>unique_subquery — 在子查询中使用 eq_ref；</li><li>ref_or_null — 对 null 进行索引的优化的 ref；</li><li>fulltext — 使用全文索引；</li><li>ref — 使用非唯一索引查找数据；</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联；</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点。</li></ul><h2 id="创建测试表和数据-1"><a href="#创建测试表和数据-1" class="headerlink" title="创建测试表和数据"></a>创建测试表和数据</h2><p>为了演示和测试那种情况下会导致索引失效，我们先创建一个测试表和相应的数据：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 创建表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span> student;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> student(<br>  id <span class="hljs-type">int</span> <span class="hljs-keyword">primary key</span> auto_increment <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;主键&#x27;</span>,<br>  sn <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;学号&#x27;</span>,<br>  <span class="hljs-type">name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>  age <span class="hljs-type">int</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>  sex <span class="hljs-type">bit</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;性别&#x27;</span>,<br>  address <span class="hljs-type">varchar</span>(<span class="hljs-number">250</span>) <span class="hljs-keyword">comment</span> <span class="hljs-string">&#x27;家庭地址&#x27;</span>,<br>  key idx_address (address),<br>  key idx_sn_name_age (sn,<span class="hljs-type">name</span>,age)<br>)ENGINE=InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br><span class="hljs-comment">-- 添加测试数据</span><br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> student(id,sn,<span class="hljs-type">name</span>,age,sex,address) <br>  <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;cn001&#x27;</span>,<span class="hljs-string">&#x27;张三&#x27;</span>,<span class="hljs-number">18</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;高老庄&#x27;</span>),<br>  (<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;cn002&#x27;</span>,<span class="hljs-string">&#x27;李四&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;花果山&#x27;</span>),<br>  (<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;cn003&#x27;</span>,<span class="hljs-string">&#x27;王五&#x27;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;水帘洞&#x27;</span>);<br></code></pre></td></tr></table></figure><p>当前表中总共有 3 个索引，如下图所示：</p><p><img src="https://s9.51cto.com/oss/202401/05/3806d4a9089f58dbd3b641618e1def4c648fbc.png" alt="图片" title="图片">图片</p><blockquote><p>PS：本文以下内容基于 MySQL 5.7 InnoDB 数据引擎下。</p></blockquote><h2 id="索引失效情况1：非最左匹配-1"><a href="#索引失效情况1：非最左匹配-1" class="headerlink" title="索引失效情况1：非最左匹配"></a>索引失效情况1：非最左匹配</h2><p>最左匹配原则指的是，以最左边的为起点字段查询可以使用联合索引，否则将不能使用联合索引。我们本文的联合索引的字段顺序是 sn + name + age，我们假设它们的顺序是 A + B + C，以下联合索引的使用情况如下：</p><p><img src="https://s2.51cto.com/oss/202401/05/529c1db624f52d1e7d597156acc2ba4edc02d9.png" alt="图片" title="图片">图片</p><p>从上述结果可以看出，如果是以最左边开始匹配的字段都可以使用上联合索引，比如：</p><ul><li>A+B+C</li><li>A+B</li><li>A+C</li></ul><p>其中：A 等于字段 sn，B 等于字段 name，C 等于字段 age。</p><p>而 B+C 却不能使用到联合索引，这就是最左匹配原则。</p><h2 id="索引失效情况2：错误模糊查询-1"><a href="#索引失效情况2：错误模糊查询-1" class="headerlink" title="索引失效情况2：错误模糊查询"></a>索引失效情况2：错误模糊查询</h2><p>模糊查询 like 的常见用法有 3 种：</p><ol><li>模糊匹配后面任意字符：like ‘张%’</li><li>模糊匹配前面任意字符：like ‘%张’</li><li>模糊匹配前后任意字符：like ‘%张%’</li></ol><p>而这 3 种模糊查询中只有第 1 种查询方式可以使用到索引，具体执行结果如下：</p><p><img src="https://s4.51cto.com/oss/202401/05/a4710fc55f261bb9c7b906d333145243664f8b.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况3：列运算-1"><a href="#索引失效情况3：列运算-1" class="headerlink" title="索引失效情况3：列运算"></a>索引失效情况3：列运算</h2><p>如果索引列使用了运算，那么索引也会失效，如下图所示：</p><p><img src="https://s9.51cto.com/oss/202401/05/a963cdb838e68bcc651773b024f8993f2b76af.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况4：使用函数-1"><a href="#索引失效情况4：使用函数-1" class="headerlink" title="索引失效情况4：使用函数"></a>索引失效情况4：使用函数</h2><p>查询列如果使用任意 MySQL 提供的函数就会导致索引失效，比如以下列使用了 ifnull 函数之后的执行计划如下：</p><p><img src="https://s6.51cto.com/oss/202401/05/e8d7d8421b0f5b5efa083794173cadc3eda521.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况5：类型转换-1"><a href="#索引失效情况5：类型转换-1" class="headerlink" title="索引失效情况5：类型转换"></a>索引失效情况5：类型转换</h2><p>如果索引列存在类型转换，那么也不会走索引，比如 address 为字符串类型，而查询的时候设置了 int 类型的值就会导致索引失效，如下图所示：</p><p><img src="https://s4.51cto.com/oss/202401/05/51d31085298744d53a2404a4a67ca315ccc92c.png" alt="图片" title="图片">图片</p><h2 id="索引失效情况6：使用-is-not-null-1"><a href="#索引失效情况6：使用-is-not-null-1" class="headerlink" title="索引失效情况6：使用 is not null"></a>索引失效情况6：使用 is not null</h2><p>当在查询中使用了 is not null 也会导致索引失效，而 is null 则会正常触发索引的，如下图所示：</p><p><img src="https://s3.51cto.com/oss/202401/05/181383c59fd058393171363a28a3a6f5fba130.png" alt="图片" title="图片">图片</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>导致 MySQL 索引失效的常见场景有以下 6 种：</p><ol><li>联合索引不满足最左匹配原则。</li><li>模糊查询最前面的为不确定匹配字符。</li><li>索引列参与了运算。</li><li>索引列使用了函数。</li><li>索引列存在类型转换。</li><li>索引列使用 is not null 查询。</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis集群维护</title>
    <link href="/article/7ea8260e.html"/>
    <url>/article/7ea8260e.html</url>
    
    <content type="html"><![CDATA[<p><strong>目录</strong></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t0">前言</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t1">1、 –cluster create  创建集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t2">2、–cluster check  检查集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t3">3、–cluster info 查看集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t4">4、–cluster fix  修复集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t5">5、–cluster rehard 迁移槽位</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t6">6、 –cluster rebalance 平衡集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t7">7、 –cluster  add-node    集群扩容</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t8">8、–cluster del-node      集群缩容</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t9">9、 –cluster call  在集群中执行命令</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t10">10、–cluster set-timeout     整个集群的cluster-node-timeout时间</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t11">11、–cluster import          导入数据至集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t12">12、–cluster backup         备份集群rdb文件</a></p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>redis-trib.rb</code>是官方提供的Redis Cluster的管理工具，它提供了集群创建、检查、修复、均衡等命令行工具。Redis Cluster 在5.0之后取消了ruby脚本的支持，而是直接集合到redis-cli里，避免了再安装ruby的相关环境。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@localhost bin]# ./redis-cli --cluster helpCluster Manager Commands:  create         host1:port1 ... hostN:portN                 --cluster-replicas <span class="hljs-symbol">&lt;arg&gt;</span>  check          hos<span class="hljs-variable">t:port</span>                 --cluster-<span class="hljs-built_in">search</span>-multiple-owners  info           hos<span class="hljs-variable">t:port</span>  <span class="hljs-keyword">fix</span>            hos<span class="hljs-variable">t:port</span>                 --cluster-<span class="hljs-built_in">search</span>-multiple-owners                 --cluster-<span class="hljs-keyword">fix</span>-with-unreachable-masters  reshard        hos<span class="hljs-variable">t:port</span>                 --cluster-from <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-<span class="hljs-keyword">to</span> <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-slots <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-yes                 --cluster-timeout <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-pipeline <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-replace  rebalance      hos<span class="hljs-variable">t:port</span>                 --cluster-weight &lt;node1=w1...nodeN=<span class="hljs-keyword">wN</span>&gt;                 --cluster-use-<span class="hljs-built_in">empty</span>-masters                 --cluster-timeout <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-simulate                 --cluster-pipeline <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-threshold <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-replace  <span class="hljs-built_in">add</span>-node       new_hos<span class="hljs-variable">t:new_port</span> existing_hos<span class="hljs-variable">t:existing_port</span>                 --cluster-slave                 --cluster-master-id <span class="hljs-symbol">&lt;arg&gt;</span>  del-node       hos<span class="hljs-variable">t:port</span> node_id  <span class="hljs-keyword">call</span>           hos<span class="hljs-variable">t:port</span> <span class="hljs-keyword">command</span> arg arg .. arg                 --cluster-<span class="hljs-keyword">only</span>-masters                 --cluster-<span class="hljs-keyword">only</span>-replicas  <span class="hljs-keyword">set</span>-timeout    hos<span class="hljs-variable">t:port</span> milliseconds  import         hos<span class="hljs-variable">t:port</span>                 --cluster-from <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-user <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-pass <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-askpass                 --cluster-<span class="hljs-keyword">copy</span>                 --cluster-replace  backup         hos<span class="hljs-variable">t:port</span> backup_directory  <span class="hljs-keyword">help</span>            For check, <span class="hljs-keyword">fix</span>, reshard, del-node, <span class="hljs-keyword">set</span>-timeout you can specify the host <span class="hljs-built_in">and</span> port of any working node in the cluster. Cluster Manager Options:  --cluster-yes  Automatic yes <span class="hljs-keyword">to</span> cluster commands prompts <br></code></pre></td></tr></table></figure><p>下面我们来详细的说下各命令的用法和作用：</p><h2 id="1、-–cluster-create-创建集群"><a href="#1、-–cluster-create-创建集群" class="headerlink" title="1、 –cluster create  创建集群"></a><strong>1、 –cluster create</strong>  创建<strong>集群</strong></h2><p>create         host1:port1 … hostN:portN<br>                 –cluster-replicas <arg></p><p>该命令用来创建集群，假设我现在想搭建三主三从的集群127.0.0.1:7001~7006</p><p>启动所有节点后，可通过如下命令进行搭建：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7001 127.0</span>.<span class="hljs-number">0.1:7002</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7003 127.0</span>.<span class="hljs-number">0.1:7004</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7005 127.0</span>.<span class="hljs-number">0.1:7006</span> --cluster-replicas <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>--cluster-replicas 1 :表示每个主节点需要1个从节点。这里随机分配主从关系，如果需要定制，则可以不加该参数，使用add-node来定制,查看第7节</p><h2 id="2、–cluster-check-检查集群"><a href="#2、–cluster-check-检查集群" class="headerlink" title="2、–cluster check  检查集群"></a><strong>2、–cluster check  检查集群</strong></h2><p>check          host:port<br>                 –cluster-search-multiple-owners #检查是否有槽同时被分配给了多个节点</p><p>该命令经常使用，需要拥有槽位的所有节点为启动状态，用于检查集群状态是否正常，只有当所有的槽位正常时，集群状态才OK</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1b7cd4b9fc1eb68c1e9383ac8005d40.png"></p><h2 id="3、–cluster-info-查看集群"><a href="#3、–cluster-info-查看集群" class="headerlink" title="3、–cluster info 查看集群"></a><strong>3、–cluster info 查看集群</strong></h2><p>用于查看集群的简易信息</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3968b7dce8b99f3fc589b2eba9104df.png"></p><h2 id="4、–cluster-fix-修复集群"><a href="#4、–cluster-fix-修复集群" class="headerlink" title="4、–cluster fix  修复集群"></a><strong>4、–cluster fix  修复集群</strong></h2><p>fix            host:port<br>                 –cluster-search-multiple-owners    <br>                 –cluster-fix-with-unreachable-masters  </p><p>该命令十分有用，说明如下：</p><p> –cluster-search-multiple-owners ： 是否修复多个拥有者的槽位。当集群中的槽位在迁移过程中，出现意外时，使用fix可使用该参数。fix功能，redis内部在槽位的某些异常情况下会交互式的询问操作者是否同意它的修复策略，一般情况下，默认即可。</p><p> –cluster-fix-with-unreachable-masters ： 是否修复不可达的主节点上的槽位。例如，集群中某个主节点就是坏掉了，也没有故障转移成功。此时如何恢复该主节点上的所有槽位呢，这时就可以使用该参数，会将处于该主节点上的所有槽位恢复到存活的主节点上（之前的数据会丢失，仅仅是恢复了槽位）。</p><h2 id="5、–cluster-rehard-迁移槽位"><a href="#5、–cluster-rehard-迁移槽位" class="headerlink" title="5、–cluster rehard 迁移槽位"></a><strong>5、–cluster rehard 迁移槽位</strong></h2><p>reshard        host:port<br>                 –cluster-from <arg>   #槽位来源的节点运行id，多个用,分割，all表示全部节点<br>                 –cluster-to <arg>       #目标节点的运行id，只允一个<br>                 –cluster-slots <arg>   #迁移的槽位数<br>                 –cluster-yes               #是否默认同意集群内部的迁移计划（默认同意就可以）<br>                 –cluster-timeout <arg>   #迁移命令（migrate）的超时时间<br>                 –cluster-pipeline <arg>  #迁移key时，一次取出 的key数量，默认10<br>                 –cluster-replace           #是否直接replace到目标节点</p><p>迁移一个或者多个（–cluster-from）节点上的–cluster-slots个槽位至一个目标节点（–cluster-to）上。</p><p> –cluster-from 的值不为all的情况下， –cluster-from不能包含–cluster-to</p><p>可以使用如下命令查看整个集群中的所有运行id</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@localhost bin]# ./redis-cli -h <span class="hljs-number">192.168.84.1</span> -p <span class="hljs-number">7001</span> cluster nodes8ae862c1815ff89e49d6c8801ea0cb074e82855c <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7006@17006</span> slave <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">0</span> <span class="hljs-number">1694427906290</span> <span class="hljs-number">3</span> connectedf6df82f6c67fbe83049d6f95a8473221afee2ee<span class="hljs-number">6 192.168.84</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004@17004</span> slave <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">0</span> <span class="hljs-number">1694427905000</span> <span class="hljs-number">1</span> connected222df2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003@17003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1694427904000</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923</span>-<span class="hljs-number">163834</span>cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7005@17005</span> slave <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">0</span> <span class="hljs-number">1694427905255</span> <span class="hljs-number">2</span> connected30c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001@17001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1694427902000</span> <span class="hljs-number">1</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">546010</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002@17002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1694427902000</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461-10922</span><br></code></pre></td></tr></table></figure><p>通过集群的配置文件查看也可以</p><h2 id="6、-–cluster-rebalance-平衡集群"><a href="#6、-–cluster-rebalance-平衡集群" class="headerlink" title="6、 –cluster rebalance 平衡集群"></a>6、 <strong>–cluster rebalance 平衡集群</strong></h2><p>rebalance      host:port<br>                 –cluster-weight &lt;node1&#x3D;w1…nodeN&#x3D;wN&gt;<br>                 –cluster-use-empty-masters<br>                 –cluster-timeout <arg>     #迁移命令（migrate）的超时时间<br>                 –cluster-simulate              # 模拟rebalance操作，不会真正执行迁移操作<br>                 –cluster-pipeline <arg>    #定义 getkeysinslot命令一次取出的key数量，默认值为10<br>                 –cluster-threshold <arg><br>                 –cluster-replace               #是否直接replace到目标节点</p><p>--cluster-weight： 槽位权重（浮点型）比值，例如（这里使用端口号代替运行id）： 7001&#x3D;1.0,7002&#x3D;1.0,7003&#x3D;2.0 则表示，总权重为4.0， 7001和7002将分配到 (16384&#x2F;4)*1  个槽位，7003则是(16384&#x2F;4)*2个槽位。</p><p> –cluster-threshold: 平衡触发的阈值条件，默认为2.00%。例如上一步，7001和7002应该有4096个槽位，如果7001的槽位数不够4096个，且超过 (4096*0.02 约等于)82个及以上；或者7001的槽位数比4096少于82个及以上，则会触发自平衡。</p><h2 id="7、-–cluster-add-node-集群扩容"><a href="#7、-–cluster-add-node-集群扩容" class="headerlink" title="7、 –cluster  add-node    集群扩容"></a><strong>7、 –cluster  add-node    集群扩容</strong></h2><p>add-node    new_host:new_port                  #新加入集群的ip和port</p><p>                existing_host:existing_port          #集群中任一节点的ip和port<br>                 –cluster-slave                             #新节点作为从节点，默认随机一个主节点<br>                 –cluster-master-id <arg>            #给新节点指定主节点,值为节点的运行id</p><p>可用于向集群中添加主、从节点(即扩容)</p><p>假设我现在集群中有7001 7002 7003三个主节点了，想为7001添加一个从节点127.0.0.1:7006，则可执行如下命令：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> add-node </span>127.0.0.1:7006 127.0.0.1:7001  --cluster-slave --cluster-master-id 30c69d9e408015082c1a2145875cd1ec0c7a41ea<br></code></pre></td></tr></table></figure><p> 不传入–cluster-slave –cluster-master-id 参数，表示添加一个主节点。</p><p>当添加的是一个主节点时，此时，该主节点没有任何槽位，可以使用rebalance或者reshard来迁移槽位给它。</p><h2 id="8、–cluster-del-node-集群缩容"><a href="#8、–cluster-del-node-集群缩容" class="headerlink" title="8、–cluster del-node      集群缩容"></a><strong>8、–cluster del-node      集群缩容</strong></h2><p>del-node    host:port node_id         #删除给定的一个节点，成功后关闭该节点服务</p><p>也就是缩容。</p><p>删除一个主节点要求先迁移走改主节点上的槽位（数据），这时就可以使用reshard命令了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[root@localhost bin]</span># ./redis-cli --cluster del-node <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span> <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe&gt;&gt;&gt; Removing node <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-keyword">from</span> cluster <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span>[ERR] Node <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty! Reshard data away <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure><h2 id="9、-–cluster-call-在集群中执行命令"><a href="#9、-–cluster-call-在集群中执行命令" class="headerlink" title="9、 –cluster call  在集群中执行命令"></a><strong>9、 –cluster call</strong>  在集群中执行命令</h2><p>call           host:port command arg arg .. arg               #在集群的所有节点执行相关命令<br>                 –cluster-only-masters                                #是否只在主节点上执行<br>                 –cluster-only-replicas                                #是否只在从节点上执行</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/59db12799c1a7acd9c6fc267ccf790fc.png"></p><h2 id="10、–cluster-set-timeout-整个集群的cluster-node-timeout时间"><a href="#10、–cluster-set-timeout-整个集群的cluster-node-timeout时间" class="headerlink" title="10、–cluster set-timeout     整个集群的cluster-node-timeout时间"></a><strong>10、–cluster set-timeout</strong>     整个集群的cluster-node-timeout时间</h2><p>        set-timeout    host:port milliseconds</p><p>设置整个集群的cluster-node-timeout时间</p><h2 id="11、–cluster-import-导入数据至集群"><a href="#11、–cluster-import-导入数据至集群" class="headerlink" title="11、–cluster import          导入数据至集群"></a><strong>11、–cluster import</strong>          导入数据至集群</h2><p>import         host:port<br>                 –cluster-from <arg><br>                 –cluster-from-user <arg><br>                 –cluster-from-pass <arg><br>                 –cluster-from-askpass<br>                 –cluster-copy               #migrate时指定类型为copy<br>                 –cluster-replace           #migrate时指定类型为replace</p><p>将外部redis的数据导入集群 </p><p>redis-cli –cluster import 127.0.01:6379 –cluster-from 127.0.0.2:6379 –cluster-replace –cluster-copy</p><p>说明：外部Redis实例（127.0.0.2:6379）导入到集群中的任意一节点，倒入之后，原来集群的key变为空，导入到新集群的key会自动分片到各个mater节点的slot</p><p>--cluster-replace 如果集群（127.0.01:6379）中存在外部redis实例（127.0.0.2:6379）的key，则会覆盖掉（10.35.2.68:6379）的value</p><p>--cluster-copy 默认情况下，import 命令在向集群导入数据的同时，还会删除单机服务器中源数据。如果用户想要保留单机服务器中的数据，那么可以在执行命令的同时给定 –cluster-copy 选项 </p><p>该命令将正在运行的实例的所有键（从源实例中删除键）移动到指定的预先存在的 Redis 集群。</p><p>实际项目上，数据导入应该用redis-shake工具的比较多。</p><h2 id="12、–cluster-backup-备份集群rdb文件"><a href="#12、–cluster-backup-备份集群rdb文件" class="headerlink" title="12、–cluster backup         备份集群rdb文件"></a>12、–cluster backup         备份集群<a href="https://so.csdn.net/so/search?q=rdb&spm=1001.2101.3001.7020">rdb</a>文件</h2><p>backup         host:port backup_directory    </p><p>备份主节点上的数据值RDB文件</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@localhost bin]# mkdir backup[root@localhost bin]# ./redis-cli --cluster backup <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>  ./backup&gt;&gt;&gt; Performing Cluster Check (using node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>)M: <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>   slots:[<span class="hljs-number">0</span>-<span class="hljs-number">5460</span>] (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">8</span>ae862c1815ff89e49d6c8801ea0cb074e82855c <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7006</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad292637873S: f6df82f6c67fbe83049d6f95a8473221afee2ee<span class="hljs-number">6 192.168.84</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41eaM: <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003</span>   slots:[<span class="hljs-number">10923-16383</span>] (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">4</span>cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7005</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43feM: <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002</span>   slots:[<span class="hljs-number">5461-10922</span>] (<span class="hljs-number">5462</span> slots) master   <span class="hljs-number">1</span> additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All <span class="hljs-number">16384</span> slots covered.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">232</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7001</span>-<span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea.rdb&#x27;Transfer finished with success.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">226</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7003</span>-<span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span>.rdb&#x27;Transfer finished with success.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">206</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7002</span>-<span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe.rdb&#x27;Transfer finished with success.Saving cluster configuration to: ./backup/nodes.json[OK] Backup created into: ./backup<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47dcb320ce3a8ca6ab958daf758a3194.png"></p><p>nodes.json保存的是集群结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">[root@localhost bin]# cat nodes.json [  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;30c69d9e408015082c1a2145875cd1ec0c7a41ea&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7001</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[0,5460]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5461</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">1</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;8ae862c1815ff89e49d6c8801ea0cb074e82855c&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7006</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;222df2165b7b9dba291cfa572d472ad292637873&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">3</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;f6df82f6c67fbe83049d6f95a8473221afee2ee6&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7004</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;30c69d9e408015082c1a2145875cd1ec0c7a41ea&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">1</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;222df2165b7b9dba291cfa572d472ad292637873&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7003</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[10923,16383]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5461</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">3</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;4cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7005</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;10a4381d9869e293cad95bf75482f506de9f43fe&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">2</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;10a4381d9869e293cad95bf75482f506de9f43fe&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7002</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[5461,10922]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5462</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">2</span>  &#125;]<br></code></pre></td></tr></table></figure><p>   </p><p>显示推荐内容# redis集群的维护（redis-cli –cluster 命令用法）</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/cj_eryue" title="cj_eryue">cj_eryue</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newUpTime2.png"> 已于 2024-06-11 10:54:16 修改</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png"> 阅读量7.1k <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png"> 收藏 19</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png"> 点赞数 6</p><p>分类专栏： <a href="https://blog.csdn.net/cj_eryue/category_7806826.html">redis</a> 文章标签： <a href="https://so.csdn.net/so/search/s.do?q=redis&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art">redis</a></p><p>于 2023-09-12 10:51:33 首次发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>本文链接：<a href="https://blog.csdn.net/cj_eryue/article/details/132811758">https://blog.csdn.net/cj_eryue&#x2F;article&#x2F;details&#x2F;132811758</a></p><p>版权</p><p> <a href="javascript:;" title="开放原子开发者工作坊"><img src="https://devpress.csdnimg.cn/79de2bf0b7994defa4242ef90d5513fa.jpg"> 开放原子开发者工作坊 文章已被社区收录</a></p><p>加入社区</p><p> <a href="https://blog.csdn.net/cj_eryue/category_7806826.html" title="redis"><img src="https://i-blog.csdnimg.cn/columns/default/20201014180756913.png?x-oss-process=image/resize,m_fixed,h_224,w_224"> redis 专栏收录该内容</a></p><p>12 篇文章 2 订阅</p><p>订阅专栏</p><p><strong>目录</strong></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t0">前言</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t1">1、 –cluster create  创建集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t2">2、–cluster check  检查集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t3">3、–cluster info 查看集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t4">4、–cluster fix  修复集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t5">5、–cluster rehard 迁移槽位</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t6">6、 –cluster rebalance 平衡集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t7">7、 –cluster  add-node    集群扩容</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t8">8、–cluster del-node      集群缩容</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t9">9、 –cluster call  在集群中执行命令</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t10">10、–cluster set-timeout     整个集群的cluster-node-timeout时间</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t11">11、–cluster import          导入数据至集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t12">12、–cluster backup         备份集群rdb文件</a></p><hr><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p><code>redis-trib.rb</code>是官方提供的Redis Cluster的管理工具，它提供了集群创建、检查、修复、均衡等命令行工具。Redis Cluster 在5.0之后取消了ruby脚本的支持，而是直接集合到redis-cli里，避免了再安装ruby的相关环境。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@localhost bin]# ./redis-cli --cluster helpCluster Manager Commands:  create         host1:port1 ... hostN:portN                 --cluster-replicas <span class="hljs-symbol">&lt;arg&gt;</span>  check          hos<span class="hljs-variable">t:port</span>                 --cluster-<span class="hljs-built_in">search</span>-multiple-owners  info           hos<span class="hljs-variable">t:port</span>  <span class="hljs-keyword">fix</span>            hos<span class="hljs-variable">t:port</span>                 --cluster-<span class="hljs-built_in">search</span>-multiple-owners                 --cluster-<span class="hljs-keyword">fix</span>-with-unreachable-masters  reshard        hos<span class="hljs-variable">t:port</span>                 --cluster-from <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-<span class="hljs-keyword">to</span> <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-slots <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-yes                 --cluster-timeout <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-pipeline <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-replace  rebalance      hos<span class="hljs-variable">t:port</span>                 --cluster-weight &lt;node1=w1...nodeN=<span class="hljs-keyword">wN</span>&gt;                 --cluster-use-<span class="hljs-built_in">empty</span>-masters                 --cluster-timeout <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-simulate                 --cluster-pipeline <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-threshold <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-replace  <span class="hljs-built_in">add</span>-node       new_hos<span class="hljs-variable">t:new_port</span> existing_hos<span class="hljs-variable">t:existing_port</span>                 --cluster-slave                 --cluster-master-id <span class="hljs-symbol">&lt;arg&gt;</span>  del-node       hos<span class="hljs-variable">t:port</span> node_id  <span class="hljs-keyword">call</span>           hos<span class="hljs-variable">t:port</span> <span class="hljs-keyword">command</span> arg arg .. arg                 --cluster-<span class="hljs-keyword">only</span>-masters                 --cluster-<span class="hljs-keyword">only</span>-replicas  <span class="hljs-keyword">set</span>-timeout    hos<span class="hljs-variable">t:port</span> milliseconds  import         hos<span class="hljs-variable">t:port</span>                 --cluster-from <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-user <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-pass <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-askpass                 --cluster-<span class="hljs-keyword">copy</span>                 --cluster-replace  backup         hos<span class="hljs-variable">t:port</span> backup_directory  <span class="hljs-keyword">help</span>            For check, <span class="hljs-keyword">fix</span>, reshard, del-node, <span class="hljs-keyword">set</span>-timeout you can specify the host <span class="hljs-built_in">and</span> port of any working node in the cluster. Cluster Manager Options:  --cluster-yes  Automatic yes <span class="hljs-keyword">to</span> cluster commands prompts <br></code></pre></td></tr></table></figure><p>下面我们来详细的说下各命令的用法和作用：</p><h2 id="1、-–cluster-create-创建集群-1"><a href="#1、-–cluster-create-创建集群-1" class="headerlink" title="1、 –cluster create  创建集群"></a><strong>1、 –cluster create</strong>  创建<strong>集群</strong></h2><p>create         host1:port1 … hostN:portN<br>                 –cluster-replicas <arg></p><p>该命令用来创建集群，假设我现在想搭建三主三从的集群127.0.0.1:7001~7006</p><p>启动所有节点后，可通过如下命令进行搭建：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7001 127.0</span>.<span class="hljs-number">0.1:7002</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7003 127.0</span>.<span class="hljs-number">0.1:7004</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7005 127.0</span>.<span class="hljs-number">0.1:7006</span> --cluster-replicas <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>--cluster-replicas 1 :表示每个主节点需要1个从节点。这里随机分配主从关系，如果需要定制，则可以不加该参数，使用add-node来定制,查看第7节</p><h2 id="2、–cluster-check-检查集群-1"><a href="#2、–cluster-check-检查集群-1" class="headerlink" title="2、–cluster check  检查集群"></a><strong>2、–cluster check  检查集群</strong></h2><p>check          host:port<br>                 –cluster-search-multiple-owners #检查是否有槽同时被分配给了多个节点</p><p>该命令经常使用，需要拥有槽位的所有节点为启动状态，用于检查集群状态是否正常，只有当所有的槽位正常时，集群状态才OK</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1b7cd4b9fc1eb68c1e9383ac8005d40.png"></p><h2 id="3、–cluster-info-查看集群-1"><a href="#3、–cluster-info-查看集群-1" class="headerlink" title="3、–cluster info 查看集群"></a><strong>3、–cluster info 查看集群</strong></h2><p>用于查看集群的简易信息</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3968b7dce8b99f3fc589b2eba9104df.png"></p><h2 id="4、–cluster-fix-修复集群-1"><a href="#4、–cluster-fix-修复集群-1" class="headerlink" title="4、–cluster fix  修复集群"></a><strong>4、–cluster fix  修复集群</strong></h2><p>fix            host:port<br>                 –cluster-search-multiple-owners    <br>                 –cluster-fix-with-unreachable-masters  </p><p>该命令十分有用，说明如下：</p><p> –cluster-search-multiple-owners ： 是否修复多个拥有者的槽位。当集群中的槽位在迁移过程中，出现意外时，使用fix可使用该参数。fix功能，redis内部在槽位的某些异常情况下会交互式的询问操作者是否同意它的修复策略，一般情况下，默认即可。</p><p> –cluster-fix-with-unreachable-masters ： 是否修复不可达的主节点上的槽位。例如，集群中某个主节点就是坏掉了，也没有故障转移成功。此时如何恢复该主节点上的所有槽位呢，这时就可以使用该参数，会将处于该主节点上的所有槽位恢复到存活的主节点上（之前的数据会丢失，仅仅是恢复了槽位）。</p><h2 id="5、–cluster-rehard-迁移槽位-1"><a href="#5、–cluster-rehard-迁移槽位-1" class="headerlink" title="5、–cluster rehard 迁移槽位"></a><strong>5、–cluster rehard 迁移槽位</strong></h2><p>reshard        host:port<br>                 –cluster-from <arg>   #槽位来源的节点运行id，多个用,分割，all表示全部节点<br>                 –cluster-to <arg>       #目标节点的运行id，只允一个<br>                 –cluster-slots <arg>   #迁移的槽位数<br>                 –cluster-yes               #是否默认同意集群内部的迁移计划（默认同意就可以）<br>                 –cluster-timeout <arg>   #迁移命令（migrate）的超时时间<br>                 –cluster-pipeline <arg>  #迁移key时，一次取出 的key数量，默认10<br>                 –cluster-replace           #是否直接replace到目标节点</p><p>迁移一个或者多个（–cluster-from）节点上的–cluster-slots个槽位至一个目标节点（–cluster-to）上。</p><p> –cluster-from 的值不为all的情况下， –cluster-from不能包含–cluster-to</p><p>可以使用如下命令查看整个集群中的所有运行id</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@localhost bin]# ./redis-cli -h <span class="hljs-number">192.168.84.1</span> -p <span class="hljs-number">7001</span> cluster nodes8ae862c1815ff89e49d6c8801ea0cb074e82855c <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7006@17006</span> slave <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">0</span> <span class="hljs-number">1694427906290</span> <span class="hljs-number">3</span> connectedf6df82f6c67fbe83049d6f95a8473221afee2ee<span class="hljs-number">6 192.168.84</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004@17004</span> slave <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">0</span> <span class="hljs-number">1694427905000</span> <span class="hljs-number">1</span> connected222df2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003@17003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1694427904000</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923</span>-<span class="hljs-number">163834</span>cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7005@17005</span> slave <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">0</span> <span class="hljs-number">1694427905255</span> <span class="hljs-number">2</span> connected30c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001@17001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1694427902000</span> <span class="hljs-number">1</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">546010</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002@17002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1694427902000</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461-10922</span><br></code></pre></td></tr></table></figure><p>通过集群的配置文件查看也可以</p><h2 id="6、-–cluster-rebalance-平衡集群-1"><a href="#6、-–cluster-rebalance-平衡集群-1" class="headerlink" title="6、 –cluster rebalance 平衡集群"></a>6、 <strong>–cluster rebalance 平衡集群</strong></h2><p>rebalance      host:port<br>                 –cluster-weight &lt;node1&#x3D;w1…nodeN&#x3D;wN&gt;<br>                 –cluster-use-empty-masters<br>                 –cluster-timeout <arg>     #迁移命令（migrate）的超时时间<br>                 –cluster-simulate              # 模拟rebalance操作，不会真正执行迁移操作<br>                 –cluster-pipeline <arg>    #定义 getkeysinslot命令一次取出的key数量，默认值为10<br>                 –cluster-threshold <arg><br>                 –cluster-replace               #是否直接replace到目标节点</p><p>--cluster-weight： 槽位权重（浮点型）比值，例如（这里使用端口号代替运行id）： 7001&#x3D;1.0,7002&#x3D;1.0,7003&#x3D;2.0 则表示，总权重为4.0， 7001和7002将分配到 (16384&#x2F;4)*1  个槽位，7003则是(16384&#x2F;4)*2个槽位。</p><p> –cluster-threshold: 平衡触发的阈值条件，默认为2.00%。例如上一步，7001和7002应该有4096个槽位，如果7001的槽位数不够4096个，且超过 (4096*0.02 约等于)82个及以上；或者7001的槽位数比4096少于82个及以上，则会触发自平衡。</p><h2 id="7、-–cluster-add-node-集群扩容-1"><a href="#7、-–cluster-add-node-集群扩容-1" class="headerlink" title="7、 –cluster  add-node    集群扩容"></a><strong>7、 –cluster  add-node    集群扩容</strong></h2><p>add-node    new_host:new_port                  #新加入集群的ip和port</p><p>                existing_host:existing_port          #集群中任一节点的ip和port<br>                 –cluster-slave                             #新节点作为从节点，默认随机一个主节点<br>                 –cluster-master-id <arg>            #给新节点指定主节点,值为节点的运行id</p><p>可用于向集群中添加主、从节点(即扩容)</p><p>假设我现在集群中有7001 7002 7003三个主节点了，想为7001添加一个从节点127.0.0.1:7006，则可执行如下命令：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> add-node </span>127.0.0.1:7006 127.0.0.1:7001  --cluster-slave --cluster-master-id 30c69d9e408015082c1a2145875cd1ec0c7a41ea<br></code></pre></td></tr></table></figure><p> 不传入–cluster-slave –cluster-master-id 参数，表示添加一个主节点。</p><p>当添加的是一个主节点时，此时，该主节点没有任何槽位，可以使用rebalance或者reshard来迁移槽位给它。</p><h2 id="8、–cluster-del-node-集群缩容-1"><a href="#8、–cluster-del-node-集群缩容-1" class="headerlink" title="8、–cluster del-node      集群缩容"></a><strong>8、–cluster del-node      集群缩容</strong></h2><p>del-node    host:port node_id         #删除给定的一个节点，成功后关闭该节点服务</p><p>也就是缩容。</p><p>删除一个主节点要求先迁移走改主节点上的槽位（数据），这时就可以使用reshard命令了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[root@localhost bin]</span># ./redis-cli --cluster del-node <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span> <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe&gt;&gt;&gt; Removing node <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-keyword">from</span> cluster <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span>[ERR] Node <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty! Reshard data away <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure><h2 id="9、-–cluster-call-在集群中执行命令-1"><a href="#9、-–cluster-call-在集群中执行命令-1" class="headerlink" title="9、 –cluster call  在集群中执行命令"></a><strong>9、 –cluster call</strong>  在集群中执行命令</h2><p>call           host:port command arg arg .. arg               #在集群的所有节点执行相关命令<br>                 –cluster-only-masters                                #是否只在主节点上执行<br>                 –cluster-only-replicas                                #是否只在从节点上执行</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/59db12799c1a7acd9c6fc267ccf790fc.png"></p><h2 id="10、–cluster-set-timeout-整个集群的cluster-node-timeout时间-1"><a href="#10、–cluster-set-timeout-整个集群的cluster-node-timeout时间-1" class="headerlink" title="10、–cluster set-timeout     整个集群的cluster-node-timeout时间"></a><strong>10、–cluster set-timeout</strong>     整个集群的cluster-node-timeout时间</h2><p>        set-timeout    host:port milliseconds</p><p>设置整个集群的cluster-node-timeout时间</p><h2 id="11、–cluster-import-导入数据至集群-1"><a href="#11、–cluster-import-导入数据至集群-1" class="headerlink" title="11、–cluster import          导入数据至集群"></a><strong>11、–cluster import</strong>          导入数据至集群</h2><p>import         host:port<br>                 –cluster-from <arg><br>                 –cluster-from-user <arg><br>                 –cluster-from-pass <arg><br>                 –cluster-from-askpass<br>                 –cluster-copy               #migrate时指定类型为copy<br>                 –cluster-replace           #migrate时指定类型为replace</p><p>将外部redis的数据导入集群 </p><p>redis-cli –cluster import 127.0.01:6379 –cluster-from 127.0.0.2:6379 –cluster-replace –cluster-copy</p><p>说明：外部Redis实例（127.0.0.2:6379）导入到集群中的任意一节点，倒入之后，原来集群的key变为空，导入到新集群的key会自动分片到各个mater节点的slot</p><p>--cluster-replace 如果集群（127.0.01:6379）中存在外部redis实例（127.0.0.2:6379）的key，则会覆盖掉（10.35.2.68:6379）的value</p><p>--cluster-copy 默认情况下，import 命令在向集群导入数据的同时，还会删除单机服务器中源数据。如果用户想要保留单机服务器中的数据，那么可以在执行命令的同时给定 –cluster-copy 选项 </p><p>该命令将正在运行的实例的所有键（从源实例中删除键）移动到指定的预先存在的 Redis 集群。</p><p>实际项目上，数据导入应该用redis-shake工具的比较多。</p><h2 id="12、–cluster-backup-备份集群rdb文件-1"><a href="#12、–cluster-backup-备份集群rdb文件-1" class="headerlink" title="12、–cluster backup         备份集群rdb文件"></a>12、–cluster backup         备份集群<a href="https://so.csdn.net/so/search?q=rdb&spm=1001.2101.3001.7020">rdb</a>文件</h2><p>backup         host:port backup_directory    </p><p>备份主节点上的数据值RDB文件</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@localhost bin]# mkdir backup[root@localhost bin]# ./redis-cli --cluster backup <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>  ./backup&gt;&gt;&gt; Performing Cluster Check (using node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>)M: <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>   slots:[<span class="hljs-number">0</span>-<span class="hljs-number">5460</span>] (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">8</span>ae862c1815ff89e49d6c8801ea0cb074e82855c <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7006</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad292637873S: f6df82f6c67fbe83049d6f95a8473221afee2ee<span class="hljs-number">6 192.168.84</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41eaM: <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003</span>   slots:[<span class="hljs-number">10923-16383</span>] (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">4</span>cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7005</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43feM: <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002</span>   slots:[<span class="hljs-number">5461-10922</span>] (<span class="hljs-number">5462</span> slots) master   <span class="hljs-number">1</span> additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All <span class="hljs-number">16384</span> slots covered.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">232</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7001</span>-<span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea.rdb&#x27;Transfer finished with success.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">226</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7003</span>-<span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span>.rdb&#x27;Transfer finished with success.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">206</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7002</span>-<span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe.rdb&#x27;Transfer finished with success.Saving cluster configuration to: ./backup/nodes.json[OK] Backup created into: ./backup<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47dcb320ce3a8ca6ab958daf758a3194.png"></p><p>nodes.json保存的是集群结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">[root@localhost bin]# cat nodes.json [  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;30c69d9e408015082c1a2145875cd1ec0c7a41ea&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7001</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[0,5460]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5461</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">1</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;8ae862c1815ff89e49d6c8801ea0cb074e82855c&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7006</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;222df2165b7b9dba291cfa572d472ad292637873&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">3</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;f6df82f6c67fbe83049d6f95a8473221afee2ee6&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7004</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;30c69d9e408015082c1a2145875cd1ec0c7a41ea&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">1</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;222df2165b7b9dba291cfa572d472ad292637873&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7003</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[10923,16383]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5461</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">3</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;4cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7005</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;10a4381d9869e293cad95bf75482f506de9f43fe&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">2</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;10a4381d9869e293cad95bf75482f506de9f43fe&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7002</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[5461,10922]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5462</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">2</span>  &#125;]<br></code></pre></td></tr></table></figure><p>   </p><p>显示推荐内容# redis集群的维护（redis-cli –cluster 命令用法）</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/original.png"></p><p><a href="https://blog.csdn.net/cj_eryue" title="cj_eryue">cj_eryue</a> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newUpTime2.png"> 已于 2024-06-11 10:54:16 修改</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes2.png"> 阅读量7.1k <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect2.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollectionActive2.png"> 收藏 19</p><p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Active.png"> <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/newHeart2023Black.png"> 点赞数 6</p><p>分类专栏： <a href="https://blog.csdn.net/cj_eryue/category_7806826.html">redis</a> 文章标签： <a href="https://so.csdn.net/so/search/s.do?q=redis&t=all&o=vip&s=&l=&f=&viparticle=&from_tracking_code=tag_word&from_code=app_blog_art">redis</a></p><p>于 2023-09-12 10:51:33 首次发布</p><p>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。</p><p>本文链接：<a href="https://blog.csdn.net/cj_eryue/article/details/132811758">https://blog.csdn.net/cj_eryue&#x2F;article&#x2F;details&#x2F;132811758</a></p><p>版权</p><p> <a href="javascript:;" title="开放原子开发者工作坊"><img src="https://devpress.csdnimg.cn/79de2bf0b7994defa4242ef90d5513fa.jpg"> 开放原子开发者工作坊 文章已被社区收录</a></p><p>加入社区</p><p> <a href="https://blog.csdn.net/cj_eryue/category_7806826.html" title="redis"><img src="https://i-blog.csdnimg.cn/columns/default/20201014180756913.png?x-oss-process=image/resize,m_fixed,h_224,w_224"> redis 专栏收录该内容</a></p><p>12 篇文章 2 订阅</p><p>订阅专栏</p><p><strong>目录</strong></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t0">前言</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t1">1、 –cluster create  创建集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t2">2、–cluster check  检查集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t3">3、–cluster info 查看集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t4">4、–cluster fix  修复集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t5">5、–cluster rehard 迁移槽位</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t6">6、 –cluster rebalance 平衡集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t7">7、 –cluster  add-node    集群扩容</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t8">8、–cluster del-node      集群缩容</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t9">9、 –cluster call  在集群中执行命令</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t10">10、–cluster set-timeout     整个集群的cluster-node-timeout时间</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t11">11、–cluster import          导入数据至集群</a></p><p><a href="https://blog.csdn.net/cj_eryue/article/details/132811758#t12">12、–cluster backup         备份集群rdb文件</a></p><hr><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p><code>redis-trib.rb</code>是官方提供的Redis Cluster的管理工具，它提供了集群创建、检查、修复、均衡等命令行工具。Redis Cluster 在5.0之后取消了ruby脚本的支持，而是直接集合到redis-cli里，避免了再安装ruby的相关环境。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">[root@localhost bin]# ./redis-cli --cluster helpCluster Manager Commands:  create         host1:port1 ... hostN:portN                 --cluster-replicas <span class="hljs-symbol">&lt;arg&gt;</span>  check          hos<span class="hljs-variable">t:port</span>                 --cluster-<span class="hljs-built_in">search</span>-multiple-owners  info           hos<span class="hljs-variable">t:port</span>  <span class="hljs-keyword">fix</span>            hos<span class="hljs-variable">t:port</span>                 --cluster-<span class="hljs-built_in">search</span>-multiple-owners                 --cluster-<span class="hljs-keyword">fix</span>-with-unreachable-masters  reshard        hos<span class="hljs-variable">t:port</span>                 --cluster-from <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-<span class="hljs-keyword">to</span> <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-slots <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-yes                 --cluster-timeout <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-pipeline <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-replace  rebalance      hos<span class="hljs-variable">t:port</span>                 --cluster-weight &lt;node1=w1...nodeN=<span class="hljs-keyword">wN</span>&gt;                 --cluster-use-<span class="hljs-built_in">empty</span>-masters                 --cluster-timeout <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-simulate                 --cluster-pipeline <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-threshold <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-replace  <span class="hljs-built_in">add</span>-node       new_hos<span class="hljs-variable">t:new_port</span> existing_hos<span class="hljs-variable">t:existing_port</span>                 --cluster-slave                 --cluster-master-id <span class="hljs-symbol">&lt;arg&gt;</span>  del-node       hos<span class="hljs-variable">t:port</span> node_id  <span class="hljs-keyword">call</span>           hos<span class="hljs-variable">t:port</span> <span class="hljs-keyword">command</span> arg arg .. arg                 --cluster-<span class="hljs-keyword">only</span>-masters                 --cluster-<span class="hljs-keyword">only</span>-replicas  <span class="hljs-keyword">set</span>-timeout    hos<span class="hljs-variable">t:port</span> milliseconds  import         hos<span class="hljs-variable">t:port</span>                 --cluster-from <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-user <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-pass <span class="hljs-symbol">&lt;arg&gt;</span>                 --cluster-from-askpass                 --cluster-<span class="hljs-keyword">copy</span>                 --cluster-replace  backup         hos<span class="hljs-variable">t:port</span> backup_directory  <span class="hljs-keyword">help</span>            For check, <span class="hljs-keyword">fix</span>, reshard, del-node, <span class="hljs-keyword">set</span>-timeout you can specify the host <span class="hljs-built_in">and</span> port of any working node in the cluster. Cluster Manager Options:  --cluster-yes  Automatic yes <span class="hljs-keyword">to</span> cluster commands prompts <br></code></pre></td></tr></table></figure><p>下面我们来详细的说下各命令的用法和作用：</p><h2 id="1、-–cluster-create-创建集群-2"><a href="#1、-–cluster-create-创建集群-2" class="headerlink" title="1、 –cluster create  创建集群"></a><strong>1、 –cluster create</strong>  创建<strong>集群</strong></h2><p>create         host1:port1 … hostN:portN<br>                 –cluster-replicas <arg></p><p>该命令用来创建集群，假设我现在想搭建三主三从的集群127.0.0.1:7001~7006</p><p>启动所有节点后，可通过如下命令进行搭建：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7001 127.0</span>.<span class="hljs-number">0.1:7002</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7003 127.0</span>.<span class="hljs-number">0.1:7004</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7005 127.0</span>.<span class="hljs-number">0.1:7006</span> --cluster-replicas <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>--cluster-replicas 1 :表示每个主节点需要1个从节点。这里随机分配主从关系，如果需要定制，则可以不加该参数，使用add-node来定制,查看第7节</p><h2 id="2、–cluster-check-检查集群-2"><a href="#2、–cluster-check-检查集群-2" class="headerlink" title="2、–cluster check  检查集群"></a><strong>2、–cluster check  检查集群</strong></h2><p>check          host:port<br>                 –cluster-search-multiple-owners #检查是否有槽同时被分配给了多个节点</p><p>该命令经常使用，需要拥有槽位的所有节点为启动状态，用于检查集群状态是否正常，只有当所有的槽位正常时，集群状态才OK</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f1b7cd4b9fc1eb68c1e9383ac8005d40.png"></p><h2 id="3、–cluster-info-查看集群-2"><a href="#3、–cluster-info-查看集群-2" class="headerlink" title="3、–cluster info 查看集群"></a><strong>3、–cluster info 查看集群</strong></h2><p>用于查看集群的简易信息</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d3968b7dce8b99f3fc589b2eba9104df.png"></p><h2 id="4、–cluster-fix-修复集群-2"><a href="#4、–cluster-fix-修复集群-2" class="headerlink" title="4、–cluster fix  修复集群"></a><strong>4、–cluster fix  修复集群</strong></h2><p>fix            host:port<br>                 –cluster-search-multiple-owners    <br>                 –cluster-fix-with-unreachable-masters  </p><p>该命令十分有用，说明如下：</p><p> –cluster-search-multiple-owners ： 是否修复多个拥有者的槽位。当集群中的槽位在迁移过程中，出现意外时，使用fix可使用该参数。fix功能，redis内部在槽位的某些异常情况下会交互式的询问操作者是否同意它的修复策略，一般情况下，默认即可。</p><p> –cluster-fix-with-unreachable-masters ： 是否修复不可达的主节点上的槽位。例如，集群中某个主节点就是坏掉了，也没有故障转移成功。此时如何恢复该主节点上的所有槽位呢，这时就可以使用该参数，会将处于该主节点上的所有槽位恢复到存活的主节点上（之前的数据会丢失，仅仅是恢复了槽位）。</p><h2 id="5、–cluster-rehard-迁移槽位-2"><a href="#5、–cluster-rehard-迁移槽位-2" class="headerlink" title="5、–cluster rehard 迁移槽位"></a><strong>5、–cluster rehard 迁移槽位</strong></h2><p>reshard        host:port<br>                 –cluster-from <arg>   #槽位来源的节点运行id，多个用,分割，all表示全部节点<br>                 –cluster-to <arg>       #目标节点的运行id，只允一个<br>                 –cluster-slots <arg>   #迁移的槽位数<br>                 –cluster-yes               #是否默认同意集群内部的迁移计划（默认同意就可以）<br>                 –cluster-timeout <arg>   #迁移命令（migrate）的超时时间<br>                 –cluster-pipeline <arg>  #迁移key时，一次取出 的key数量，默认10<br>                 –cluster-replace           #是否直接replace到目标节点</p><p>迁移一个或者多个（–cluster-from）节点上的–cluster-slots个槽位至一个目标节点（–cluster-to）上。</p><p> –cluster-from 的值不为all的情况下， –cluster-from不能包含–cluster-to</p><p>可以使用如下命令查看整个集群中的所有运行id</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@localhost bin]# ./redis-cli -h <span class="hljs-number">192.168.84.1</span> -p <span class="hljs-number">7001</span> cluster nodes8ae862c1815ff89e49d6c8801ea0cb074e82855c <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7006@17006</span> slave <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">0</span> <span class="hljs-number">1694427906290</span> <span class="hljs-number">3</span> connectedf6df82f6c67fbe83049d6f95a8473221afee2ee<span class="hljs-number">6 192.168.84</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004@17004</span> slave <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">0</span> <span class="hljs-number">1694427905000</span> <span class="hljs-number">1</span> connected222df2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003@17003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1694427904000</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923</span>-<span class="hljs-number">163834</span>cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7005@17005</span> slave <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">0</span> <span class="hljs-number">1694427905255</span> <span class="hljs-number">2</span> connected30c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001@17001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1694427902000</span> <span class="hljs-number">1</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">546010</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002@17002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1694427902000</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461-10922</span><br></code></pre></td></tr></table></figure><p>通过集群的配置文件查看也可以</p><h2 id="6、-–cluster-rebalance-平衡集群-2"><a href="#6、-–cluster-rebalance-平衡集群-2" class="headerlink" title="6、 –cluster rebalance 平衡集群"></a>6、 <strong>–cluster rebalance 平衡集群</strong></h2><p>rebalance      host:port<br>                 –cluster-weight &lt;node1&#x3D;w1…nodeN&#x3D;wN&gt;<br>                 –cluster-use-empty-masters<br>                 –cluster-timeout <arg>     #迁移命令（migrate）的超时时间<br>                 –cluster-simulate              # 模拟rebalance操作，不会真正执行迁移操作<br>                 –cluster-pipeline <arg>    #定义 getkeysinslot命令一次取出的key数量，默认值为10<br>                 –cluster-threshold <arg><br>                 –cluster-replace               #是否直接replace到目标节点</p><p>--cluster-weight： 槽位权重（浮点型）比值，例如（这里使用端口号代替运行id）： 7001&#x3D;1.0,7002&#x3D;1.0,7003&#x3D;2.0 则表示，总权重为4.0， 7001和7002将分配到 (16384&#x2F;4)*1  个槽位，7003则是(16384&#x2F;4)*2个槽位。</p><p> –cluster-threshold: 平衡触发的阈值条件，默认为2.00%。例如上一步，7001和7002应该有4096个槽位，如果7001的槽位数不够4096个，且超过 (4096*0.02 约等于)82个及以上；或者7001的槽位数比4096少于82个及以上，则会触发自平衡。</p><h2 id="7、-–cluster-add-node-集群扩容-2"><a href="#7、-–cluster-add-node-集群扩容-2" class="headerlink" title="7、 –cluster  add-node    集群扩容"></a><strong>7、 –cluster  add-node    集群扩容</strong></h2><p>add-node    new_host:new_port                  #新加入集群的ip和port</p><p>                existing_host:existing_port          #集群中任一节点的ip和port<br>                 –cluster-slave                             #新节点作为从节点，默认随机一个主节点<br>                 –cluster-master-id <arg>            #给新节点指定主节点,值为节点的运行id</p><p>可用于向集群中添加主、从节点(即扩容)</p><p>假设我现在集群中有7001 7002 7003三个主节点了，想为7001添加一个从节点127.0.0.1:7006，则可执行如下命令：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> add-node </span>127.0.0.1:7006 127.0.0.1:7001  --cluster-slave --cluster-master-id 30c69d9e408015082c1a2145875cd1ec0c7a41ea<br></code></pre></td></tr></table></figure><p> 不传入–cluster-slave –cluster-master-id 参数，表示添加一个主节点。</p><p>当添加的是一个主节点时，此时，该主节点没有任何槽位，可以使用rebalance或者reshard来迁移槽位给它。</p><h2 id="8、–cluster-del-node-集群缩容-2"><a href="#8、–cluster-del-node-集群缩容-2" class="headerlink" title="8、–cluster del-node      集群缩容"></a><strong>8、–cluster del-node      集群缩容</strong></h2><p>del-node    host:port node_id         #删除给定的一个节点，成功后关闭该节点服务</p><p>也就是缩容。</p><p>删除一个主节点要求先迁移走改主节点上的槽位（数据），这时就可以使用reshard命令了。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[root@localhost bin]</span># ./redis-cli --cluster del-node <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span> <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe&gt;&gt;&gt; Removing node <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-keyword">from</span> cluster <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span>[ERR] Node <span class="hljs-number">192.168</span><span class="hljs-number">.84</span><span class="hljs-number">.1</span>:<span class="hljs-number">7002</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> empty! Reshard data away <span class="hljs-keyword">and</span> <span class="hljs-keyword">try</span> again.<br></code></pre></td></tr></table></figure><h2 id="9、-–cluster-call-在集群中执行命令-2"><a href="#9、-–cluster-call-在集群中执行命令-2" class="headerlink" title="9、 –cluster call  在集群中执行命令"></a><strong>9、 –cluster call</strong>  在集群中执行命令</h2><p>call           host:port command arg arg .. arg               #在集群的所有节点执行相关命令<br>                 –cluster-only-masters                                #是否只在主节点上执行<br>                 –cluster-only-replicas                                #是否只在从节点上执行</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/59db12799c1a7acd9c6fc267ccf790fc.png"></p><h2 id="10、–cluster-set-timeout-整个集群的cluster-node-timeout时间-2"><a href="#10、–cluster-set-timeout-整个集群的cluster-node-timeout时间-2" class="headerlink" title="10、–cluster set-timeout     整个集群的cluster-node-timeout时间"></a><strong>10、–cluster set-timeout</strong>     整个集群的cluster-node-timeout时间</h2><p>        set-timeout    host:port milliseconds</p><p>设置整个集群的cluster-node-timeout时间</p><h2 id="11、–cluster-import-导入数据至集群-2"><a href="#11、–cluster-import-导入数据至集群-2" class="headerlink" title="11、–cluster import          导入数据至集群"></a><strong>11、–cluster import</strong>          导入数据至集群</h2><p>import         host:port<br>                 –cluster-from <arg><br>                 –cluster-from-user <arg><br>                 –cluster-from-pass <arg><br>                 –cluster-from-askpass<br>                 –cluster-copy               #migrate时指定类型为copy<br>                 –cluster-replace           #migrate时指定类型为replace</p><p>将外部redis的数据导入集群 </p><p>redis-cli –cluster import 127.0.01:6379 –cluster-from 127.0.0.2:6379 –cluster-replace –cluster-copy</p><p>说明：外部Redis实例（127.0.0.2:6379）导入到集群中的任意一节点，倒入之后，原来集群的key变为空，导入到新集群的key会自动分片到各个mater节点的slot</p><p>--cluster-replace 如果集群（127.0.01:6379）中存在外部redis实例（127.0.0.2:6379）的key，则会覆盖掉（10.35.2.68:6379）的value</p><p>--cluster-copy 默认情况下，import 命令在向集群导入数据的同时，还会删除单机服务器中源数据。如果用户想要保留单机服务器中的数据，那么可以在执行命令的同时给定 –cluster-copy 选项 </p><p>该命令将正在运行的实例的所有键（从源实例中删除键）移动到指定的预先存在的 Redis 集群。</p><p>实际项目上，数据导入应该用redis-shake工具的比较多。</p><h2 id="12、–cluster-backup-备份集群rdb文件-2"><a href="#12、–cluster-backup-备份集群rdb文件-2" class="headerlink" title="12、–cluster backup         备份集群rdb文件"></a>12、–cluster backup         备份集群<a href="https://so.csdn.net/so/search?q=rdb&spm=1001.2101.3001.7020">rdb</a>文件</h2><p>backup         host:port backup_directory    </p><p>备份主节点上的数据值RDB文件</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@localhost bin]# mkdir backup[root@localhost bin]# ./redis-cli --cluster backup <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>  ./backup&gt;&gt;&gt; Performing Cluster Check (using node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>)M: <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span>   slots:[<span class="hljs-number">0</span>-<span class="hljs-number">5460</span>] (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">8</span>ae862c1815ff89e49d6c8801ea0cb074e82855c <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7006</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad292637873S: f6df82f6c67fbe83049d6f95a8473221afee2ee<span class="hljs-number">6 192.168.84</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41eaM: <span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span> <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003</span>   slots:[<span class="hljs-number">10923-16383</span>] (<span class="hljs-number">5461</span> slots) master   <span class="hljs-number">1</span> additional replica(s)S: <span class="hljs-number">4</span>cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7005</span>   slots: (<span class="hljs-number">0</span> slots) slave   replicates <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43feM: <span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002</span>   slots:[<span class="hljs-number">5461-10922</span>] (<span class="hljs-number">5462</span> slots) master   <span class="hljs-number">1</span> additional replica(s)[OK] All nodes agree about slots configuration.&gt;&gt;&gt; Check for open slots...&gt;&gt;&gt; Check slots coverage...[OK] All <span class="hljs-number">16384</span> slots covered.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7001</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">232</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7001</span>-<span class="hljs-number">30</span>c69d9e408015082c1a2145875cd1ec0c7a41ea.rdb&#x27;Transfer finished with success.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7003</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">226</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7003</span>-<span class="hljs-number">222d</span>f2165b7b9dba291cfa572d472ad<span class="hljs-number">292637873</span>.rdb&#x27;Transfer finished with success.&gt;&gt;&gt; Node <span class="hljs-number">192.168.84.1</span>:<span class="hljs-number">7002</span> -&gt; Saving RDB...SYNC sent to master, writing <span class="hljs-number">206</span> bytes to &#x27;./backup/redis-node-<span class="hljs-number">192.168.84.1</span>-<span class="hljs-number">7002</span>-<span class="hljs-number">10</span>a4381d9869e293cad95bf75482f506de9f43fe.rdb&#x27;Transfer finished with success.Saving cluster configuration to: ./backup/nodes.json[OK] Backup created into: ./backup<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47dcb320ce3a8ca6ab958daf758a3194.png"></p><p>nodes.json保存的是集群结构：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">[root@localhost bin]# cat nodes.json [  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;30c69d9e408015082c1a2145875cd1ec0c7a41ea&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7001</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[0,5460]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5461</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">1</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;8ae862c1815ff89e49d6c8801ea0cb074e82855c&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7006</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;222df2165b7b9dba291cfa572d472ad292637873&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">3</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;f6df82f6c67fbe83049d6f95a8473221afee2ee6&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7004</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;30c69d9e408015082c1a2145875cd1ec0c7a41ea&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">1</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;222df2165b7b9dba291cfa572d472ad292637873&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7003</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[10923,16383]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5461</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">3</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;4cdc4c8127dc5ea8d15a239fa6c2f3c09b0d5f3a&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7005</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: <span class="hljs-string">&quot;10a4381d9869e293cad95bf75482f506de9f43fe&quot;</span>,    <span class="hljs-string">&quot;slots&quot;</span>: [],    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">0</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;slave&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">2</span>  &#125;,  &#123;    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;10a4381d9869e293cad95bf75482f506de9f43fe&quot;</span>,    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;192.168.84.1&quot;</span>,    <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">7002</span>,    <span class="hljs-string">&quot;replicate&quot;</span>: null,    <span class="hljs-string">&quot;slots&quot;</span>: <span class="hljs-string">[[5461,10922]]</span>,    <span class="hljs-string">&quot;slots_count&quot;</span>: <span class="hljs-number">5462</span>,    <span class="hljs-string">&quot;flags&quot;</span>: <span class="hljs-string">&quot;master&quot;</span>,    <span class="hljs-string">&quot;current_epoch&quot;</span>: <span class="hljs-number">2</span>  &#125;]<br></code></pre></td></tr></table></figure><p>   </p><p>显示推荐内容</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redisson分布式锁</title>
    <link href="/article/41a6994d.html"/>
    <url>/article/41a6994d.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />在[多线程](https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020)环境下，为了保证数据的线程安全，我们通常用加锁的方式，使同一时刻只有一个线程可以对这个共享资源进行操作，**在单服务系统我们常用JVM锁——[Synchronized、ReentrantLock等](https://blog.csdn.net/weixin_45433817/article/details/132216383 "Synchronized、ReentrantLock等")。然而在多台服务系统的情况下，JVM锁就无法在多个服务器之间生效了，这时候我们就需要用分布式锁来解决线程安全的问题。**<p>分布式锁的实现方式有很多，主流的就是基于<strong>数据库、zookeeper以及redis</strong>，当然使用redis的居多，由于篇幅原因，本节就详细介绍一下使用redis实现分布式锁的几种方式。</p><h2 id="一、SETNX实现"><a href="#一、SETNX实现" class="headerlink" title="一、SETNX实现"></a>一、SETNX实现</h2><p><strong>ps：本文重点使Redisson实现分布式锁，咱就不从SETNX+EXPIRE、SETNX+LUA脚本…什么的逐步演进了，本身就是一回事，直接一步到位，用set ex px nx+唯一校验+LUA脚本删除等操作实现。</strong></p><p>利用<strong>Redis的单线程</strong>特性，在多个Redis客户端通过SETNX，如果返回1表示获取锁成功，反之失败。因为Redis的单线程机制，所以可以保证一个客户端成功获取后，其它客户端都会获取失败。伪代码如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">public class RedisLock &#123;    private Jedis jedis;    private void init()&#123;        //建立连接        jedis = JedisPoolFactory.getJedis();    &#125;    /**     * 获取锁     * @param lockKey 锁的键值     * @param requestId 唯一标识     * @param expireTime 过期时间     * @<span class="hljs-keyword">return</span> 是否获取锁 成功返回<span class="hljs-keyword">true</span>，反之<span class="hljs-keyword">false</span>     */    public boolean tryLock(<span class="hljs-keyword">String</span> lockKey,<span class="hljs-keyword">String</span> requestId,int expireTime)&#123;        //<span class="hljs-number">2</span>、加锁        <span class="hljs-keyword">String</span> result = jedis.<span class="hljs-keyword">set</span>(lockKey,requestId,<span class="hljs-string">&quot;NX&quot;</span>,<span class="hljs-string">&quot;EX&quot;</span>,expireTime);​        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(result);    &#125;​    /**     * 释放锁     * @param lockKey 锁的键值     * @param requestId 唯一标识     * @<span class="hljs-keyword">return</span> 成功<span class="hljs-keyword">true</span>，失败<span class="hljs-keyword">false</span>     */    public boolean unlock(<span class="hljs-keyword">String</span> lockKey,<span class="hljs-keyword">String</span> requestId)&#123;        //LUA脚本：判断当前锁的值是否等于请求标识requestId，如果是则删除锁并返回<span class="hljs-keyword">true</span>，反之返回<span class="hljs-keyword">false</span>。        <span class="hljs-keyword">String</span> scripts = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +                <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;        Object result = jedis.eval(scripts, Collections.singletonList(lockKey), Collections.singletonList(requestId));        <span class="hljs-keyword">return</span> Long.parseLong(result.toString())==<span class="hljs-number">1</span>L;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>存在的问题：</strong></p><blockquote><ul><li><strong>锁无法续期：</strong>假设线程A获取了锁，但是由于网络原因，执行时间超过了设置的过期时间，这是锁被释放了，线程B获取锁成功，此时线程A和B都会执行临界区的代码，这是绝对不允许的。</li></ul></blockquote><h2 id="二、Redisson实现分布式锁"><a href="#二、Redisson实现分布式锁" class="headerlink" title="二、Redisson实现分布式锁"></a>二、Redisson实现分布式锁</h2><p>在使用SETNX实现的分布式锁中，存在锁无法续期导致并发冲突的问题。不过这个问题在Redisson中用看门狗的机制巧妙地解决了，这也是我们实现分布式锁最常用的方式。</p><h3 id="2-1-整体类图"><a href="#2-1-整体类图" class="headerlink" title="2.1 整体类图"></a>2.1 整体类图</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2163205be5f25e23897ced4a05a14cb9.png"></p><p>标黄的两个类就是我们今天的重点，看门狗续期的实现逻辑在<strong>RedissionBaseLock类</strong>中，加锁逻辑在<strong>RedissionLock类</strong>中。</p><h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3><p>在深入代码前，我们先看下加锁、看门狗续期大致的流程，有个大致印象。</p><p><img src="https://i-blog.csdnimg.cn/direct/47e9d6b55dd9448d8fe54d097e8bfbd3.png"></p><h3 id="2-3-加锁流程源码分析"><a href="#2-3-加锁流程源码分析" class="headerlink" title="2.3 加锁流程源码分析"></a>2.3 加锁流程源码分析</h3><p>下面我们就按上面的流程图，走走源码。</p><h4 id="2-3-1-lock-—加锁入口"><a href="#2-3-1-lock-—加锁入口" class="headerlink" title="2.3.1 lock()—加锁入口"></a>2.3.1 lock()—加锁入口</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c90322cb4a159b87fd04aca1081c2e2.png"></p><ul><li>lock方法，一个没设置过期时间，一个设置了过期时间。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/096f1c9bba501ea1e6b22b942c56c93f.png"></p><p>解析：</p><blockquote><ul><li>第一个红框：尝试加锁，会返回null或者具体的值，<strong>返回null表示加锁成功，反之有线程持有该锁，加锁失败。</strong></li><li>第二个红框：<strong>加锁失败，while循环不断尝试。</strong></li></ul></blockquote><h4 id="2-3-2-tryAcquire-—执行加锁LUA脚本并判断是否要进行锁续期"><a href="#2-3-2-tryAcquire-—执行加锁LUA脚本并判断是否要进行锁续期" class="headerlink" title="2.3.2 tryAcquire()—执行加锁LUA脚本并判断是否要进行锁续期"></a>2.3.2 tryAcquire()—执行加锁LUA脚本并判断是否要进行锁续期</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/17e3ff2ffae885cde2e3349b11819e08.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8ab1b8816bdb35dc5cd7918ee3e682dc.png"></p><blockquote><ul><li><p>第一个红框：执行加锁LUA脚本，返回null说明加锁成功，反之失败。</p><ul><li><p><strong>如果设置了过期时间，第二个参数就传设置的时间。</strong></p></li><li><p>反之，使用默认的<strong>internallockLeaseTime</strong>时间。</p></li></ul></li><li><p>第二个红框：如果加锁成功（null），且设置了过期时间，将设置过期时间赋值给internallockLeaseTime，如果没设置，则执行<strong>scheduleExpirationRenewal方法（看门狗）。</strong>返回结果。</p></li></ul></blockquote><p><strong>ps：internallockLeaseTime默认就是30s。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3776045e441c2b913a359ec9fbe4266d.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a0950ff3af7e06b77e31416b71c66999.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04323d9885389ecb586ed19b62ac751c.png"></p><h4 id="2-3-3-tryLockInnerAsync-—–选择slot槽并执行lua脚本"><a href="#2-3-3-tryLockInnerAsync-—–选择slot槽并执行lua脚本" class="headerlink" title="2.3.3 tryLockInnerAsync()—–选择slot槽并执行lua脚本"></a>2.3.3 tryLockInnerAsync()—–选择slot槽并执行lua脚本</h4><p>我们先看如何执行LUA加锁脚本的，这里面有点深。。。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/16032194b6c649b468f75692ef55f6b4.png"> <img src="https://i-blog.csdnimg.cn/blog_migrate/3aac08c39e8ead75464cc1c9aeb18fe7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cff71f24ba3ea06fa99bc94dc294f563.png"></p><p><strong>slot槽这里就不多讲了。。。我们回到LUA脚本。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aaa3bc287881377ff5ecdf9d7b7c1fdd.png"></p><blockquote><ul><li><strong>首先检查锁的key是否存在，如果不存在，判断是否是同一线程再次过来对同一个key进行加锁，也就是当前key是否被当前线程持有（可重入性）。</strong></li><li>如果上述两个条件任意一个成立，则对当前key执行自增和设置过期时间操作，并<strong>返回null表示加锁成功。</strong></li><li><strong>反之，返回当前锁的过期时间，表示加锁失败。</strong></li></ul></blockquote><h3 id="2-4-watch-dog源码分析"><a href="#2-4-watch-dog源码分析" class="headerlink" title="2.4 watch dog源码分析"></a>2.4 watch dog源码分析</h3><h4 id="2-4-1-scheduleExpirationRenewal-–锁续期入口"><a href="#2-4-1-scheduleExpirationRenewal-–锁续期入口" class="headerlink" title="2.4.1 scheduleExpirationRenewal()–锁续期入口"></a>2.4.1 scheduleExpirationRenewal()–锁续期入口</h4><p>当加锁成功，且没有设置过期时间，执行<strong>scheduleExpirationRenewal()方法</strong>，这也是我们常说的”看门狗”的实现逻辑。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/708d64a8687a87050b20fe1e5e88a36e.png"></p><blockquote><ul><li>第一个红框：EXPIRATION_RENEWAL_MAP存放续期任务，get有值说明当前锁需要续期，为null则不需要再续期了。</li><li>第二个红框，执行续期操作。</li></ul></blockquote><h4 id="2-4-2-renewExpiration-—-执行锁续期操作"><a href="#2-4-2-renewExpiration-—-执行锁续期操作" class="headerlink" title="2.4.2 renewExpiration()—-执行锁续期操作"></a>2.4.2 renewExpiration()—-执行锁续期操作</h4><p>这个方法用<strong>netty的时间轮</strong>进行续期。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/50ed4ade0574c203c1e118abc1920cfd.png"></p><blockquote><ul><li><p>第一个红框：首先会从<strong>EXPIRATION_RENEWAL_MAP</strong>中获取一个值，如果为null，就不续期了，<strong>说明这个锁可能已经被释放或过期了。</strong></p></li><li><p>第二个红框：基于TimerTask实现一个定时任务，设置<strong>internalLockLeaseTime &#x2F; 3</strong>的时长进行一次锁续期，也就是每10s进行一次续期。</p><ul><li><p>这里也会从<strong>EXPIRATION_RENEWAL_MAP</strong>里获取一个值，检查锁是否被释放。</p></li><li><p><strong>如果不为null，则获取第一个thread（也就是持有锁的线程），如果为null则说明锁也被释放了，此时也不需要续期。</strong></p></li><li><p>如果不为null，说明需要续期，它会异步调用<strong>renewExpirationAsync(threadId)方法</strong>来实现续期。</p></li><li><p>当异步续期操作完成，会调用whenComplete方法来处理结果，如果有异常，则将该锁从<strong>EXPIRATION_RENEWAL_MAP</strong>中移除。如果续期成功，则会重新调用<strong>renewExpiration()方法</strong>进行下一次续期，如果续期失败，则调用<strong>cancelExpirationRenewal()方法</strong>取消续期。</p></li></ul></li></ul></blockquote><h4 id="2-4-3-renewExpirationAsync-–执行锁续期LUA脚本"><a href="#2-4-3-renewExpirationAsync-–执行锁续期LUA脚本" class="headerlink" title="2.4.3 renewExpirationAsync()–执行锁续期LUA脚本"></a>2.4.3 renewExpirationAsync()–执行锁续期LUA脚本</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2bc37246d829ed6149898214984c7ab2.png"></p><blockquote><ul><li><strong>如果当前key存在，说明当前锁还被该线程持有，那么就重置过期时间为30s，并返回true，表示续期成功，反之返回false。</strong></li></ul></blockquote><h4 id="2-4-4-cancelExpirationRenewal—取消锁续期"><a href="#2-4-4-cancelExpirationRenewal—取消锁续期" class="headerlink" title="2.4.4 cancelExpirationRenewal—取消锁续期"></a>2.4.4 cancelExpirationRenewal—取消锁续期</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/70dd77797eb7311864199dbdc59537b6.png"></p><blockquote><ul><li>还是从这个map里获取键值对，如果为null，说明续期任务不存在，也没必要进行下去了，直接返回。</li><li>如果threadId不为null，直接将这个续期任务从task里移除。</li><li>如果threadId为null或者task中不再有任何线程在等待续期，此时就调用cancel方法来取消定时任务，然后在从<strong>EXPIRATION_RENEWAL_MAP</strong>中移除该续期任务。</li></ul></blockquote><p><strong>ps：当unlock的时候也会调该方法，来执行取消锁续期的操作。</strong></p><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><h4 id="2-5-1-什么时候会进行锁续期"><a href="#2-5-1-什么时候会进行锁续期" class="headerlink" title="2.5.1 什么时候会进行锁续期"></a>2.5.1 什么时候会进行锁续期</h4><blockquote><p>加锁时，如果没有指定过期时间，则默认过期时间为30s且每隔10s进行锁续期操作。</p><p><strong>ps：参考2.3.2和2.4.2小节。</strong></p></blockquote><h4 id="2-5-2-什么情况会停止续期"><a href="#2-5-2-什么情况会停止续期" class="headerlink" title="2.5.2 什么情况会停止续期"></a>2.5.2 什么情况会停止续期</h4><blockquote><ul><li><p>锁被释放。</p></li><li><p>续期时发生异常。</p></li><li><p>执行锁续期LUA脚本失败。</p></li><li><p>Redission的续期时Netty时间轮（TimerTask、TimeOut、Timer）的，并且操作都是基于JVM，所以当应用宕机、下线或重启后，续期任务也没有了。</p></li></ul><p><strong>ps：参考2.4.3小节。</strong></p></blockquote><h3 id="2-6-lock-和trylock-的区别"><a href="#2-6-lock-和trylock-的区别" class="headerlink" title="2.6 lock()和trylock()的区别"></a>2.6 lock()和trylock()的区别</h3><p>讲了半天忘了说使用redission实现分布式锁的示例了😂，索性就在这补充一下吧。</p><p><strong>lock()：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RLock lock = redisson.getLock(<span class="hljs-string">&quot;MyLock&quot;</span>);lock.lock();<span class="hljs-regexp">//</span>阻塞方法，知道获取到锁try &#123;    <span class="hljs-regexp">//</span>业务代码&#125;finally &#123;    <span class="hljs-regexp">//</span>当前锁存在且被当前线程持有     <span class="hljs-keyword">if</span>(lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread())&#123;      <span class="hljs-regexp">//</span>释放锁      lock.unlock();   &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>lock的原理是以阻塞的方式获取锁，如果获取失败则一直等待，直到获取成功。</p><p><strong>ps：可以参考2.3.1小节。</strong></p></blockquote><p><strong>trylock()：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RLock lock = redisson.getLock(<span class="hljs-string">&quot;MyLock&quot;</span>);boolean b = lock.tryLock();<span class="hljs-regexp">//</span>非阻塞方法，立即返回获取结果<span class="hljs-keyword">if</span>(b)&#123;     try &#123;          <span class="hljs-regexp">//</span>业务代码     &#125;finally &#123;          <span class="hljs-regexp">//</span>当前锁存在且被当前线程持有          <span class="hljs-keyword">if</span>(lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread())&#123;               <span class="hljs-regexp">//</span>释放锁               lock.unlock();           &#125;     &#125;&#125;<span class="hljs-keyword">else</span> &#123;   <span class="hljs-regexp">//</span>获取锁失败，处理逻辑&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c9d3a00e609d59fa4984a1f606e3953.png"></p><blockquote><p>tryLock是尝试获取锁，如果能获取直接返回true，如果无法获取，它会按照我们指定的超时时间进行阻塞，<strong>这个时间内还会尝试获取锁，如果超过这个时间还没获取到，直接返回false。</strong>如果没有指定超时时间，就如我们的示例，那获取不到的话直接就返回false。</p></blockquote><p><strong>我们看下源码：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bf0550041bf17578d7a01ed660437db.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9968619e85e7c4660cc7331cb48315d.png"></p><p><strong>这是没有指定超时时间执行的方法，方法名也很见名知意，就是尝试一次加锁。指定了超时时间的这里就不介绍了，无非是在超时时间内执行while循环尝试获取锁。</strong></p><h2 id="三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用"><a href="#三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用" class="headerlink" title="三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用"></a>三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用</h2><p><strong>ps：这几种锁都不常用，所以就不细讲了，知道有这个事就行。</strong></p><h3 id="3-1-公平锁（FairLock）"><a href="#3-1-公平锁（FairLock）" class="headerlink" title="3.1 公平锁（FairLock）"></a>3.1 公平锁（FairLock）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">RLock <span class="hljs-keyword">lock</span> = redisson.getFairLock(<span class="hljs-string">&quot;MyLock&quot;</span>);<span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br></code></pre></td></tr></table></figure><h3 id="3-2-联锁（MultiLock）"><a href="#3-2-联锁（MultiLock）" class="headerlink" title="3.2 联锁（MultiLock）"></a>3.2 联锁（MultiLock）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">RLock lock1 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock1&quot;</span>)</span>;RLock lock2 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock2&quot;</span>)</span>;RLock lock3 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock3&quot;</span>)</span>;RedissonMultiLock lock=<span class="hljs-keyword">new</span> <span class="hljs-constructor">RedissonMultiLock(<span class="hljs-params">lock1</span>,<span class="hljs-params">lock2</span>,<span class="hljs-params">lock3</span>)</span>;<span class="hljs-comment">//同时加锁lock1、lock2、lock3//所有的锁都上锁成功才算成功lock.lock(); //...lock.unlock();</span><br></code></pre></td></tr></table></figure><h3 id="3-3-读写锁"><a href="#3-3-读写锁" class="headerlink" title="3.3 读写锁"></a>3.3 读写锁</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">RReadWriteLock <span class="hljs-keyword">lock</span> = redisson.getReadWriteLock(&quot;myLock&quot;);//读锁<span class="hljs-keyword">lock</span>.readLock().<span class="hljs-keyword">lock</span>();//写锁<span class="hljs-keyword">lock</span>.writeLock().<span class="hljs-keyword">lock</span>();<br></code></pre></td></tr></table></figure><p><strong>ps：还有个RedLock，这个可以细讲一下，但是由于篇幅原因，就放在下一篇文章吧。</strong></p><h2 id="四、Redission实现分布式锁存在的问题"><a href="#四、Redission实现分布式锁存在的问题" class="headerlink" title="四、Redission实现分布式锁存在的问题"></a>四、Redission实现分布式锁存在的问题</h2><p>Redission使用看门狗续期的方案在大多数场景下是挺不错的，但在极端情况下还是会存在问题，比如：</p><blockquote><ul><li>线程1首先获取锁成功，将键值对写入redis的master节点。</li><li><strong>在redis将master数据同步到slave节点之前，master故障了。</strong></li><li>此时会触发故障转移，将其中一个slave升级为master。</li><li>但新的master并没有线程1写入的键值对，因此如果此时来个线程2，也同样可以获取到锁，这就违背了锁的初衷。</li></ul></blockquote><p>这个场景就是我们常说的<a href="https://blog.csdn.net/weixin_45433817/article/details/137209295?spm=1001.2014.3001.5501" title="集群脑裂">集群脑裂</a><strong>（网络分区）</strong>问题。</p><p>那么比较主流的解决方案就是<strong>Redis作者提出的Redlock</strong>和<strong>Zookeeper</strong>实现的分布式锁，这个我们下节再讲。</p><p><strong>End：希望对大家有所帮助，如果有纰漏或者更好的想法，请您一定不要吝啬你的赐教🙋。</strong>在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>环境下，为了保证数据的线程安全，我们通常用加锁的方式，使同一时刻只有一个线程可以对这个共享资源进行操作，<strong>在单服务系统我们常用JVM锁——<a href="https://blog.csdn.net/weixin_45433817/article/details/132216383" title="Synchronized、ReentrantLock等">Synchronized、ReentrantLock等</a>。然而在多台服务系统的情况下，JVM锁就无法在多个服务器之间生效了，这时候我们就需要用分布式锁来解决线程安全的问题。</strong></p><p>分布式锁的实现方式有很多，主流的就是基于<strong>数据库、zookeeper以及redis</strong>，当然使用redis的居多，由于篇幅原因，本节就详细介绍一下使用redis实现分布式锁的几种方式。</p><h2 id="一、SETNX实现-1"><a href="#一、SETNX实现-1" class="headerlink" title="一、SETNX实现"></a>一、SETNX实现</h2><p><strong>ps：本文重点使Redisson实现分布式锁，咱就不从SETNX+EXPIRE、SETNX+LUA脚本…什么的逐步演进了，本身就是一回事，直接一步到位，用set ex px nx+唯一校验+LUA脚本删除等操作实现。</strong></p><p>利用<strong>Redis的单线程</strong>特性，在多个Redis客户端通过SETNX，如果返回1表示获取锁成功，反之失败。因为Redis的单线程机制，所以可以保证一个客户端成功获取后，其它客户端都会获取失败。伪代码如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">public class RedisLock &#123;    private Jedis jedis;    private void init()&#123;        //建立连接        jedis = JedisPoolFactory.getJedis();    &#125;    /**     * 获取锁     * @param lockKey 锁的键值     * @param requestId 唯一标识     * @param expireTime 过期时间     * @<span class="hljs-keyword">return</span> 是否获取锁 成功返回<span class="hljs-keyword">true</span>，反之<span class="hljs-keyword">false</span>     */    public boolean tryLock(<span class="hljs-keyword">String</span> lockKey,<span class="hljs-keyword">String</span> requestId,int expireTime)&#123;        //<span class="hljs-number">2</span>、加锁        <span class="hljs-keyword">String</span> result = jedis.<span class="hljs-keyword">set</span>(lockKey,requestId,<span class="hljs-string">&quot;NX&quot;</span>,<span class="hljs-string">&quot;EX&quot;</span>,expireTime);​        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(result);    &#125;​    /**     * 释放锁     * @param lockKey 锁的键值     * @param requestId 唯一标识     * @<span class="hljs-keyword">return</span> 成功<span class="hljs-keyword">true</span>，失败<span class="hljs-keyword">false</span>     */    public boolean unlock(<span class="hljs-keyword">String</span> lockKey,<span class="hljs-keyword">String</span> requestId)&#123;        //LUA脚本：判断当前锁的值是否等于请求标识requestId，如果是则删除锁并返回<span class="hljs-keyword">true</span>，反之返回<span class="hljs-keyword">false</span>。        <span class="hljs-keyword">String</span> scripts = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +                <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;        Object result = jedis.eval(scripts, Collections.singletonList(lockKey), Collections.singletonList(requestId));        <span class="hljs-keyword">return</span> Long.parseLong(result.toString())==<span class="hljs-number">1</span>L;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>存在的问题：</strong></p><blockquote><ul><li><strong>锁无法续期：</strong>假设线程A获取了锁，但是由于网络原因，执行时间超过了设置的过期时间，这是锁被释放了，线程B获取锁成功，此时线程A和B都会执行临界区的代码，这是绝对不允许的。</li></ul></blockquote><h2 id="二、Redisson实现分布式锁-1"><a href="#二、Redisson实现分布式锁-1" class="headerlink" title="二、Redisson实现分布式锁"></a>二、Redisson实现分布式锁</h2><p>在使用SETNX实现的分布式锁中，存在锁无法续期导致并发冲突的问题。不过这个问题在Redisson中用看门狗的机制巧妙地解决了，这也是我们实现分布式锁最常用的方式。</p><h3 id="2-1-整体类图-1"><a href="#2-1-整体类图-1" class="headerlink" title="2.1 整体类图"></a>2.1 整体类图</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2163205be5f25e23897ced4a05a14cb9.png"></p><p>标黄的两个类就是我们今天的重点，看门狗续期的实现逻辑在<strong>RedissionBaseLock类</strong>中，加锁逻辑在<strong>RedissionLock类</strong>中。</p><h3 id="2-2-大致流程-1"><a href="#2-2-大致流程-1" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3><p>在深入代码前，我们先看下加锁、看门狗续期大致的流程，有个大致印象。</p><p><img src="https://i-blog.csdnimg.cn/direct/47e9d6b55dd9448d8fe54d097e8bfbd3.png"></p><h3 id="2-3-加锁流程源码分析-1"><a href="#2-3-加锁流程源码分析-1" class="headerlink" title="2.3 加锁流程源码分析"></a>2.3 加锁流程源码分析</h3><p>下面我们就按上面的流程图，走走源码。</p><h4 id="2-3-1-lock-—加锁入口-1"><a href="#2-3-1-lock-—加锁入口-1" class="headerlink" title="2.3.1 lock()—加锁入口"></a>2.3.1 lock()—加锁入口</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c90322cb4a159b87fd04aca1081c2e2.png"></p><ul><li>lock方法，一个没设置过期时间，一个设置了过期时间。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/096f1c9bba501ea1e6b22b942c56c93f.png"></p><p>解析：</p><blockquote><ul><li>第一个红框：尝试加锁，会返回null或者具体的值，<strong>返回null表示加锁成功，反之有线程持有该锁，加锁失败。</strong></li><li>第二个红框：<strong>加锁失败，while循环不断尝试。</strong></li></ul></blockquote><h4 id="2-3-2-tryAcquire-—执行加锁LUA脚本并判断是否要进行锁续期-1"><a href="#2-3-2-tryAcquire-—执行加锁LUA脚本并判断是否要进行锁续期-1" class="headerlink" title="2.3.2 tryAcquire()—执行加锁LUA脚本并判断是否要进行锁续期"></a>2.3.2 tryAcquire()—执行加锁LUA脚本并判断是否要进行锁续期</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/17e3ff2ffae885cde2e3349b11819e08.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8ab1b8816bdb35dc5cd7918ee3e682dc.png"></p><blockquote><ul><li><p>第一个红框：执行加锁LUA脚本，返回null说明加锁成功，反之失败。</p><ul><li><p><strong>如果设置了过期时间，第二个参数就传设置的时间。</strong></p></li><li><p>反之，使用默认的<strong>internallockLeaseTime</strong>时间。</p></li></ul></li><li><p>第二个红框：如果加锁成功（null），且设置了过期时间，将设置过期时间赋值给internallockLeaseTime，如果没设置，则执行<strong>scheduleExpirationRenewal方法（看门狗）。</strong>返回结果。</p></li></ul></blockquote><p><strong>ps：internallockLeaseTime默认就是30s。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3776045e441c2b913a359ec9fbe4266d.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a0950ff3af7e06b77e31416b71c66999.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04323d9885389ecb586ed19b62ac751c.png"></p><h4 id="2-3-3-tryLockInnerAsync-—–选择slot槽并执行lua脚本-1"><a href="#2-3-3-tryLockInnerAsync-—–选择slot槽并执行lua脚本-1" class="headerlink" title="2.3.3 tryLockInnerAsync()—–选择slot槽并执行lua脚本"></a>2.3.3 tryLockInnerAsync()—–选择slot槽并执行lua脚本</h4><p>我们先看如何执行LUA加锁脚本的，这里面有点深。。。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/16032194b6c649b468f75692ef55f6b4.png"> <img src="https://i-blog.csdnimg.cn/blog_migrate/3aac08c39e8ead75464cc1c9aeb18fe7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cff71f24ba3ea06fa99bc94dc294f563.png"></p><p><strong>slot槽这里就不多讲了。。。我们回到LUA脚本。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aaa3bc287881377ff5ecdf9d7b7c1fdd.png"></p><blockquote><ul><li><strong>首先检查锁的key是否存在，如果不存在，判断是否是同一线程再次过来对同一个key进行加锁，也就是当前key是否被当前线程持有（可重入性）。</strong></li><li>如果上述两个条件任意一个成立，则对当前key执行自增和设置过期时间操作，并<strong>返回null表示加锁成功。</strong></li><li><strong>反之，返回当前锁的过期时间，表示加锁失败。</strong></li></ul></blockquote><h3 id="2-4-watch-dog源码分析-1"><a href="#2-4-watch-dog源码分析-1" class="headerlink" title="2.4 watch dog源码分析"></a>2.4 watch dog源码分析</h3><h4 id="2-4-1-scheduleExpirationRenewal-–锁续期入口-1"><a href="#2-4-1-scheduleExpirationRenewal-–锁续期入口-1" class="headerlink" title="2.4.1 scheduleExpirationRenewal()–锁续期入口"></a>2.4.1 scheduleExpirationRenewal()–锁续期入口</h4><p>当加锁成功，且没有设置过期时间，执行<strong>scheduleExpirationRenewal()方法</strong>，这也是我们常说的”看门狗”的实现逻辑。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/708d64a8687a87050b20fe1e5e88a36e.png"></p><blockquote><ul><li>第一个红框：EXPIRATION_RENEWAL_MAP存放续期任务，get有值说明当前锁需要续期，为null则不需要再续期了。</li><li>第二个红框，执行续期操作。</li></ul></blockquote><h4 id="2-4-2-renewExpiration-—-执行锁续期操作-1"><a href="#2-4-2-renewExpiration-—-执行锁续期操作-1" class="headerlink" title="2.4.2 renewExpiration()—-执行锁续期操作"></a>2.4.2 renewExpiration()—-执行锁续期操作</h4><p>这个方法用<strong>netty的时间轮</strong>进行续期。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/50ed4ade0574c203c1e118abc1920cfd.png"></p><blockquote><ul><li><p>第一个红框：首先会从<strong>EXPIRATION_RENEWAL_MAP</strong>中获取一个值，如果为null，就不续期了，<strong>说明这个锁可能已经被释放或过期了。</strong></p></li><li><p>第二个红框：基于TimerTask实现一个定时任务，设置<strong>internalLockLeaseTime &#x2F; 3</strong>的时长进行一次锁续期，也就是每10s进行一次续期。</p><ul><li><p>这里也会从<strong>EXPIRATION_RENEWAL_MAP</strong>里获取一个值，检查锁是否被释放。</p></li><li><p><strong>如果不为null，则获取第一个thread（也就是持有锁的线程），如果为null则说明锁也被释放了，此时也不需要续期。</strong></p></li><li><p>如果不为null，说明需要续期，它会异步调用<strong>renewExpirationAsync(threadId)方法</strong>来实现续期。</p></li><li><p>当异步续期操作完成，会调用whenComplete方法来处理结果，如果有异常，则将该锁从<strong>EXPIRATION_RENEWAL_MAP</strong>中移除。如果续期成功，则会重新调用<strong>renewExpiration()方法</strong>进行下一次续期，如果续期失败，则调用<strong>cancelExpirationRenewal()方法</strong>取消续期。</p></li></ul></li></ul></blockquote><h4 id="2-4-3-renewExpirationAsync-–执行锁续期LUA脚本-1"><a href="#2-4-3-renewExpirationAsync-–执行锁续期LUA脚本-1" class="headerlink" title="2.4.3 renewExpirationAsync()–执行锁续期LUA脚本"></a>2.4.3 renewExpirationAsync()–执行锁续期LUA脚本</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2bc37246d829ed6149898214984c7ab2.png"></p><blockquote><ul><li><strong>如果当前key存在，说明当前锁还被该线程持有，那么就重置过期时间为30s，并返回true，表示续期成功，反之返回false。</strong></li></ul></blockquote><h4 id="2-4-4-cancelExpirationRenewal—取消锁续期-1"><a href="#2-4-4-cancelExpirationRenewal—取消锁续期-1" class="headerlink" title="2.4.4 cancelExpirationRenewal—取消锁续期"></a>2.4.4 cancelExpirationRenewal—取消锁续期</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/70dd77797eb7311864199dbdc59537b6.png"></p><blockquote><ul><li>还是从这个map里获取键值对，如果为null，说明续期任务不存在，也没必要进行下去了，直接返回。</li><li>如果threadId不为null，直接将这个续期任务从task里移除。</li><li>如果threadId为null或者task中不再有任何线程在等待续期，此时就调用cancel方法来取消定时任务，然后在从<strong>EXPIRATION_RENEWAL_MAP</strong>中移除该续期任务。</li></ul></blockquote><p><strong>ps：当unlock的时候也会调该方法，来执行取消锁续期的操作。</strong></p><h3 id="2-5-小结-1"><a href="#2-5-小结-1" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><h4 id="2-5-1-什么时候会进行锁续期-1"><a href="#2-5-1-什么时候会进行锁续期-1" class="headerlink" title="2.5.1 什么时候会进行锁续期"></a>2.5.1 什么时候会进行锁续期</h4><blockquote><p>加锁时，如果没有指定过期时间，则默认过期时间为30s且每隔10s进行锁续期操作。</p><p><strong>ps：参考2.3.2和2.4.2小节。</strong></p></blockquote><h4 id="2-5-2-什么情况会停止续期-1"><a href="#2-5-2-什么情况会停止续期-1" class="headerlink" title="2.5.2 什么情况会停止续期"></a>2.5.2 什么情况会停止续期</h4><blockquote><ul><li><p>锁被释放。</p></li><li><p>续期时发生异常。</p></li><li><p>执行锁续期LUA脚本失败。</p></li><li><p>Redission的续期时Netty时间轮（TimerTask、TimeOut、Timer）的，并且操作都是基于JVM，所以当应用宕机、下线或重启后，续期任务也没有了。</p></li></ul><p><strong>ps：参考2.4.3小节。</strong></p></blockquote><h3 id="2-6-lock-和trylock-的区别-1"><a href="#2-6-lock-和trylock-的区别-1" class="headerlink" title="2.6 lock()和trylock()的区别"></a>2.6 lock()和trylock()的区别</h3><p>讲了半天忘了说使用redission实现分布式锁的示例了😂，索性就在这补充一下吧。</p><p><strong>lock()：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RLock lock = redisson.getLock(<span class="hljs-string">&quot;MyLock&quot;</span>);lock.lock();<span class="hljs-regexp">//</span>阻塞方法，知道获取到锁try &#123;    <span class="hljs-regexp">//</span>业务代码&#125;finally &#123;    <span class="hljs-regexp">//</span>当前锁存在且被当前线程持有     <span class="hljs-keyword">if</span>(lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread())&#123;      <span class="hljs-regexp">//</span>释放锁      lock.unlock();   &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>lock的原理是以阻塞的方式获取锁，如果获取失败则一直等待，直到获取成功。</p><p><strong>ps：可以参考2.3.1小节。</strong></p></blockquote><p><strong>trylock()：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RLock lock = redisson.getLock(<span class="hljs-string">&quot;MyLock&quot;</span>);boolean b = lock.tryLock();<span class="hljs-regexp">//</span>非阻塞方法，立即返回获取结果<span class="hljs-keyword">if</span>(b)&#123;     try &#123;          <span class="hljs-regexp">//</span>业务代码     &#125;finally &#123;          <span class="hljs-regexp">//</span>当前锁存在且被当前线程持有          <span class="hljs-keyword">if</span>(lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread())&#123;               <span class="hljs-regexp">//</span>释放锁               lock.unlock();           &#125;     &#125;&#125;<span class="hljs-keyword">else</span> &#123;   <span class="hljs-regexp">//</span>获取锁失败，处理逻辑&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c9d3a00e609d59fa4984a1f606e3953.png"></p><blockquote><p>tryLock是尝试获取锁，如果能获取直接返回true，如果无法获取，它会按照我们指定的超时时间进行阻塞，<strong>这个时间内还会尝试获取锁，如果超过这个时间还没获取到，直接返回false。</strong>如果没有指定超时时间，就如我们的示例，那获取不到的话直接就返回false。</p></blockquote><p><strong>我们看下源码：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bf0550041bf17578d7a01ed660437db.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9968619e85e7c4660cc7331cb48315d.png"></p><p><strong>这是没有指定超时时间执行的方法，方法名也很见名知意，就是尝试一次加锁。指定了超时时间的这里就不介绍了，无非是在超时时间内执行while循环尝试获取锁。</strong></p><h2 id="三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用-1"><a href="#三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用-1" class="headerlink" title="三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用"></a>三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用</h2><p><strong>ps：这几种锁都不常用，所以就不细讲了，知道有这个事就行。</strong></p><h3 id="3-1-公平锁（FairLock）-1"><a href="#3-1-公平锁（FairLock）-1" class="headerlink" title="3.1 公平锁（FairLock）"></a>3.1 公平锁（FairLock）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">RLock <span class="hljs-keyword">lock</span> = redisson.getFairLock(<span class="hljs-string">&quot;MyLock&quot;</span>);<span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br></code></pre></td></tr></table></figure><h3 id="3-2-联锁（MultiLock）-1"><a href="#3-2-联锁（MultiLock）-1" class="headerlink" title="3.2 联锁（MultiLock）"></a>3.2 联锁（MultiLock）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">RLock lock1 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock1&quot;</span>)</span>;RLock lock2 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock2&quot;</span>)</span>;RLock lock3 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock3&quot;</span>)</span>;RedissonMultiLock lock=<span class="hljs-keyword">new</span> <span class="hljs-constructor">RedissonMultiLock(<span class="hljs-params">lock1</span>,<span class="hljs-params">lock2</span>,<span class="hljs-params">lock3</span>)</span>;<span class="hljs-comment">//同时加锁lock1、lock2、lock3//所有的锁都上锁成功才算成功lock.lock(); //...lock.unlock();</span><br></code></pre></td></tr></table></figure><h3 id="3-3-读写锁-1"><a href="#3-3-读写锁-1" class="headerlink" title="3.3 读写锁"></a>3.3 读写锁</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">RReadWriteLock <span class="hljs-keyword">lock</span> = redisson.getReadWriteLock(&quot;myLock&quot;);//读锁<span class="hljs-keyword">lock</span>.readLock().<span class="hljs-keyword">lock</span>();//写锁<span class="hljs-keyword">lock</span>.writeLock().<span class="hljs-keyword">lock</span>();<br></code></pre></td></tr></table></figure><p><strong>ps：还有个RedLock，这个可以细讲一下，但是由于篇幅原因，就放在下一篇文章吧。</strong></p><h2 id="四、Redission实现分布式锁存在的问题-1"><a href="#四、Redission实现分布式锁存在的问题-1" class="headerlink" title="四、Redission实现分布式锁存在的问题"></a>四、Redission实现分布式锁存在的问题</h2><p>Redission使用看门狗续期的方案在大多数场景下是挺不错的，但在极端情况下还是会存在问题，比如：</p><blockquote><ul><li>线程1首先获取锁成功，将键值对写入redis的master节点。</li><li><strong>在redis将master数据同步到slave节点之前，master故障了。</strong></li><li>此时会触发故障转移，将其中一个slave升级为master。</li><li>但新的master并没有线程1写入的键值对，因此如果此时来个线程2，也同样可以获取到锁，这就违背了锁的初衷。</li></ul></blockquote><p>这个场景就是我们常说的<a href="https://blog.csdn.net/weixin_45433817/article/details/137209295?spm=1001.2014.3001.5501" title="集群脑裂">集群脑裂</a><strong>（网络分区）</strong>问题。</p><p>那么比较主流的解决方案就是<strong>Redis作者提出的Redlock</strong>和<strong>Zookeeper</strong>实现的分布式锁，这个我们下节再讲。</p><p><strong>End：希望对大家有所帮助，如果有纰漏或者更好的想法，请您一定不要吝啬你的赐教🙋。</strong>在<a href="https://so.csdn.net/so/search?q=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1001.2101.3001.7020">多线程</a>环境下，为了保证数据的线程安全，我们通常用加锁的方式，使同一时刻只有一个线程可以对这个共享资源进行操作，<strong>在单服务系统我们常用JVM锁——<a href="https://blog.csdn.net/weixin_45433817/article/details/132216383" title="Synchronized、ReentrantLock等">Synchronized、ReentrantLock等</a>。然而在多台服务系统的情况下，JVM锁就无法在多个服务器之间生效了，这时候我们就需要用分布式锁来解决线程安全的问题。</strong></p><p>分布式锁的实现方式有很多，主流的就是基于<strong>数据库、zookeeper以及redis</strong>，当然使用redis的居多，由于篇幅原因，本节就详细介绍一下使用redis实现分布式锁的几种方式。</p><h2 id="一、SETNX实现-2"><a href="#一、SETNX实现-2" class="headerlink" title="一、SETNX实现"></a>一、SETNX实现</h2><p><strong>ps：本文重点使Redisson实现分布式锁，咱就不从SETNX+EXPIRE、SETNX+LUA脚本…什么的逐步演进了，本身就是一回事，直接一步到位，用set ex px nx+唯一校验+LUA脚本删除等操作实现。</strong></p><p>利用<strong>Redis的单线程</strong>特性，在多个Redis客户端通过SETNX，如果返回1表示获取锁成功，反之失败。因为Redis的单线程机制，所以可以保证一个客户端成功获取后，其它客户端都会获取失败。伪代码如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">public class RedisLock &#123;    private Jedis jedis;    private void init()&#123;        //建立连接        jedis = JedisPoolFactory.getJedis();    &#125;    /**     * 获取锁     * @param lockKey 锁的键值     * @param requestId 唯一标识     * @param expireTime 过期时间     * @<span class="hljs-keyword">return</span> 是否获取锁 成功返回<span class="hljs-keyword">true</span>，反之<span class="hljs-keyword">false</span>     */    public boolean tryLock(<span class="hljs-keyword">String</span> lockKey,<span class="hljs-keyword">String</span> requestId,int expireTime)&#123;        //<span class="hljs-number">2</span>、加锁        <span class="hljs-keyword">String</span> result = jedis.<span class="hljs-keyword">set</span>(lockKey,requestId,<span class="hljs-string">&quot;NX&quot;</span>,<span class="hljs-string">&quot;EX&quot;</span>,expireTime);​        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(result);    &#125;​    /**     * 释放锁     * @param lockKey 锁的键值     * @param requestId 唯一标识     * @<span class="hljs-keyword">return</span> 成功<span class="hljs-keyword">true</span>，失败<span class="hljs-keyword">false</span>     */    public boolean unlock(<span class="hljs-keyword">String</span> lockKey,<span class="hljs-keyword">String</span> requestId)&#123;        //LUA脚本：判断当前锁的值是否等于请求标识requestId，如果是则删除锁并返回<span class="hljs-keyword">true</span>，反之返回<span class="hljs-keyword">false</span>。        <span class="hljs-keyword">String</span> scripts = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +                <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;        Object result = jedis.eval(scripts, Collections.singletonList(lockKey), Collections.singletonList(requestId));        <span class="hljs-keyword">return</span> Long.parseLong(result.toString())==<span class="hljs-number">1</span>L;    &#125;&#125;<br></code></pre></td></tr></table></figure><p><strong>存在的问题：</strong></p><blockquote><ul><li><strong>锁无法续期：</strong>假设线程A获取了锁，但是由于网络原因，执行时间超过了设置的过期时间，这是锁被释放了，线程B获取锁成功，此时线程A和B都会执行临界区的代码，这是绝对不允许的。</li></ul></blockquote><h2 id="二、Redisson实现分布式锁-2"><a href="#二、Redisson实现分布式锁-2" class="headerlink" title="二、Redisson实现分布式锁"></a>二、Redisson实现分布式锁</h2><p>在使用SETNX实现的分布式锁中，存在锁无法续期导致并发冲突的问题。不过这个问题在Redisson中用看门狗的机制巧妙地解决了，这也是我们实现分布式锁最常用的方式。</p><h3 id="2-1-整体类图-2"><a href="#2-1-整体类图-2" class="headerlink" title="2.1 整体类图"></a>2.1 整体类图</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2163205be5f25e23897ced4a05a14cb9.png"></p><p>标黄的两个类就是我们今天的重点，看门狗续期的实现逻辑在<strong>RedissionBaseLock类</strong>中，加锁逻辑在<strong>RedissionLock类</strong>中。</p><h3 id="2-2-大致流程-2"><a href="#2-2-大致流程-2" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3><p>在深入代码前，我们先看下加锁、看门狗续期大致的流程，有个大致印象。</p><p><img src="https://i-blog.csdnimg.cn/direct/47e9d6b55dd9448d8fe54d097e8bfbd3.png"></p><h3 id="2-3-加锁流程源码分析-2"><a href="#2-3-加锁流程源码分析-2" class="headerlink" title="2.3 加锁流程源码分析"></a>2.3 加锁流程源码分析</h3><p>下面我们就按上面的流程图，走走源码。</p><h4 id="2-3-1-lock-—加锁入口-2"><a href="#2-3-1-lock-—加锁入口-2" class="headerlink" title="2.3.1 lock()—加锁入口"></a>2.3.1 lock()—加锁入口</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c90322cb4a159b87fd04aca1081c2e2.png"></p><ul><li>lock方法，一个没设置过期时间，一个设置了过期时间。</li></ul><p><img src="https://i-blog.csdnimg.cn/blog_migrate/096f1c9bba501ea1e6b22b942c56c93f.png"></p><p>解析：</p><blockquote><ul><li>第一个红框：尝试加锁，会返回null或者具体的值，<strong>返回null表示加锁成功，反之有线程持有该锁，加锁失败。</strong></li><li>第二个红框：<strong>加锁失败，while循环不断尝试。</strong></li></ul></blockquote><h4 id="2-3-2-tryAcquire-—执行加锁LUA脚本并判断是否要进行锁续期-2"><a href="#2-3-2-tryAcquire-—执行加锁LUA脚本并判断是否要进行锁续期-2" class="headerlink" title="2.3.2 tryAcquire()—执行加锁LUA脚本并判断是否要进行锁续期"></a>2.3.2 tryAcquire()—执行加锁LUA脚本并判断是否要进行锁续期</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/17e3ff2ffae885cde2e3349b11819e08.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8ab1b8816bdb35dc5cd7918ee3e682dc.png"></p><blockquote><ul><li><p>第一个红框：执行加锁LUA脚本，返回null说明加锁成功，反之失败。</p><ul><li><p><strong>如果设置了过期时间，第二个参数就传设置的时间。</strong></p></li><li><p>反之，使用默认的<strong>internallockLeaseTime</strong>时间。</p></li></ul></li><li><p>第二个红框：如果加锁成功（null），且设置了过期时间，将设置过期时间赋值给internallockLeaseTime，如果没设置，则执行<strong>scheduleExpirationRenewal方法（看门狗）。</strong>返回结果。</p></li></ul></blockquote><p><strong>ps：internallockLeaseTime默认就是30s。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3776045e441c2b913a359ec9fbe4266d.png"><img src="https://i-blog.csdnimg.cn/blog_migrate/a0950ff3af7e06b77e31416b71c66999.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04323d9885389ecb586ed19b62ac751c.png"></p><h4 id="2-3-3-tryLockInnerAsync-—–选择slot槽并执行lua脚本-2"><a href="#2-3-3-tryLockInnerAsync-—–选择slot槽并执行lua脚本-2" class="headerlink" title="2.3.3 tryLockInnerAsync()—–选择slot槽并执行lua脚本"></a>2.3.3 tryLockInnerAsync()—–选择slot槽并执行lua脚本</h4><p>我们先看如何执行LUA加锁脚本的，这里面有点深。。。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/16032194b6c649b468f75692ef55f6b4.png"> <img src="https://i-blog.csdnimg.cn/blog_migrate/3aac08c39e8ead75464cc1c9aeb18fe7.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cff71f24ba3ea06fa99bc94dc294f563.png"></p><p><strong>slot槽这里就不多讲了。。。我们回到LUA脚本。</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aaa3bc287881377ff5ecdf9d7b7c1fdd.png"></p><blockquote><ul><li><strong>首先检查锁的key是否存在，如果不存在，判断是否是同一线程再次过来对同一个key进行加锁，也就是当前key是否被当前线程持有（可重入性）。</strong></li><li>如果上述两个条件任意一个成立，则对当前key执行自增和设置过期时间操作，并<strong>返回null表示加锁成功。</strong></li><li><strong>反之，返回当前锁的过期时间，表示加锁失败。</strong></li></ul></blockquote><h3 id="2-4-watch-dog源码分析-2"><a href="#2-4-watch-dog源码分析-2" class="headerlink" title="2.4 watch dog源码分析"></a>2.4 watch dog源码分析</h3><h4 id="2-4-1-scheduleExpirationRenewal-–锁续期入口-2"><a href="#2-4-1-scheduleExpirationRenewal-–锁续期入口-2" class="headerlink" title="2.4.1 scheduleExpirationRenewal()–锁续期入口"></a>2.4.1 scheduleExpirationRenewal()–锁续期入口</h4><p>当加锁成功，且没有设置过期时间，执行<strong>scheduleExpirationRenewal()方法</strong>，这也是我们常说的”看门狗”的实现逻辑。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/708d64a8687a87050b20fe1e5e88a36e.png"></p><blockquote><ul><li>第一个红框：EXPIRATION_RENEWAL_MAP存放续期任务，get有值说明当前锁需要续期，为null则不需要再续期了。</li><li>第二个红框，执行续期操作。</li></ul></blockquote><h4 id="2-4-2-renewExpiration-—-执行锁续期操作-2"><a href="#2-4-2-renewExpiration-—-执行锁续期操作-2" class="headerlink" title="2.4.2 renewExpiration()—-执行锁续期操作"></a>2.4.2 renewExpiration()—-执行锁续期操作</h4><p>这个方法用<strong>netty的时间轮</strong>进行续期。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/50ed4ade0574c203c1e118abc1920cfd.png"></p><blockquote><ul><li><p>第一个红框：首先会从<strong>EXPIRATION_RENEWAL_MAP</strong>中获取一个值，如果为null，就不续期了，<strong>说明这个锁可能已经被释放或过期了。</strong></p></li><li><p>第二个红框：基于TimerTask实现一个定时任务，设置<strong>internalLockLeaseTime &#x2F; 3</strong>的时长进行一次锁续期，也就是每10s进行一次续期。</p><ul><li><p>这里也会从<strong>EXPIRATION_RENEWAL_MAP</strong>里获取一个值，检查锁是否被释放。</p></li><li><p><strong>如果不为null，则获取第一个thread（也就是持有锁的线程），如果为null则说明锁也被释放了，此时也不需要续期。</strong></p></li><li><p>如果不为null，说明需要续期，它会异步调用<strong>renewExpirationAsync(threadId)方法</strong>来实现续期。</p></li><li><p>当异步续期操作完成，会调用whenComplete方法来处理结果，如果有异常，则将该锁从<strong>EXPIRATION_RENEWAL_MAP</strong>中移除。如果续期成功，则会重新调用<strong>renewExpiration()方法</strong>进行下一次续期，如果续期失败，则调用<strong>cancelExpirationRenewal()方法</strong>取消续期。</p></li></ul></li></ul></blockquote><h4 id="2-4-3-renewExpirationAsync-–执行锁续期LUA脚本-2"><a href="#2-4-3-renewExpirationAsync-–执行锁续期LUA脚本-2" class="headerlink" title="2.4.3 renewExpirationAsync()–执行锁续期LUA脚本"></a>2.4.3 renewExpirationAsync()–执行锁续期LUA脚本</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2bc37246d829ed6149898214984c7ab2.png"></p><blockquote><ul><li><strong>如果当前key存在，说明当前锁还被该线程持有，那么就重置过期时间为30s，并返回true，表示续期成功，反之返回false。</strong></li></ul></blockquote><h4 id="2-4-4-cancelExpirationRenewal—取消锁续期-2"><a href="#2-4-4-cancelExpirationRenewal—取消锁续期-2" class="headerlink" title="2.4.4 cancelExpirationRenewal—取消锁续期"></a>2.4.4 cancelExpirationRenewal—取消锁续期</h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/70dd77797eb7311864199dbdc59537b6.png"></p><blockquote><ul><li>还是从这个map里获取键值对，如果为null，说明续期任务不存在，也没必要进行下去了，直接返回。</li><li>如果threadId不为null，直接将这个续期任务从task里移除。</li><li>如果threadId为null或者task中不再有任何线程在等待续期，此时就调用cancel方法来取消定时任务，然后在从<strong>EXPIRATION_RENEWAL_MAP</strong>中移除该续期任务。</li></ul></blockquote><p><strong>ps：当unlock的时候也会调该方法，来执行取消锁续期的操作。</strong></p><h3 id="2-5-小结-2"><a href="#2-5-小结-2" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><h4 id="2-5-1-什么时候会进行锁续期-2"><a href="#2-5-1-什么时候会进行锁续期-2" class="headerlink" title="2.5.1 什么时候会进行锁续期"></a>2.5.1 什么时候会进行锁续期</h4><blockquote><p>加锁时，如果没有指定过期时间，则默认过期时间为30s且每隔10s进行锁续期操作。</p><p><strong>ps：参考2.3.2和2.4.2小节。</strong></p></blockquote><h4 id="2-5-2-什么情况会停止续期-2"><a href="#2-5-2-什么情况会停止续期-2" class="headerlink" title="2.5.2 什么情况会停止续期"></a>2.5.2 什么情况会停止续期</h4><blockquote><ul><li><p>锁被释放。</p></li><li><p>续期时发生异常。</p></li><li><p>执行锁续期LUA脚本失败。</p></li><li><p>Redission的续期时Netty时间轮（TimerTask、TimeOut、Timer）的，并且操作都是基于JVM，所以当应用宕机、下线或重启后，续期任务也没有了。</p></li></ul><p><strong>ps：参考2.4.3小节。</strong></p></blockquote><h3 id="2-6-lock-和trylock-的区别-2"><a href="#2-6-lock-和trylock-的区别-2" class="headerlink" title="2.6 lock()和trylock()的区别"></a>2.6 lock()和trylock()的区别</h3><p>讲了半天忘了说使用redission实现分布式锁的示例了😂，索性就在这补充一下吧。</p><p><strong>lock()：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RLock lock = redisson.getLock(<span class="hljs-string">&quot;MyLock&quot;</span>);lock.lock();<span class="hljs-regexp">//</span>阻塞方法，知道获取到锁try &#123;    <span class="hljs-regexp">//</span>业务代码&#125;finally &#123;    <span class="hljs-regexp">//</span>当前锁存在且被当前线程持有     <span class="hljs-keyword">if</span>(lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread())&#123;      <span class="hljs-regexp">//</span>释放锁      lock.unlock();   &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>lock的原理是以阻塞的方式获取锁，如果获取失败则一直等待，直到获取成功。</p><p><strong>ps：可以参考2.3.1小节。</strong></p></blockquote><p><strong>trylock()：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">RLock lock = redisson.getLock(<span class="hljs-string">&quot;MyLock&quot;</span>);boolean b = lock.tryLock();<span class="hljs-regexp">//</span>非阻塞方法，立即返回获取结果<span class="hljs-keyword">if</span>(b)&#123;     try &#123;          <span class="hljs-regexp">//</span>业务代码     &#125;finally &#123;          <span class="hljs-regexp">//</span>当前锁存在且被当前线程持有          <span class="hljs-keyword">if</span>(lock.isLocked() &amp;&amp; lock.isHeldByCurrentThread())&#123;               <span class="hljs-regexp">//</span>释放锁               lock.unlock();           &#125;     &#125;&#125;<span class="hljs-keyword">else</span> &#123;   <span class="hljs-regexp">//</span>获取锁失败，处理逻辑&#125;<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1c9d3a00e609d59fa4984a1f606e3953.png"></p><blockquote><p>tryLock是尝试获取锁，如果能获取直接返回true，如果无法获取，它会按照我们指定的超时时间进行阻塞，<strong>这个时间内还会尝试获取锁，如果超过这个时间还没获取到，直接返回false。</strong>如果没有指定超时时间，就如我们的示例，那获取不到的话直接就返回false。</p></blockquote><p><strong>我们看下源码：</strong></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5bf0550041bf17578d7a01ed660437db.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9968619e85e7c4660cc7331cb48315d.png"></p><p><strong>这是没有指定超时时间执行的方法，方法名也很见名知意，就是尝试一次加锁。指定了超时时间的这里就不介绍了，无非是在超时时间内执行while循环尝试获取锁。</strong></p><h2 id="三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用-2"><a href="#三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用-2" class="headerlink" title="三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用"></a>三、Redission公平锁（FairLock）、联锁（MultiLock）、读写锁的使用</h2><p><strong>ps：这几种锁都不常用，所以就不细讲了，知道有这个事就行。</strong></p><h3 id="3-1-公平锁（FairLock）-2"><a href="#3-1-公平锁（FairLock）-2" class="headerlink" title="3.1 公平锁（FairLock）"></a>3.1 公平锁（FairLock）</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">RLock <span class="hljs-keyword">lock</span> = redisson.getFairLock(<span class="hljs-string">&quot;MyLock&quot;</span>);<span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();<br></code></pre></td></tr></table></figure><h3 id="3-2-联锁（MultiLock）-2"><a href="#3-2-联锁（MultiLock）-2" class="headerlink" title="3.2 联锁（MultiLock）"></a>3.2 联锁（MultiLock）</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">RLock lock1 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock1&quot;</span>)</span>;RLock lock2 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock2&quot;</span>)</span>;RLock lock3 = redisson.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;MyLock3&quot;</span>)</span>;RedissonMultiLock lock=<span class="hljs-keyword">new</span> <span class="hljs-constructor">RedissonMultiLock(<span class="hljs-params">lock1</span>,<span class="hljs-params">lock2</span>,<span class="hljs-params">lock3</span>)</span>;<span class="hljs-comment">//同时加锁lock1、lock2、lock3//所有的锁都上锁成功才算成功lock.lock(); //...lock.unlock();</span><br></code></pre></td></tr></table></figure><h3 id="3-3-读写锁-2"><a href="#3-3-读写锁-2" class="headerlink" title="3.3 读写锁"></a>3.3 读写锁</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">RReadWriteLock <span class="hljs-keyword">lock</span> = redisson.getReadWriteLock(&quot;myLock&quot;);//读锁<span class="hljs-keyword">lock</span>.readLock().<span class="hljs-keyword">lock</span>();//写锁<span class="hljs-keyword">lock</span>.writeLock().<span class="hljs-keyword">lock</span>();<br></code></pre></td></tr></table></figure><p><strong>ps：还有个RedLock，这个可以细讲一下，但是由于篇幅原因，就放在下一篇文章吧。</strong></p><h2 id="四、Redission实现分布式锁存在的问题-2"><a href="#四、Redission实现分布式锁存在的问题-2" class="headerlink" title="四、Redission实现分布式锁存在的问题"></a>四、Redission实现分布式锁存在的问题</h2><p>Redission使用看门狗续期的方案在大多数场景下是挺不错的，但在极端情况下还是会存在问题，比如：</p><blockquote><ul><li>线程1首先获取锁成功，将键值对写入redis的master节点。</li><li><strong>在redis将master数据同步到slave节点之前，master故障了。</strong></li><li>此时会触发故障转移，将其中一个slave升级为master。</li><li>但新的master并没有线程1写入的键值对，因此如果此时来个线程2，也同样可以获取到锁，这就违背了锁的初衷。</li></ul></blockquote><p>这个场景就是我们常说的<a href="https://blog.csdn.net/weixin_45433817/article/details/137209295?spm=1001.2014.3001.5501" title="集群脑裂">集群脑裂</a><strong>（网络分区）</strong>问题。</p><p>那么比较主流的解决方案就是<strong>Redis作者提出的Redlock</strong>和<strong>Zookeeper</strong>实现的分布式锁，这个我们下节再讲。</p><p><strong>End：希望对大家有所帮助，如果有纰漏或者更好的想法，请您一定不要吝啬你的赐教🙋。</strong></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis分布式锁</title>
    <link href="/article/e2ee4148.html"/>
    <url>/article/e2ee4148.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />## 前言<p>本篇文章主要介绍基于Redis的<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E9%2594%2581&spm=1001.2101.3001.7020">分布式锁</a>实现到底是怎么一回事，其中参考了许多大佬写的文章，算是对分布式锁做一个总结</p><h2 id="分布式锁概览"><a href="#分布式锁概览" class="headerlink" title="分布式锁概览"></a>分布式锁概览</h2><p>在<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%25E5%25A4%259A%25E7%25BA%25BF%25E7%25A8%258B&spm=1001.2101.3001.7020">多线程</a>的环境下，为了保证一个代码块在同一时间只能由一个线程访问，Java中我们一般可以使用synchronized语法和ReetrantLock去保证，这实际上是本地锁的方式。但是现在公司都是流行<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84&zhida_source=entity">分布式架构</a>，在分布式环境下，如何保证不同节点的<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5&zhida_source=entity">线程同步</a>执行呢？</p><p>实际上，对于分布式场景，我们可以使用分布式锁，它是控制<a href="https://link.zhihu.com/?target=https://so.csdn.net/so/search?q=%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E7%25B3%25BB%25E7%25BB%259F&spm=1001.2101.3001.7020">分布式系统</a>之间<strong>互斥访问共享资源</strong>的一种方式。</p><p>比如说在一个分布式系统中，多台机器上部署了多个服务，当客户端一个用户发起一个数据插入请求时，如果没有<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9C%BA%E5%88%B6&zhida_source=entity">分布式锁机制</a>保证，那么那多台机器上的多个服务可能进行并发插入操作，导致数据重复插入，对于某些不允许有多余数据的业务来说，这就会造成问题。而分布式锁机制就是为了解决类似这类问题，保证多个服务之间互斥的访问共享资源，如果一个服务抢占了分布式锁，其他服务没获取到锁，就不进行后续操作。大致意思如下图所示（不一定准确）：</p><p><img src="https://pica.zhimg.com/v2-838464fda75a3639278415e05543602e_1440w.jpg"></p><h3 id="分布式锁的特点"><a href="#分布式锁的特点" class="headerlink" title="分布式锁的特点"></a>分布式锁的特点</h3><p>分布式锁一般有如下的特点：</p><ul><li>互斥性： 同一时刻只能有一个线程持有锁</li><li>可重入性： 同一节点上的同一个线程如果获取了锁之后能够再次获取锁</li><li>锁超时：和J.U.C中的锁一样支持锁超时，防止死锁</li><li>高性能和高可用： 加锁和解锁需要高效，同时也需要保证高可用，防止分布式锁失效</li><li>具备阻塞和<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%80%A7&zhida_source=entity">非阻塞性</a>：能够及时从阻塞状态中被唤醒</li></ul><h3 id="分布式锁的实现方式"><a href="#分布式锁的实现方式" class="headerlink" title="分布式锁的实现方式"></a>分布式锁的实现方式</h3><p>我们一般实现分布式锁有以下几种方式：</p><ul><li>基于数据库</li><li>基于Redis</li><li>基于zookeeper</li></ul><p>本篇文章主要介绍基于Redis如何实现分布式锁</p><h2 id="Redis的分布式锁实现"><a href="#Redis的分布式锁实现" class="headerlink" title="Redis的分布式锁实现"></a>Redis的分布式锁实现</h2><h3 id="1-利用setnx-expire命令-错误的做法"><a href="#1-利用setnx-expire命令-错误的做法" class="headerlink" title="1. 利用setnx+expire命令 (错误的做法)"></a>1. 利用setnx+expire命令 (错误的做法)</h3><p>Redis的SETNX命令，setnx key value，将key设置为value，当键不存在时，才能成功，若键存在，什么也不做，成功返回1，失败返回0 。 SETNX实际上就是SET IF NOT Exists的缩写</p><p>因为分布式锁还需要超时机制，所以我们利用<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=2&q=expire%E5%91%BD%E4%BB%A4&zhida_source=entity">expire命令</a>来设置，所以利用setnx+expire命令的核心代码如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>,<span class="hljs-built_in">String</span> requset,<span class="hljs-type">int</span> timeout) &#123;<br><br> Long result = jedis.<span class="hljs-property">setnx</span>(<span class="hljs-built_in">key</span>, requset);<br><br> <span class="hljs-comment">// result = 1时，设置成功，否则设置失败</span><br><br> <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1</span>L) &#123;<br><br> <span class="hljs-keyword">return</span> jedis.<span class="hljs-property">expire</span>(<span class="hljs-built_in">key</span>, timeout) == <span class="hljs-number">1</span>L;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>实际上上面的步骤是有问题的，setnx和expire是分开的两步操作，不具有原子性，如果执行完第一条指令应用异常或者重启了，锁将无法过期。</p><p>一种改善方案就是使用Lua脚本来保证<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=2&q=%E5%8E%9F%E5%AD%90%E6%80%A7&zhida_source=entity">原子性</a>（包含setnx和expire两条指令）</p><h3 id="2-使用Lua脚本（包含setnx和expire两条指令）"><a href="#2-使用Lua脚本（包含setnx和expire两条指令）" class="headerlink" title="2. 使用Lua脚本（包含setnx和expire两条指令）"></a>2. 使用Lua脚本（包含setnx和expire两条指令）</h3><p>代码如下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs processing"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock_with_lua</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-built_in">String</span> UniqueId, <span class="hljs-type">int</span> seconds) &#123;<br><br> <span class="hljs-built_in">String</span> lua_scripts = <span class="hljs-string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +<br><br> <span class="hljs-string">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;<br><br> List&lt;<span class="hljs-built_in">String</span>&gt; keys = <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;();<br><br> List&lt;<span class="hljs-built_in">String</span>&gt; values = <span class="hljs-keyword">new </span><span class="hljs-class title_">ArrayList</span>&lt;&gt;();<br><br>    keys.<span class="hljs-property">add</span>(<span class="hljs-built_in">key</span>);<br><br>    values.<span class="hljs-property">add</span>(UniqueId);<br><br>    values.<span class="hljs-property">add</span>(<span class="hljs-built_in">String</span>.<span class="hljs-property">valueOf</span>(seconds));<br><br> <span class="hljs-built_in">Object</span> result = jedis.<span class="hljs-property">eval</span>(lua_scripts, keys, values);<br><br> <span class="hljs-comment">//判断是否成功</span><br><br> <span class="hljs-keyword">return</span> result.<span class="hljs-property">equals</span>(<span class="hljs-number">1</span>L);<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-使用-set-key-value-EX-seconds-PX-milliseconds-NX-XX-命令-正确做法"><a href="#3-使用-set-key-value-EX-seconds-PX-milliseconds-NX-XX-命令-正确做法" class="headerlink" title="3. 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)"></a>3. 使用 set key value [EX seconds][PX milliseconds][NX|XX] 命令 (正确做法)</h3><p>Redis在 2.6.12 版本开始，为 SET 命令增加一系列选项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>SET key value<span class="hljs-selector-attr">[EX seconds]</span><span class="hljs-selector-attr">[PX milliseconds]</span><span class="hljs-selector-attr">[NX|XX]</span><br></code></pre></td></tr></table></figure><ul><li>EX seconds: 设定过期时间，单位为秒</li><li>PX milliseconds: 设定过期时间，单位为毫秒</li><li>NX: 仅当key不存在时设置值</li><li>XX: 仅当key存在时设置值</li></ul><p>set命令的nx选项，就等同于<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=setnx%E5%91%BD%E4%BB%A4&zhida_source=entity">setnx命令</a>，代码过程如下：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing"><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock_with_set</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">key</span>, <span class="hljs-built_in">String</span> UniqueId, <span class="hljs-type">int</span> seconds) &#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.<span class="hljs-property">equals</span>(jedis.<span class="hljs-property">set</span>(<span class="hljs-built_in">key</span>, UniqueId, <span class="hljs-string">&quot;NX&quot;</span>, <span class="hljs-string">&quot;EX&quot;</span>, seconds));<br><br>&#125;<br></code></pre></td></tr></table></figure><p>value必须要具有唯一性，我们可以用UUID来做，设置随机字符串保证唯一性，至于为什么要保证唯一性？假如value不是随机字符串，而是一个固定值，那么就可能存在下面的问题：</p><ul><li>1.客户端1获取锁成功</li><li>2.客户端1在某个操作上阻塞了太长时间</li><li>3.设置的key过期了，锁自动释放了</li><li>4.客户端2获取到了对应同一个资源的锁</li><li>5.客户端1从阻塞中恢复过来，因为value值一样，所以执行释放锁操作时就会释放掉客户端2持有的锁，这样就会造成问题</li></ul><p>所以通常来说，在释放锁时，我们需要对value进行验证</p><p>释放锁的实现</p><p>释放锁时需要验证value值，也就是说我们在获取锁的时候需要设置一个value，不能直接用del key这种粗暴的方式，因为直接del key任何客户端都可以进行解锁了，所以<strong>解锁时，我们需要判断锁是否是自己的，基于value值来判断</strong>，代码如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br>public boolean release<span class="hljs-constructor">Lock_with_lua(String <span class="hljs-params">key</span>,String <span class="hljs-params">value</span>)</span> &#123;<br><br> String luaScript = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +<br><br> <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;<br><br> return jedis.eval(luaScript, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>singleton<span class="hljs-constructor">List(<span class="hljs-params">key</span>)</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>singleton<span class="hljs-constructor">List(<span class="hljs-params">value</span>)</span>).equals(<span class="hljs-number">1L</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用Lua脚本的方式，尽量保证原子性。</p><p>使用 <code>set key value [EX seconds][PX milliseconds][NX|XX]</code> 命令 看上去很OK，实际上在<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=Redis%E9%9B%86%E7%BE%A4&zhida_source=entity">Redis集群</a>的时候也会出现问题，比如说A客户端在Redis的master节点上拿到了锁，但是这个加锁的key还没有同步到slave节点，master故障，发生故障转移，一个slave节点升级为<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=2&q=master%E8%8A%82%E7%82%B9&zhida_source=entity">master节点</a>，B客户端也可以获取同个key的锁，但客户端A也已经拿到锁了，这就导致多个客户端都拿到锁。</p><p>所以针对Redis集群这种情况，还有其他方案</p><h3 id="4-Redlock算法-与-Redisson-实现"><a href="#4-Redlock算法-与-Redisson-实现" class="headerlink" title="4. Redlock算法 与 Redisson 实现"></a>4. Redlock算法 与 Redisson 实现</h3><p>Redis作者 <a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=antirez&zhida_source=entity">antirez</a>基于分布式环境下提出了一种更高级的分布式锁的实现Redlock，原理如下：</p><blockquote><p>下面参考文章<a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s?__biz=MzU5ODUwNzY1Nw==&mid=2247484155&idx=1&sn=0c73f45f2f641ba0bf4399f57170ac9b&scene=21%23wechat_redirect">Redlock：Redis分布式锁最牛逼的实现</a> 和 <a href="https://link.zhihu.com/?target=https://redis.io/topics/distlock">redis.io&#x2F;topics&#x2F;dist…</a></p></blockquote><p>假设有5个独立的<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=Redis%E8%8A%82%E7%82%B9&zhida_source=entity">Redis节点</a>（**注意这里的节点可以是5个Redis单master实例，也可以是5个Redis Cluster集群，但并不是有5个主节点的<a href="https://zhida.zhihu.com/search?content_id=219936088&content_type=Article&match_order=1&q=cluster%E9%9B%86%E7%BE%A4&zhida_source=entity">cluster集群</a>**）：</p><ul><li>获取当前Unix时间，以毫秒为单位</li><li>依次尝试从5个实例，使用相同的key和具有唯一性的value(例如UUID)获取锁，当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应用小于锁的失效时间，例如你的锁自动失效时间为10s，则超时时间应该在5~50毫秒之间，这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁</li><li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间，当且仅当从大多数(N&#x2F;2+1，这里是3个节点)的Redis节点都取到锁，并且使用的时间小于锁失败时间时，锁才算获取成功。</li><li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）</li><li>如果某些原因，获取锁失败（没有在至少N&#x2F;2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）</li></ul><p>Redisson实现简单分布式锁</p><p>对于Java用户而言，我们经常使用Jedis，Jedis是Redis的Java客户端，除了Jedis之外，Redisson也是Java的客户端，Jedis是阻塞式I&#x2F;O，而Redisson底层使用Netty可以实现非阻塞I&#x2F;O，该客户端封装了锁的，继承了J.U.C的Lock接口，所以我们可以像使用ReentrantLock一样使用Redisson，具体使用过程如下。</p><ol><li>首先加入POM依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.10.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ol><li>使用Redisson，代码如下(与使用ReentrantLock类似）</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-comment">// 1. 配置文件</span><br><br>Config config = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Config()</span>;<br><br>config.use<span class="hljs-constructor">SingleServer()</span><br><br>        .set<span class="hljs-constructor">Address(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>)</span><br><br>        .set<span class="hljs-constructor">Password(RedisConfig.PASSWORD)</span><br><br>        .set<span class="hljs-constructor">Database(0)</span>;<br><br><span class="hljs-comment">//2. 构造RedissonClient</span><br><br>RedissonClient redissonClient = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Redisson</span>.</span></span>create(config);<br><br> <br><br><span class="hljs-comment">//3. 设置锁定资源名称</span><br><br>RLock lock = redissonClient.get<span class="hljs-constructor">Lock(<span class="hljs-string">&quot;redlock&quot;</span>)</span>;<br><br>lock.lock<span class="hljs-literal">()</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;获取锁成功，实现业务逻辑&quot;</span>);<br><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>sleep(<span class="hljs-number">10000</span>);<br><br>&#125; catch (InterruptedException e) &#123;<br><br>    e.print<span class="hljs-constructor">StackTrace()</span>;<br><br>&#125; finally &#123;<br><br> lock.unlock<span class="hljs-literal">()</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>关于Redlock算法的实现，在Redisson中我们可以使用RedissonRedLock来完成，具体使用细节可以参考大佬的文章： <a href="https://link.zhihu.com/?target=https://mp.weixin.qq.com/s/8uhYult2h_YUHT7q7YCKYQ">mp.weixin.qq.com&#x2F;s&#x2F;8uhYult2h…</a></p><h2 id="Redis实现的分布式锁轮子"><a href="#Redis实现的分布式锁轮子" class="headerlink" title="Redis实现的分布式锁轮子"></a>Redis实现的分布式锁轮子</h2><p>下面利用SpringBoot + Jedis + AOP的组合来实现一个简易的分布式锁。</p><h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h3><p>自定义一个注解，被注解的方法会执行获取分布式锁的逻辑</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><br><span class="hljs-variable">@Documented</span><br><br><span class="hljs-variable">@Inherited</span><br><br>public <span class="hljs-variable">@interface</span> RedisLock &#123;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 业务键</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">key</span>();<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 锁的过期秒数,默认是5秒</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">expire</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-number">5</span>;<br><br> <br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 尝试加锁，最多等待时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-selector-tag">long</span> <span class="hljs-selector-tag">waitTime</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">Long</span><span class="hljs-selector-class">.MIN_VALUE</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 锁的超时时间单位</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * @return</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-selector-tag">TimeUnit</span> <span class="hljs-selector-tag">timeUnit</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">TimeUnit</span><span class="hljs-selector-class">.SECONDS</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-AOP拦截器实现"><a href="#2-AOP拦截器实现" class="headerlink" title="2. AOP拦截器实现"></a>2. AOP拦截器实现</h3><p>在AOP中我们去执行获取分布式锁和释放分布式锁的逻辑，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Aspect</span><br><br><span class="hljs-meta">@Component</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockMethodAspect</span> &#123;<br><br> <span class="hljs-meta">@Autowired</span><br><br> <span class="hljs-keyword">private</span> RedisLockHelper redisLockHelper;<br><br> <span class="hljs-meta">@Autowired</span><br><br> <span class="hljs-keyword">private</span> JedisUtil jedisUtil;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(LockMethodAspect.class);<br><br> <br><br> <span class="hljs-meta">@Around(&quot;@annotation(com.redis.lock.annotation.RedisLock)&quot;)</span><br><br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> &#123;<br><br> <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> jedisUtil.getJedis();<br><br> <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) joinPoint.getSignature();<br><br> <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br><br> <br><br> <span class="hljs-type">RedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> method.getAnnotation(RedisLock.class);<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> redisLock.key();<br><br> <span class="hljs-keyword">try</span> &#123;<br><br> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">islock</span> <span class="hljs-operator">=</span> redisLockHelper.lock(jedis,key, value, redisLock.expire(), redisLock.timeUnit());<br><br>            logger.info(<span class="hljs-string">&quot;isLock : &#123;&#125;&quot;</span>,islock);<br><br> <span class="hljs-keyword">if</span> (!islock) &#123;<br><br>                logger.error(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br><br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;获取锁失败&quot;</span>);<br><br>            &#125;<br><br> <span class="hljs-keyword">try</span> &#123;<br><br> <span class="hljs-keyword">return</span> joinPoint.proceed();<br><br>            &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br><br> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;系统异常&quot;</span>);<br><br>            &#125;<br><br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br><br>            logger.info(<span class="hljs-string">&quot;释放锁&quot;</span>);<br><br>            redisLockHelper.unlock(jedis,key, value);<br><br>            jedis.close();<br><br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br> <br></code></pre></td></tr></table></figure><h3 id="3-Redis实现分布式锁核心类"><a href="#3-Redis实现分布式锁核心类" class="headerlink" title="3. Redis实现分布式锁核心类"></a>3. Redis实现分布式锁核心类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Component</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLockHelper</span> &#123;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">sleepTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 直接使用setnx + expire方式获取分布式锁</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 非原子性</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lock_setnx</span><span class="hljs-params">(Jedis jedis,String key, String value, <span class="hljs-type">int</span> timeout)</span> &#123;<br><br> <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.setnx(key, value);<br><br> <span class="hljs-comment">// result = 1时，设置成功，否则设置失败</span><br><br> <span class="hljs-keyword">if</span> (result == <span class="hljs-number">1L</span>) &#123;<br><br> <span class="hljs-keyword">return</span> jedis.expire(key, timeout) == <span class="hljs-number">1L</span>;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>    &#125;<br><br> <br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 使用Lua脚本，脚本中使用setnex+expire命令进行加锁操作</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> UniqueId</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> seconds</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">Lock_with_lua</span><span class="hljs-params">(Jedis jedis,String key, String UniqueId, <span class="hljs-type">int</span> seconds)</span> &#123;<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">lua_scripts</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;setnx&#x27;,KEYS[1],ARGV[1]) == 1 then&quot;</span> +<br><br> <span class="hljs-string">&quot;redis.call(&#x27;expire&#x27;,KEYS[1],ARGV[2]) return 1 else return 0 end&quot;</span>;<br><br>        List&lt;String&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        List&lt;String&gt; values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        keys.add(key);<br><br>        values.add(UniqueId);<br><br>        values.add(String.valueOf(seconds));<br><br> <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.eval(lua_scripts, keys, values);<br><br> <span class="hljs-comment">//判断是否成功</span><br><br> <span class="hljs-keyword">return</span> result.equals(<span class="hljs-number">1L</span>);<br><br>    &#125;<br><br> <br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 在Redis的2.6.12及以后中,使用 set key value [NX] [EX] 命令</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lock</span><span class="hljs-params">(Jedis jedis,String key, String value, <span class="hljs-type">int</span> timeout, TimeUnit timeUnit)</span> &#123;<br><br> <span class="hljs-type">long</span> <span class="hljs-variable">seconds</span> <span class="hljs-operator">=</span> timeUnit.toSeconds(timeout);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;OK&quot;</span>.equals(jedis.set(key, value, <span class="hljs-string">&quot;NX&quot;</span>, <span class="hljs-string">&quot;EX&quot;</span>, seconds));<br><br>    &#125;<br><br> <br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 自定义获取锁的超时时间</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> waitTime</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeUnit</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lock_with_waitTime</span><span class="hljs-params">(Jedis jedis,String key, String value, <span class="hljs-type">int</span> timeout, <span class="hljs-type">long</span> waitTime,TimeUnit timeUnit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br> <span class="hljs-type">long</span> <span class="hljs-variable">seconds</span> <span class="hljs-operator">=</span> timeUnit.toSeconds(timeout);<br><br> <span class="hljs-keyword">while</span> (waitTime &gt;= <span class="hljs-number">0</span>) &#123;<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(key, value, <span class="hljs-string">&quot;nx&quot;</span>, <span class="hljs-string">&quot;ex&quot;</span>, seconds);<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;OK&quot;</span>.equals(result)) &#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>            &#125;<br><br>            waitTime -= sleepTime;<br><br>            Thread.sleep(sleepTime);<br><br>        &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 错误的解锁方法—直接删除key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock_with_del</span><span class="hljs-params">(Jedis jedis,String key)</span> &#123;<br><br>        jedis.del(key);<br><br>    &#125;<br><br> <br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * 使用Lua脚本进行解锁操纵，解锁的时候验证value值</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> jedis</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br><br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(Jedis jedis,String key,String value)</span> &#123;<br><br> <span class="hljs-type">String</span> <span class="hljs-variable">luaScript</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1] then &quot;</span> +<br><br> <span class="hljs-string">&quot;return redis.call(&#x27;del&#x27;,KEYS[1]) else return 0 end&quot;</span>;<br><br> <span class="hljs-keyword">return</span> jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(value)).equals(<span class="hljs-number">1L</span>);<br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Controller层控制"><a href="#4-Controller层控制" class="headerlink" title="4. Controller层控制"></a>4. Controller层控制</h3><p>定义一个TestController来测试我们实现的分布式锁</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br><span class="hljs-meta">@RestController</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br> <span class="hljs-meta">@RedisLock(key = <span class="hljs-string">&quot;redis_lock&quot;</span>)</span><br><br> <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/index&quot;</span>)</span><br><br> <span class="hljs-keyword">public</span> String index() &#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br><br>    &#125;<br><br>&#125;<br><br> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring中的order</title>
    <link href="/article/402be486.html"/>
    <url>/article/402be486.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />让我来解释一下Spring中的order排序规则:<ol><li>基本原则:</li></ol><ul><li>order值越小,优先级越高</li><li>默认情况下order值为0</li><li>order可以是负数,正数或0</li></ul><ol start="2"><li>常见使用场景:</li></ol><p><code>// AOP切面排序 @Order(1)   @Aspect public class LogAspect &#123;     //... &#125;  @Order(2) @Aspect  public class SecurityAspect &#123;     //... &#125;  // Filter过滤器排序 @Order(1) public class AuthenticationFilter implements Filter &#123;     //... &#125;  // 事件监听器排序 @Order(1) public class EmailListener implements ApplicationListener&lt;OrderEvent&gt; &#123;     //... &#125;</code></p><ol start="3"><li>排序规则:</li></ol><ul><li>相同类型的组件按order值从小到大排序</li><li>order值相同时,按照类名的字母顺序排序</li><li>没有指定order的默认值为最低优先级(Ordered.LOWEST_PRECEDENCE)</li></ul><ol start="4"><li>实现方式:</li></ol><ul><li>使用@Order注解</li><li>实现Ordered接口</li><li>实现PriorityOrdered接口(优先级高于普通Ordered)</li></ul><ol start="5"><li>注意事项:</li></ol><ul><li>@Order对@Autowired注入的依赖顺序无效</li><li>要对@Autowired注入排序,需要使用@OrderBy注解</li><li>PriorityOrdered接口的优先级高于@Order注解</li></ul><p>所以简单总结:order值越小 &#x3D; 优先级越高 &#x3D; 越先执行。通过合理设置order值,我们可以控制Spring组件的执行顺序。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 配置 github 用户名密码</title>
    <link href="/article/ff88336e.html"/>
    <url>/article/ff88336e.html</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td># 配置用户名密码</td></tr><tr><td></td><td>git config –global user.name username</td></tr><tr><td></td><td># 使用 token</td></tr><tr><td></td><td>git config –global user.password token</td></tr><tr><td></td><td>git config –global user.email “email”</td></tr><tr><td></td><td></td></tr><tr><td></td><td># 输入的用户名密码将被记住，不用每次都输入了</td></tr><tr><td></td><td>git config –global credential.helper store</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两个仓库之间如何同步代码</title>
    <link href="/article/ccabb2b0.html"/>
    <url>/article/ccabb2b0.html</url>
    
    <content type="html"><![CDATA[<p>#拉取Fork出来的分支 <!-- toc --></p><meta name="referrer" content="no-referrer" />git clone Fork的分支url #注意：进入项目根目录，执行下面操作 #查看所有远程库(remote repo)的远程url git remote -v #添加源分支url git remote add upstream 替换成源项目url #查看所有远程库(remote repo)的远程url git remote -v #从源分支获取最新的代码 git fetch upstream #切换到主分支 git checkout master #合并本地分支和源分支,本地库和远程的github原仓库同步 git merge upstream/master #push到fork分支,本地的仓库提交到github git push origin master]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> 一文解读exports、module.exports 和 export、export default</title>
    <link href="/article/9fd4703c.html"/>
    <url>/article/9fd4703c.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />### 第一部分：exports 和 [module](https://so.csdn.net/so/search?q=module&spm=1001.2101.3001.7020 "module").exports<p>为了让<a href="https://so.csdn.net/so/search?q=Node&spm=1001.2101.3001.7020" title="Node">Node</a>.js的文件可以相互调用，Node.js提供了一个简单的模块系统。模块是Node.js 应用程序的基本<a href="https://so.csdn.net/so/search?q=%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86&spm=1001.2101.3001.7020">组成部分</a>，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C&#x2F;C++ 扩展。</p><h4 id="1-exports"><a href="#1-exports" class="headerlink" title="1. exports"></a>1. exports</h4><h5 id="1-1-导出模块"><a href="#1-1-导出模块" class="headerlink" title="1.1 导出模块"></a>1.1 导出模块</h5><p>exports 对象是由模块系统创建的。在我们自己写模块的时候，需要在模块最后写好模块接口，声明这个模块对外暴露什么内容，exports 提供了暴露接口的方法。如下代码示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>hello.jsvar sayHello = <span class="hljs-keyword">function</span> () &#123;    console.log(<span class="hljs-string">&#x27;hello&#x27;</span>)&#125;var sos = <span class="hljs-number">110</span>;var app = &#123;    name: <span class="hljs-string">&#x27;testApp&#x27;</span>,    version: <span class="hljs-string">&#x27;1.0.0&#x27;</span>,    help: <span class="hljs-keyword">function</span> () &#123;        console.log(<span class="hljs-string">&#x27;what can i do for you?&#x27;</span>)    &#125;&#125;<span class="hljs-regexp">//</span>导出一个方法exports.sayHello = sayHello;<span class="hljs-regexp">//</span>导出一个变量exports.sos = sos;<span class="hljs-regexp">//</span>导出一个JSON对象exports.app = app;<br></code></pre></td></tr></table></figure><p>或者写成下面的形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">//hello.jsexports.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)&#125;exports.sos = <span class="hljs-number">110</span>;exports.app = &#123;    name: <span class="hljs-string">&#x27;testApp&#x27;</span>,    version: <span class="hljs-string">&#x27;1.0.0&#x27;</span>,    help: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;what can i do for you?&#x27;</span>)    &#125;&#125;<br></code></pre></td></tr></table></figure><p>在以上示例中，hello.js 通过 exports 对象把 sayHello 作为模块的访问接口，在其他模块（或js文件）中通过 require(’.&#x2F;hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员<a href="https://marketing.csdn.net/p/3127db09a98e0723b83b2914d9256174?pId=2782&utm_source=glcblog&spm=1001.2101.3001.7020">函数</a>了。</p><h5 id="1-2-引入模块"><a href="#1-2-引入模块" class="headerlink" title="1.2 引入模块"></a>1.2 引入模块</h5><p>在 Node.js 中，引入一个模块非常简单，如下我们创建一个 main.js 文件并引入 hello 模块，代码如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//m</span>ain.jsvar hello = require(<span class="hljs-string">&#x27;./hello&#x27;</span>);<span class="hljs-regexp">//</span>调用模块hello中的方法hello.sayHello();<span class="hljs-regexp">//</span>调用模块hello中的变量console.log(hello.sos)console.log(hello.app.version)<span class="hljs-regexp">//</span>调用模块hello中的JSON对象属性hello.app.help()<br></code></pre></td></tr></table></figure><p>执行命令（node main.js）运行main.js，结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hello1101</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>what can i do for you?<br></code></pre></td></tr></table></figure><p>以上实例中，代码 require(’.&#x2F;hello’) 引入了当前目录下的 hello.js 文件（.&#x2F; 为当前目录，node.js 默认后缀为 js）。</p><p>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p><h4 id="2-module-exports"><a href="#2-module-exports" class="headerlink" title="2. module.exports"></a>2. module.exports</h4><h5 id="2-1-导出模块"><a href="#2-1-导出模块" class="headerlink" title="2.1 导出模块"></a>2.1 导出模块</h5><p>有时候我们希望把一个对象封装到模块中，格式如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//hello.js <span class="hljs-keyword">function</span> Hello() &#123;    var <span class="hljs-type">name</span>;    var sos = <span class="hljs-string">&#x27;110&#x27;</span>;    this.setName = <span class="hljs-keyword">function</span> (thyName) &#123;        <span class="hljs-type">name</span> = thyName;    &#125;;    this.sayHello = <span class="hljs-keyword">function</span> () &#123;        console.log(<span class="hljs-string">&#x27;Hello &#x27;</span> + <span class="hljs-type">name</span>);    &#125;;    this.app = &#123;        <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;testApp&#x27;</span>,        <span class="hljs-keyword">version</span>: <span class="hljs-string">&#x27;1.0.0&#x27;</span>,        help: <span class="hljs-keyword">function</span> () &#123;            console.log(<span class="hljs-string">&#x27;what can i do for you?&#x27;</span>)        &#125;    &#125;;&#125;;// 把变量、方法、<span class="hljs-type">JSON</span>对象等封装在一起，一并导出module.exports = Hello;<br></code></pre></td></tr></table></figure><h5 id="2-2-引入模块"><a href="#2-2-引入模块" class="headerlink" title="2.2 引入模块"></a>2.2 引入模块</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//m</span>ain.jsvar Hello = require(<span class="hljs-string">&#x27;./hello&#x27;</span>)<span class="hljs-regexp">//</span>通过new关键字，实例化一个hello模块的对象，通过这个对象才能调用hello模块相关的方法。hello = new Hello(); hello.setName(<span class="hljs-string">&quot;zhangSan&quot;</span>)hello.sayHello() console.log(hello.app.version)hello.app.help()<br></code></pre></td></tr></table></figure><p>执行命令，运行main.js，结果如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Hello</span> zhangSan1.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>what can i do for you?<br></code></pre></td></tr></table></figure><h4 id="3-exports-和-module-exports-的区别是什么？"><a href="#3-exports-和-module-exports-的区别是什么？" class="headerlink" title="3. exports 和 module.exports 的区别是什么？"></a>3. exports 和 module.exports 的区别是什么？</h4><p>上面两节的内容可以知道：相较于 exports，模块接口的唯一变化是使用 module.exports &#x3D; Hello 代替了exports.sayHello &#x3D; function(){}，exports.sos，exports.app。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p><p>为了直观地展现两者的异同点，我们先来看两个实例：</p><h5 id="3-1-exports-模式下两者的异同"><a href="#3-1-exports-模式下两者的异同" class="headerlink" title="3.1 exports 模式下两者的异同"></a>3.1 exports 模式下两者的异同</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">//hello.jsvar sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;    console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)&#125;var sos = <span class="hljs-number">110</span>;var app = &#123;    name: <span class="hljs-string">&#x27;testApp&#x27;</span>,    version: <span class="hljs-string">&#x27;1.0.0&#x27;</span>,    help: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;what can i do for you?&#x27;</span>)    &#125;&#125;exports.sayHello = sayHello;exports.sos = sos;exports.app = app;//打印exports和<span class="hljs-built_in">module</span>.exports的内容console.<span class="hljs-built_in">log</span>(exports);console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">module</span>.exports);console.<span class="hljs-built_in">log</span>(exports === <span class="hljs-built_in">module</span>.exports);<br></code></pre></td></tr></table></figure><p>运行如下 main.js 代码：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//m</span>ain.jsvar Hello = require(<span class="hljs-string">&#x27;./exports_mode&#x27;</span>) Hello.sayHello()<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml">&#123;  <span class="hljs-attr">sayHello:</span> [<span class="hljs-attr">Function:</span> <span class="hljs-string">sayHello</span>],  <span class="hljs-attr">sos:</span> <span class="hljs-number">110</span>,  <span class="hljs-attr">app:</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;testApp&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;1.0.0&#x27;</span>, <span class="hljs-attr">help:</span> [<span class="hljs-attr">Function:</span> <span class="hljs-string">help</span>] &#125;&#125;&#123;  <span class="hljs-attr">sayHello:</span> [<span class="hljs-attr">Function:</span> <span class="hljs-string">sayHello</span>],  <span class="hljs-attr">sos:</span> <span class="hljs-number">110</span>,  <span class="hljs-attr">app:</span> &#123; <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;testApp&#x27;</span>, <span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;1.0.0&#x27;</span>, <span class="hljs-attr">help:</span> [<span class="hljs-attr">Function:</span> <span class="hljs-string">help</span>] &#125;&#125;<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>很明显！！！ exports 和 module.exports 的内容是完全一样的，换言之：exports 指向的是 module.exports。</p></blockquote><h5 id="3-2-module-exports-模式下两者的异同"><a href="#3-2-module-exports-模式下两者的异同" class="headerlink" title="3.2 module.exports 模式下两者的异同"></a>3.2 module.exports 模式下两者的异同</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">//hello.jsfunction Hello() &#123;    var name;    this.setName = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(thyName)</span></span> &#123;        name = thyName;    &#125;;    this.sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;        console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name);    &#125;;    this.app = &#123;        name: <span class="hljs-string">&#x27;testApp&#x27;</span>,        version: <span class="hljs-string">&#x27;1.0.0&#x27;</span>,        help: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span></span> &#123;            console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;what can i do for you?&#x27;</span>)        &#125;    &#125;;&#125;; // 把变量、方法、JSON对象等封装在一起，一并导出<span class="hljs-built_in">module</span>.exports = Hello;//打印exports和<span class="hljs-built_in">module</span>.exports的内容console.<span class="hljs-built_in">log</span>(exports);console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">module</span>.exports);console.<span class="hljs-built_in">log</span>(exports === <span class="hljs-built_in">module</span>.exports);<br></code></pre></td></tr></table></figure><p>运行main.js如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> Hello = require(<span class="hljs-string">&#x27;./exports_mode&#x27;</span>)hello = <span class="hljs-keyword">new</span> <span class="hljs-type">Hello</span>(); hello.setName(<span class="hljs-string">&quot;zhangSan&quot;</span>)hello.sayHello()<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">&#123;&#125;[<span class="hljs-keyword">Function</span>: Hello]falseHello zhangSan<br></code></pre></td></tr></table></figure><blockquote><p>很明显！！！module.exports 模式下，module.exports 和 exports 的内容是完全不同的，module.exports 导出的是模块（hello.js）对象本身（类别Java，可以理解为导出的是一个类，而不是实例化的对象），在此场景下 exports 是空的（类比Java，理解为一个空对象，没有实例化就是null）。</p></blockquote><h5 id="3-3-小结"><a href="#3-3-小结" class="headerlink" title="3.3 小结"></a>3.3 小结</h5><p>基于上面的实例，我们可以看到，输出的 module.exports 对象内容就是一个[Function]，在 javascript 里面是一个类。使用这种方式的好处是： exports 只能对外暴露单个函数，但是 module.exports 却能暴露一个类。</p><h3 id="第二部分：export-和-export-default"><a href="#第二部分：export-和-export-default" class="headerlink" title="第二部分：export 和 export default"></a>第二部分：export 和 export default</h3><p>exports 和 module.exports 是Node.js的模块系统关键字，而 export 和 export default 则是 ES6模块系统的关键字。很明显，两者属于两个体系：</p><blockquote><blockquote><p>require: node 和 es6 都支持的引入<br>export &#x2F; import : 只有es6 支持的导出引入<br>module.exports &#x2F; exports: 只有 node 支持的导出</p></blockquote></blockquote><h4 id="1-export"><a href="#1-export" class="headerlink" title="1.export"></a>1.export</h4><p>export 用于对外输出本模块（一个文件可以理解为一个模块）变量的接口，import 用于在一个模块中加载另一个含有export接口的模块。也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。这几个都是ES6的语法。</p><p>示例1：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">//app.jsexport var name<span class="hljs-operator">=</span><span class="hljs-string">&quot;ZhangSan&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>app.jsvar name1=<span class="hljs-string">&quot;ZhangSan&quot;</span>;var name2=<span class="hljs-string">&quot;LiSi&quot;</span>;export &#123; name1 ,name2 &#125;<br></code></pre></td></tr></table></figure><h4 id="2-import"><a href="#2-import" class="headerlink" title="2.import"></a>2.import</h4><p>import 用于在一个模块中加载另一个含有export接口的模块。具体见下面的示例。</p><p>对于上面的 示例1，引入方式为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//m</span>ain.jsimport &#123; name &#125; from <span class="hljs-string">&quot;./app.js&quot;</span> <span class="hljs-regexp">//</span>路径根据实际情况填写<br></code></pre></td></tr></table></figure><p>对于上面的 示例2，引入方式为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//m</span>ain.jsimport &#123; name1 , name2 &#125; from <span class="hljs-string">&quot;./app.js&quot;</span> <span class="hljs-regexp">//</span>路径根据实际情况填写<br></code></pre></td></tr></table></figure><h4 id="3-export-和-export-default"><a href="#3-export-和-export-default" class="headerlink" title="3.export 和 export default"></a>3.export 和 export default</h4><p>通过上面这几个例子，读者一定了解了如何使用export，import，如果还是不懂可以自己动手试一试。上面讲的是export和import，但是export跟export default 有什么区别呢？如下：</p><p>export与export default均可用于导出常量、函数、文件、模块等；<br>你可以在其它文件或模块中通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入，以便能够对其进行使用；<br>在一个文件或模块中，export、import可以有多个，export default仅有一个；<br>通过export方式导出，在导入时要加{ }，export default则不需要<br>实际上，很多时候export与export default可以实现同样的目的，只是用法有些区别。注意第4条，通过export方式导出，在导入时要加{ }，export default则不需要。使用export default命令，为模块指定默认输出，这样就不需要知道所要加载模块的变量名。</p><h3 id="第三部分：CommonJS-和-ES6"><a href="#第三部分：CommonJS-和-ES6" class="headerlink" title="第三部分：CommonJS 和 ES6"></a>第三部分：CommonJS 和 ES6</h3><h4 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1. CommonJS"></a>1. CommonJS</h4><p>Node里面的模块系统遵循的是CommonJS规范。那问题又来了，什么是CommonJS规范呢？由于js以前比较混乱，各写各的代码，没有一个模块的概念，而这个规范出来其实就是对模块的一个定义。</p><p>CommonJS定义的模块分为:</p><blockquote><blockquote><p>模块标识(module)、模块定义(exports) 、模块引用(require)</p></blockquote></blockquote><h5 id="1-1-exports-和-module-exports"><a href="#1-1-exports-和-module-exports" class="headerlink" title="1.1 exports 和 module.exports"></a>1.1 exports 和 module.exports</h5><p>在一个node执行一个文件时，会给这个文件内生成一个 exports和module对象，而module又有一个exports属性。他们之间的关系如下图，都指向一块{}内存区域。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">exports</span> <span class="hljs-operator">=</span> module.exports <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/direct/62ec231d5f74446cb4347dfd6ca596a7.png"> </p><p>实际上，require导出的内容是module.exports的指向的内存块内容，并不是exports的。简而言之，区分他们之间的区别就是 exports 只是 module.exports的引用，辅助后者添加内容用的。</p><h5 id="1-2-注意事项"><a href="#1-2-注意事项" class="headerlink" title="1.2 注意事项"></a>1.2 注意事项</h5><p>在实际应用中，为了避免糊涂，尽量都用 module.exports 导出，然后用require导入。</p><h4 id="2-ES6"><a href="#2-ES6" class="headerlink" title="2. ES6"></a>2. ES6</h4><p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p><p>在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。</p><blockquote><p>ES6 的模块化分为导出（export） 与导入（import）两个模块。</p></blockquote><h5 id="2-1-ES6-的特点"><a href="#2-1-ES6-的特点" class="headerlink" title="2.1 ES6 的特点"></a>2.1 ES6 的特点</h5><ul><li>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 use strict;</li><li>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</li><li>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</li><li>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</li></ul><h5 id="2-2-基本用法"><a href="#2-2-基本用法" class="headerlink" title="2.2 基本用法"></a>2.2 基本用法</h5><ul><li>模块导入导出各种类型的变量，如字符串，数值，函数，类。</li><li>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。</li><li>不仅能导出声明还能导出引用（例如函数）。</li><li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</li><li>import 命令会提升到整个模块的头部，首先执行。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你听我说我的烦恼</title>
    <link href="/article/b3200b03.html"/>
    <url>/article/b3200b03.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />1. 一年又快到头了，今年添了宝宝感觉时间过得更快了。不知道说些啥，随便说吧。  2. 销售篇：20年买了房，买房时，我表姐说有个熟人邻居在地产公司，然后当时去看了现房，当时说的有个98平具体楼层记不清了，还有个16小高 顶楼128，还有个144，去看房时下雨天，销售说98的刚定出去，（后来想想有可能是个坑，想卖大户型），就去看了128的，房子方正，当时也没想着去楼顶看看。144的独立电梯，户型比128多个房间，忘了去没去看了。然后去另外一个楼盘看了，期房，30多层，只有28层了，去了另外一个楼盘，期房，房型也很多，当时算了算首付啥的订了128平，记得交首付好像销售又说了啥，很匆忙的交了，具体也记不清了，感觉也是有坑。当时自己打车去的，销售还给报销了打车费，第一次知道45w原来那么重。  3. 装修篇：之后就是装修，当时找了业之峰，城市人家，还白嫖了人家赠品，后来觉得报价高，楼下有那种私人装修的拉活，看了看他们装修的几家，还算可以就订了。装修过程比较顺利，装修完之后两个月，租的房子正好到期就住进去了。当时装修的带客户去我们家参观时，人家一个人说，这个房顶怎么不平啊，当时没在意，后来想想应该是漆面没刷平，然后主卧的墙上有天出了一道裂纹找了装修他们说这是施工洞，说这是开发商责任，就找了开发商，来了个工人说要修复就只能铲了墙皮，重新挂网，当时因为自己一个人或者懒，也没有管。  4. 开发商篇：住了大约半年后，发现阳台上角上有点阴水，找了物业，物业找了开发商，当时说是我们自己封窗户时，没打胶，雨水浸进来的，找了封窗户的重新打了胶，到了第二年发现还是有，只要下大雨就会阴，说是外面雨水漏斗溅水导致的，先给把漏斗提高了一下，雨水不乱浸，也没啥效果，就把漏斗去了，换成直接的了，雨季也过去了，到了第三年，发现还是浸水，开发商来给打了胶，今年发现打胶的地方不阴水了，其他地方开始了，今年有找了他们，让他们给楼顶做了一下防水，只能明年雨季观察了。明年就是防水保修期最后一年了，不知道过了之后再找谁。  5. 住房噪音篇：20年10月住进来之后，自己手里也没钱，只买了一张床自己睡，买了个魔术贴窗帘，周末没事就打打游戏，直到有一天忽然听见早上有人唱歌，就很蒙，声音很清楚，发现是旁边单元声音，我记得刚刚交房时带我妈来看，我姐家几个孩子也来，在房间里跑，喊，我妈说这房子怎么这么ying的慌（方言吵），终于知道房间隔音很差，然后后面他们好像打游戏很大声音，找物业投诉了，再后来好像他们就搬走了，新搬来的一户，我发现他们好像不在主卧住，不知道是业主还是租户。然后晚上经常听到咚一声，发现是楼下关卧室门声，开关灯声都很清楚，直到疫情居家隔离时，有天晚上很晚他们家还一直吵，就举报了他们，过了没多久好像又搬走了，这两年我和对象一直住在小次卧，小次卧相对安静，23年结了婚，10月左右发现有了宝宝，当时他们搬走了基本没什么声音，直到有一天楼下2,3点有叮咚声，我下去找了他们，是一对小情侣新搬来在收拾空调，之后几天没啥声音，忽然听到晚上有人很大声在喊，像是打游戏，一直到了凌晨4点，我没睡着，直接去楼下找了他们，发现开门的不是之前的情侣，和他们聊发现他们是搞游戏直播的，那对小情侣住在主卧，小次卧他们打游戏，领一个次卧也住了个女的搞直播，之后有因为他们大半夜2点多剁排骨，找了他们，然后过完年他们也都搬走了，房东去年就在卖房，没卖出去，今年5月宝宝出生，然后楼下6月卖了出去，装修电钻声，把孩子吓哭好几次，但是人家正常时间装修也没找他们。最近晚上一点多隐隐约约听到有人说话声，还有诺凳子声，楼下没人，旁边单元主卧没人住，旁边胡没卖出去，定位到是旁边户型楼下的人，之前就看到他们搬过来，没想到还会有交集，他们一直持续噪音到早上，下楼上班时，看到他们，从他们小电驴看应该是送外卖的，和他们聊天发现浑身酒气，他们已经两次喝酒到凌晨了，和他们交流了，不知道接下来啥时候再来一次。  6. 另外一个噪音来源也是一直持续的就是楼顶，从住进来一年之后，发现有人经常上楼顶晾晒，有时中午睡觉，也会被咚咚声吵醒，刚开始还有在楼顶遛狗，跳绳，吊嗓子的，就上楼去劝告他们，但是晾晒的还是有人，联系了物业，物业也是不允许晾晒的，但是楼顶门消防上不让关逃生通道，物业就给收了几次晾衣绳，但是上面有衣物的他们也不敢收，其实一个月晾晒一次也没啥，楼顶阳光那么好，但是就烦的是当成自家的每天都往上爬，楼里就有个女的每个周末都往上去，不管阴天晴天。最近被他折腾烦了，在物业群里说了他们，再不行就只能以恶治恶了  当时买房时150w,首付45，贷款105,从月供5700多到现在4700多，算了算本金只还了7w,20多是利息，去年结婚后，收的礼钱，+我和媳妇公积金+孩子的礼钱，一共还了22w,还剩75w，希望抓紧还完，下一套房一定要好好吸取教训，其实我觉得老破小挺好的，我喜欢早睡，在老家小区8点就没啥人了。  希望你看完能对你买房入坑有所帮助。身边人都说我不爱笑了，头发也白了很多，都问我愁什么，有车有房。我也不知道如何给他们说。幸亏我老婆睡觉熟很多噪音她听不到，不然我会更焦虑哈哈哈哈哈。]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JS操作符</title>
    <link href="/article/f1ff5bd.html"/>
    <url>/article/f1ff5bd.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p><code>?.</code> 运算符与 <code>.</code> 链式运算符相似，不同之处在于，如果引用是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish">空值</a>（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>），它不会导致错误，而是使表达式短路并返回 <code>undefined</code>。当用于函数调用时，如果给定函数不存在，它也会返回 <code>undefined</code>。</p><p><strong>空值合并运算符</strong>（**<code>??</code>**）是一个逻辑运算符，当左侧的操作数为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/null"><code>null</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a> 时，返回其右侧操作数，否则返回左侧操作数。</p><p>逻辑空赋值运算符（<code>x ??= y</code>）仅在 <code>x</code> 是<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Nullish">空值</a>（<code>null</code> 或 <code>undefined</code>）时对其赋值。</p><p>严格相等运算符（<code>===</code>）会检查它的两个操作数是否相等，并且返回一个布尔值结果。与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality">相等</a>运算符不同，严格相等运算符总是认为不同类型的操作数是不同的。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K8S内网部署问题</title>
    <link href="/article/385fe79a.html"/>
    <url>/article/385fe79a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />查看pod的docker启动日志1.coredns无法启动，报错： listen tcp :53: bind: permission deniedcentos 7.9 中无法通过设置 net.ipv4.ip_unprivileged_port_start 解决，  最后解决选择了 修改 coredns 的 SecurityContext 的 allowPrivilegeEscalation 为 true<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">securityContext:</span><br>  <span class="hljs-attr">allowPrivilegeEscalation:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>2.calico 报错customResourceDefinition default not found<br>去查看docker启动日志发现calico.yaml 和 镜像版本不一致，参数找不到，升级calico版本</p><p>3.从节点，kubectl日志提示 &#x2F;var&#x2F;lib&#x2F;calico&#x2F;nodename not found 手动创建</p><p>4.kubectl 提示 #  runtime create failed systemd cgroup flag passed, but systemd support for managing，将docker  和 k8s cgroup-driver改为cgroupfs,猜测与docker版本有关理论都使用systemed也可以.</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习之一：离线安装Docker步骤</title>
    <link href="/article/c172ae43.html"/>
    <url>/article/c172ae43.html</url>
    
    <content type="html"><![CDATA[<p>0<!-- toc --></p><meta name="referrer" content="no-referrer" /><h2 id="1、Docker安装"><a href="#1、Docker安装" class="headerlink" title="1、Docker安装"></a>1、Docker安装</h2><h3 id="1-1、离线安装"><a href="#1-1、离线安装" class="headerlink" title="1.1、离线安装"></a>1.1、离线安装</h3><p><strong>步骤一</strong>：官网下载 <a href="https://download.docker.com/linux/static/stable/x86_64/">docker 安装包</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>static<span class="hljs-regexp">/stable/</span>x86_64/docker-<span class="hljs-number">24.0</span>.<span class="hljs-number">6</span>.tgz<br></code></pre></td></tr></table></figure><p><strong>步骤二</strong>：解压安装包;</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf docker-<span class="hljs-number">24</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span>.tgz<br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：将解压之后的<code>docker</code>文件移到 <code>/usr/bin</code>目录下;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo cp docker<span class="hljs-regexp">/* /u</span>sr<span class="hljs-regexp">/bin/</span><br></code></pre></td></tr></table></figure><p><strong>步骤四</strong>：将<code>docker</code>注册成系统服务;</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>docker.service<br></code></pre></td></tr></table></figure><p>然后在文件中添加以下内容，退出并保存。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Docker Application Container Engine<br><span class="hljs-attr">Documentation</span>=https://docs.docker.com<br><span class="hljs-attr">After</span>=network-<span class="hljs-literal">on</span>line.target firewalld.service<br><span class="hljs-attr">Wants</span>=network-<span class="hljs-literal">on</span>line.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=notify<br><span class="hljs-attr">ExecStart</span>=/usr/bin/dockerd<br><span class="hljs-attr">ExecReload</span>=/bin/kill -s HUP <span class="hljs-variable">$MAINPID</span><br><span class="hljs-attr">LimitNOFILE</span>=infinity<br><span class="hljs-attr">LimitNPROC</span>=infinity<br><span class="hljs-attr">TimeoutStartSec</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">Delegate</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">KillMode</span>=process<br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure<br><span class="hljs-attr">StartLimitBurst</span>=<span class="hljs-number">3</span><br><span class="hljs-attr">StartLimitInterval</span>=<span class="hljs-number">60</span>s<br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure><p><strong>步骤五</strong>：给文件增加可执行权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod +x <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>docker.service<br>systemctl daemon-reload <br></code></pre></td></tr></table></figure><p><strong>步骤六</strong>：设置开机自启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker.service<br></code></pre></td></tr></table></figure><p><strong>步骤七</strong> ：启动<code>docker</code></p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure><p><strong>步骤八</strong>：测试<code>docker</code>是否启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/947aab77e905b2f32a98354bec5454df.png#pic_center" alt="在这里插入图片描述"></p><p><strong>卸载步骤</strong></p><p><strong>步骤一</strong>：停止<code>docker</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">sudo systemctl stop docker<br></code></pre></td></tr></table></figure><p><strong>步骤二</strong>：删除<code>Docker</code>服务</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 移除开机自启动</span><br>systemctl disable docker.service<br><span class="hljs-comment"># 删除service服务</span><br>rm -f <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>docker.service<br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：删除<code>Docker</code>相关命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -f <span class="hljs-regexp">/usr/</span>bin/docker*<br>rm -f <span class="hljs-regexp">/usr/</span>bin/containerd*<br>rm -f <span class="hljs-regexp">/usr/</span>bin/ctr<br>rm -f <span class="hljs-regexp">/usr/</span>bin/runc<br></code></pre></td></tr></table></figure><p><strong>步骤三</strong>：删除<code>docker</code>目录和容器相关文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo rm -rf <span class="hljs-regexp">/var/</span>lib/docker<br>sudo rm -rf <span class="hljs-regexp">/var/</span>lib/containerd<br></code></pre></td></tr></table></figure><p><strong>步骤四</strong>：验证是否已成功卸载</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h3 id="1-2、在线安装"><a href="#1-2、在线安装" class="headerlink" title="1.2、在线安装"></a>1.2、在线安装</h3><p>参考官方文档：<a href="https://docs.docker.com/engine/install/ubuntu/">Docker安装步骤</a></p><h2 id="2、Docker镜像"><a href="#2、Docker镜像" class="headerlink" title="2、Docker镜像"></a>2、Docker镜像</h2><h3 id="2-1、镜像下载"><a href="#2-1、镜像下载" class="headerlink" title="2.1、镜像下载"></a>2.1、镜像下载</h3><p><strong>步骤一</strong>：查找镜像</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker search ubuntu</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/002563a36fcac500fbd9affb2ca35538.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤二</strong>：下载镜像</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull ubuntu</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f94df933695d13be2220c5648e8d1015.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤三</strong>：查看镜像</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/86d5536a51e86c49c4d668ac03acdad7.png#pic_center" alt="在这里插入图片描述"></p><p>删除镜像，可以执行：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi e4c58958181a<br><span class="hljs-comment">#或者</span><br>docker rmi ubuntu:latest<br></code></pre></td></tr></table></figure><h3 id="2-2、容器命令"><a href="#2-2、容器命令" class="headerlink" title="2.2、容器命令"></a>2.2、容器命令</h3><p>这里的<code>ubuntu</code>镜像就类似迷你版的<code>ISO</code>镜像文件，启动镜像的时候可以理解为以这个镜像创建了一个虚拟机，并执行了封装镜像的时候所书写的命令，对于这样已经启动的镜像我们称之为容器（<code>containerd</code>），这里测试所使用的只是一个<code>ubuntu</code>的镜像，启动的时候只是一个<code>ubuntu</code>的虚拟机，没有封装实际的功能。</p><p><strong>步骤一</strong>：启动容器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> ubuntu:latest<br><span class="hljs-comment">#或者</span><br>docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> e4c58958181a<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4a22d97af17fa8207fbd82c59b104106.png#pic_center" alt="在这里插入图片描述"></p><p>可以看出启动之后进入到一个迷你版本的<code>ubuntu</code>系统，里面封装了一部分常用命令，但是大部分命令都没有安装。</p><p>执行 <code>eixt</code> 可以退出容器，并关闭该容器运行，类似于虚拟机关机，但是虚拟机本身还存在。</p><p>也可以执行<code>ctrl + p</code> 之后 执行 <code>ctrl + q</code>这样可以退出容器，但容器本身在后台继续运行，类似于虚拟机运行状态。</p><p><strong>步骤二</strong>：查看启动的容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker ps -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/63d4501560b626d8bfc6aa885feeac65.png#pic_center" alt="在这里插入图片描述"></p><p>这里显示状态<code>Exited</code>表示容器已经停止运行了，如果想要重启容器，可以执行<code>docker start 700f9f498c9d</code>， 其中<code>700f9f498c9d</code>表示容器的<code>ID</code></p><p><strong>步骤三</strong>：重启容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> start <span class="hljs-number">700</span>f9f498c9d<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/07489fd549af058dff800a38f72c85ed.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤四</strong>：停止容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> stop <span class="hljs-number">700</span>f9f498c9d<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e7cb712a1baef76c4f853b04783d510.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤五</strong>：删除容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rm <span class="hljs-number">700</span>f9f498c9d<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e3f358bff7910b4ddd0c36e2a382c194.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤六</strong>：后台启动容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -itd ubuntu:latest<br><span class="hljs-comment">#或者</span><br>docker <span class="hljs-built_in">run</span> -itd e4c58958181a<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d87d67d226187d8c0628e4c98fe40276.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤七</strong>：连接容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> attach <span class="hljs-number">725</span>f09c35ba6<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9eb1e1776a64b5243c783aeaad77e06.png#pic_center" alt="在这里插入图片描述"></p><p>这样启动执行<code>eixt</code>之后容器也会关闭，如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e4d40f7210551589b1d486a11fb4db7a.png#pic_center" alt="在这里插入图片描述"></p><p>因此，可以使用下面命令链接容器：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it <span class="hljs-number">725</span>f09c35ba6 <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6804331f906b3631f7c6a631e80b3c86.png#pic_center" alt="在这里插入图片描述"></p><p>这样使用<code>exit</code>退出容器，容器也不会关闭。</p><p><strong>步骤八</strong>：查看<code>ubuntu</code>版本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/i</span>ssue<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d6e7f6d9892fac2bd644b62c658ab990.png#pic_center" alt="在这里插入图片描述"></p><h2 id="3、程序封装"><a href="#3、程序封装" class="headerlink" title="3、程序封装"></a>3、程序封装</h2><h3 id="3-1、需求分析"><a href="#3-1、需求分析" class="headerlink" title="3.1、需求分析"></a>3.1、需求分析</h3><p>需要将在<code>ubuntu 22.04</code>版本下编译的<code>coml_transcode</code>可执行程序及运行目录上传到容器中，并在容器中成功运行程序，然后将该容器打包成一个新的镜像基础文件作为发布版使用，现场服务器部署完<code>docker</code>之后直接加载启动这个新的镜像就能成功运行<code>coml_transcode</code>程序，这样就避免了依赖现场服务器环境（操作系统不一致，glibc库不一致等导致程序启动不成功等问题。）</p><h3 id="3-2、创建镜像"><a href="#3-2、创建镜像" class="headerlink" title="3.2、创建镜像"></a>3.2、创建镜像</h3><p><strong>步骤一</strong>：虚拟机上编译源代码，并将运行目录上传</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/753f22d955f28732cc4c8eb354f13287.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤二</strong>：编写<code>DockerFile</code>文件</p><p>该文件和源文件在一个文件夹下，如上图所示，名为<strong>dockerfile</strong>，文件内容：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu<br><br><span class="hljs-keyword">ENV</span> MYPATH /home/coml_transcode<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> ./coml_transcode <span class="hljs-variable">$MYPATH</span></span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$MYPATH</span></span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;start.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure><p><code>FROM ubuntu</code>: <code>FROM</code>是后面是该目标镜像使用的基础镜像，基础镜像有且只能有一个，这里使用<code>ubuntu</code>作为基础镜像；</p><p><code>ENV</code>: 配置环境目录；</p><p><code>COPY</code>: 将宿主机下的文件拷贝到镜像；</p><p><code>WORKDIR</code>：设置容器的默认工作目录；</p><p><code>ENTRYPOINT</code>: 器启动时第一个运行的命令及其参数，这里表示启动容器是执行<code>start.sh</code>脚本。</p><p><strong>步骤三</strong>：创建镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -f ./dockerfile -t coml_transcode:v1.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure><p><code>./dockerfile</code> 表示<code>Dockerfile</code>的所在位置;</p><p><code>coml_transcode:v1.0</code> 表示新建镜像的名字及版本号</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f3b5595e8556641b52dd050a8ec08f69.png#pic_center" alt="在这里插入图片描述"></p><p>构建完查看是否成功构建，通过<strong>docker images</strong>命令查看当前本地的所有镜像：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/34d565175ce455eb75bef0b5dc5cf976.png#pic_center" alt="在这里插入图片描述"></p><p>这里的<code>coml_trancode</code>镜像便是刚创建的</p><p><strong>步骤四</strong>：通过镜像运行一个容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d coml_transcode:v1.0<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/aff6cf8cb6f4571bd141879f30c13863.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤五</strong>：链接容器</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it <span class="hljs-number">02135</span>e2b8b7d <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fafb01c2d732307be107871a1895c5be.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤六</strong>：导出镜像</p><p>通过上述可以验证程序能够在<code>ubuntu</code>基础虚拟机上面运行，将<code>coml_transcode</code>这个镜像导出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> save -o ./coml_transcode.tar coml_transcode:v1.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/48b2a17df68315ec7f9a12ec2b69862f.png#pic_center" alt="在这里插入图片描述"></p><h2 id="4、现场环境"><a href="#4、现场环境" class="headerlink" title="4、现场环境"></a>4、现场环境</h2><h3 id="4-1、安装Docker"><a href="#4-1、安装Docker" class="headerlink" title="4.1、安装Docker"></a>4.1、安装Docker</h3><p>现场服务器按照<code>1.1</code>章节步骤安装<code>docker</code></p><h3 id="4-2、导入镜像"><a href="#4-2、导入镜像" class="headerlink" title="4.2、导入镜像"></a>4.2、导入镜像</h3><p><strong>步骤一</strong>：将<code>coml_transcode.tar</code>镜像导入到现场服务器上</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker load -<span class="hljs-selector-tag">i</span> coml_transcode<span class="hljs-selector-class">.tar</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cac5148262cfa483f3486711a15f0858.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤二</strong>：通过该镜像启动一个容器</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d 18820b82f7eb<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b17e9fc6fc80c2300fa0d44de6b842ff.png#pic_center" alt="在这里插入图片描述"></p><p><strong>步骤三</strong>：链接容器</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">docker exec -it <span class="hljs-number">98</span><span class="hljs-keyword">c</span><span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">6</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>bf<span class="hljs-number">75</span> /bin/bash<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/80feef2dc9ae7f400155c0c1cdfc4bc4.png#pic_center" alt="在这里插入图片描述"></p><p>可以看到程序已经成功启动</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p><strong>1、预安装命令</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">vim<br>ifconfig<br>dstat<br>ufw<br>tcpdump<br><span class="hljs-built_in">ping</span><br></code></pre></td></tr></table></figure><p>初始化<code>ubuntu</code>镜像安装的命令很少，可以通过<code>3.2</code>章节编写<code>Dockerfile</code>文件来预安装可能用到的命令，如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> ubuntu<br><br>ENV MYPATH /home/coml_transcode<br><br>COPY ./coml_transcode <span class="hljs-variable">$MYPATH</span><br><br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#更新apt</span><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> update<br><span class="hljs-comment">#安装vim编辑器</span><br><span class="hljs-built_in">RUN</span> apt -y install vim<br><span class="hljs-comment">#安装ifconfig命令查看网络IP</span><br><span class="hljs-built_in">RUN</span> apt -y install net-tools<br><span class="hljs-comment">#安装防火墙查看攻击</span><br><span class="hljs-built_in">RUN</span> apt -y install ufw<br><span class="hljs-comment">#安装网络IO查看工具</span><br><span class="hljs-built_in">RUN</span> apt -y install dstat<br><span class="hljs-comment">#安装抓包工具</span><br><span class="hljs-built_in">RUN</span> apt -y install tcpdump<br><span class="hljs-comment">#安装ping命令</span><br><span class="hljs-built_in">RUN</span> apt -y install iputils-ping<br><br>ENTRYPOINT [<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;start.sh&quot;</span>]<br></code></pre></td></tr></table></figure><p>然后再创建新的镜像即可，这样通过新镜像启动的容器初始就存在这些命令。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/af2c457cdbf68ad3dc38abec8942aaab.png#pic_center" alt="在这里插入图片描述"></p><p><strong>2、网络配置</strong></p><p><code>Doker</code>启动的容器存在<code>4</code>种网络配置，如下表所示：</p><table><thead><tr><th>网络模式</th><th>指定方式</th><th>解释</th><th></th></tr></thead><tbody><tr><td><code>bridge</code></td><td><code>--network bridge</code>指定，默认使用<code>docker0</code></td><td><strong>桥接模式</strong>链接宿主机，通过虚拟出来的<code>docker0</code>作为网桥链接物理网卡，也可以使用<code>docker network create --subnet=172.18.0.0/16 docker1</code>创建新的网桥使用。</td><td></td></tr><tr><td><code>host</code></td><td><code>--network host</code>指定</td><td><strong>主机模式</strong>链接宿主机，通过和宿主机共享同一物理网卡链接，自身不在配置<code>IP</code>，这种模式无法做到网络端口映射。</td><td></td></tr><tr><td><code>none</code></td><td><code>--network none</code>指定</td><td><strong><code>none</code>模式</strong>，禁用网络功能，这个<code>Docker</code>容器不存在网卡，<code>IP</code>等信息。不能和其它容器或宿主机进行通信。</td><td></td></tr><tr><td><code>container</code></td><td><code>--network container:NAME</code>或者容器<code>ID</code></td><td><strong><code>container</code>模式</strong>，同其它容器共享网络，<code>MAC</code>地址和<code>ip</code>一样。</td><td></td></tr></tbody></table><p><code>docker</code>容器启动的时候如果不指定网络模式，默认选择<code>bridge</code>模式</p><p><strong>3、CPU隔离</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d <span class="hljs-attribute">--cpuset-cpus</span>=1-20 coml_transcode:v2.0<br></code></pre></td></tr></table></figure><p>指定该容器使用<code>CPU 1-20</code></p><p><strong>4、日志文件同步</strong></p><p>日志同步可以做到容器指定目录下的文件可以和宿主机指定目录下的文件进行实时同步功能。这样可以解决如下几个问题：</p><p>1.如果启动的容器异常退出之后，重启不起来，导致容器里存在的程序日志信息无法查看；</p><p>2.如果需要更新程序，只需要将最新版本的程序，上传至宿主机的共享目录下，然后重启容器即可完成程序的迭代更新；</p><p>3.对于集群部署的容器，可以将宿主机共享文件统一设置再一个目录下，如：<code>data/data1, data/data2, data/data3</code>这样的格式，这样便于查看每个容器所打印的日志信息，不必去连接到每一个容器去查看。</p><p>启动容器时使用如下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 获取宿主机可执行程序运行目录</span><br>root@ubuntu:<span class="hljs-regexp">/home/</span>DockerTranscode/coml_transcode<span class="hljs-comment"># pwd</span><br><span class="hljs-regexp">/home/</span>DockerTranscode/coml_transcode<br><br><span class="hljs-comment"># 启动容器</span><br> docker run -d --privileged=true -v <span class="hljs-regexp">/home/</span>DockerTranscode<span class="hljs-regexp">/coml_transcode:/</span>home<span class="hljs-regexp">/coml_transcode/</span> coml_transcode:v5.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5a2ad1875f76211f43d14a529b300906.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CloudFlare+SaaS回源优选IP使国内用户高速访问网站</title>
    <link href="/article/4c7bdcf0.html"/>
    <url>/article/4c7bdcf0.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /># 前言 🚀<p>由于不可抗力因素,使用了Cloudflare开启小黄云在国内的访问速度十分堪忧,间歇性抽风</p><p>在之前我们可以使用cloudflare partner来使访问回源到一个优选过后的IP</p><p>但是在去年这个方法已经行不通了, 那么我们这些白嫖玩家又不想对接国内备案实名CDN,同时想要保证国内的高速访问</p><p>我们应该怎么做呢?</p><p>这就是我们这期要讲的主要内容,Cloudflare SaaS回源</p><h1 id="什么是SaaS回源-🤔"><a href="#什么是SaaS回源-🤔" class="headerlink" title="什么是SaaS回源? 🤔"></a>什么是SaaS回源? 🤔</h1><h2 id="SaaS回源主要分为两个部分"><a href="#SaaS回源主要分为两个部分" class="headerlink" title="SaaS回源主要分为两个部分"></a>SaaS回源主要分为两个部分</h2><ol><li>自定义主机名 (Custom Hostnames)<ul><li>你可以设置一个自定义主机名,来作为你的访问域名</li></ul></li><li>回源 (Origin Server)<ul><li>当用户请求特定的主机名（如客户自己的域名）时，请求会被转发到SaaS提供商的原始服务器（或称为回源服务器）。</li></ul></li></ol><h1 id="SaaS回源有什么用-🧐"><a href="#SaaS回源有什么用-🧐" class="headerlink" title="SaaS回源有什么用? 🧐"></a>SaaS回源有什么用? 🧐</h1><ul><li><p>可能看到现在大家还是一头雾水,不过没关系,我会给大家根据实例来通俗易懂的解释一下</p></li><li><p>我们可以使用支持分流的DNS解析服务(例如腾讯的DNSPOD),</p><p>将我们需要访问的域名例如 <code>image.dooo.ng</code> 通过CNAME解析到任意一个Cloudflare的节点,</p><p>例如<code>csgo.com</code>, <code>visa.com</code>,而这些域名解析到的CF的IP通常是经过大陆特殊优化的</p><p>有些是优选线路,有些的百度云合作的IP地址</p></li><li><p>将我们的 <code>image.dooo.ng</code> CNAME解析到 <code>csgo.com</code> 之后, 我们访问image.dooo.ng的请求实则是被发送到了</p><p><strong>经过优选后线路较好的Cloudflare IP</strong>上 这个步骤达到了我们优选IP的目的</p></li><li><p>此时Cloudflare的IP收到了我们的访问请求, 会匹配我们访问的域名 <code>image.dooo.ng</code> 在Cloudflare中是否有匹配的 <strong>自定义主机名</strong> 如果有, 它会将我们回源到我们设置的 <strong>回源服务器</strong> 上</p></li><li><p>这里我绘制了一个序列图来帮助大家理解</p><p><img src="https://image.dooo.ng/i/2023/11/28/6565c28e8d95e.jpg"></p></li></ul><h2 id="使用Cloudflare的SaaS回源"><a href="#使用Cloudflare的SaaS回源" class="headerlink" title="使用Cloudflare的SaaS回源"></a>使用Cloudflare的SaaS回源</h2><ul><li>我们可以设置自定义域名（例如 <code>image.dooo.ng</code>）。</li><li>并通过CNAME记录将其解析到另一个域名（例如 <code>csgo.com</code>）。</li><li>这样设置是为了利用Cloudflare的安全和性能特性，如DDoS防护、SSL&#x2F;TLS加密、CDN加速等。</li></ul><h2 id="CNAME解析过程"><a href="#CNAME解析过程" class="headerlink" title="CNAME解析过程"></a>CNAME解析过程</h2><ul><li>访问 <code>image.dooo.ng</code> 时，DNS查询会根据CNAME记录找到它实际指向的 <code>csgo.com</code>。</li><li>由于 <code>csgo.com</code> 已接入Cloudflare CDN，用户的请求会被路由到Cloudflare的边缘节点。</li></ul><h2 id="Cloudflare边缘节点处理"><a href="#Cloudflare边缘节点处理" class="headerlink" title="Cloudflare边缘节点处理"></a>Cloudflare边缘节点处理</h2><ul><li>Cloudflare的边缘节点处理请求，包括应用安全规则、进行缓存等。</li><li>如果请求需要回源（即获取原始内容），Cloudflare会将请求转发到原始的回源服务器。</li></ul><h2 id="访问过程的理解"><a href="#访问过程的理解" class="headerlink" title="访问过程的理解"></a>访问过程的理解</h2><ul><li>用户访问 <code>image.dooo.ng</code> 实际上是在访问Cloudflare的节点。</li><li>然后，根据需要，Cloudflare会从原始的回源服务器获取内容。</li><li>这个过程对用户透明，用户只知道他们访问的是 <code>image.dooo.ng</code>，但实际上得到的内容可能是直接来自Cloudflare的缓存，或者是经过Cloudflare优化处理后的来自原始服务器的内容。</li></ul><h1 id="实际操作-🛠️"><a href="#实际操作-🛠️" class="headerlink" title="实际操作 🛠️"></a>实际操作 🛠️</h1><h2 id="准备域名-🌐"><a href="#准备域名-🌐" class="headerlink" title="准备域名 🌐"></a>准备域名 🌐</h2><ul><li><p>在了解了SaaS回源的相关原理之后, 我们可以进行实操了!</p></li><li><p>首先我们需要准备两个域名</p><ol><li><p><code>tongyi.tw.cn</code> &lt;– 作为 我们的访问域名,也就是自定义主机名,稍后我们访问此域名来访问网站</p></li><li><p><code>fallback.tech</code> &lt;– 作为 我们的回源域名,也就是当我们访问 <code>tongyi.tw.cn</code> 时,cloudflare在内部回源的域名</p></li><li><p>我将<code>tongyi.tw.cn</code> 解析在腾讯的DNSPOD上, 而<code>fallback.tech</code> 解析在Cloudflare上</p><ul><li><p>前者不是必须的,你可以都解析在Cloudflare上,我选择DNSPOD是因为它有免费的分流服务</p><p>可以将境内境外解析到不同的cname上</p></li><li><p>而后者则是必须的! 因为只有解析在cloudflare上的域名才可以启用SaaS回源</p></li></ul></li></ol></li></ul><h1 id="设置回源域名-🔄"><a href="#设置回源域名-🔄" class="headerlink" title="设置回源域名 🔄"></a>设置回源域名 🔄</h1><h2 id="添加DNS解析-🧩"><a href="#添加DNS解析-🧩" class="headerlink" title="添加DNS解析 🧩"></a>添加DNS解析 🧩</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565c5ed316f3.jpg" alt="image-20231128185020364"></p><ul><li>首先我们先来添加一个DNS解析</li><li>解析到我们的真实服务器IP地址, 正如上面所说的,这是一个回源的域名,也就是说,服务器的IP到底是什么 只有这台回源域名知道,它的工作也只是起到回源的作用</li><li>这里你可以随意填写一级域名或二级域名,我推荐填写二级域名 也就是 <code>origin.fallback.tech</code> 可以随意起名</li><li>因为填写二级域名, 你还可以在DNS中正常解析一级域名,仅将二级域名作为回退源</li></ul><h2 id="添加回退源-🔄"><a href="#添加回退源-🔄" class="headerlink" title="添加回退源 🔄"></a>添加回退源 🔄</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565c5010d985.jpg" alt="image-20231128184623739"></p><ul><li>进入到Cloudflare域名管理界面 -&gt; SSL&#x2F;TLS -&gt; 自定义主机名 -&gt; 添加一个回退源</li><li>回退源地址即为我们刚才解析的二级域名</li></ul><p><img src="https://image.dooo.ng/i/2023/11/28/6565c6b4281c9.jpg" alt="image-20231128185339266"></p><h2 id="检查回退源是否有效-✔️"><a href="#检查回退源是否有效-✔️" class="headerlink" title="检查回退源是否有效 ✔️"></a>检查回退源是否有效 ✔️</h2><ul><li>回退源状态: <code>有效</code> 即代表回退源添加成功,现在访问 <code>origin.fallback.tech</code> 你应该会看到如下界面</li></ul><p><img src="https://image.dooo.ng/i/2023/11/28/6565c753a0a85.jpg" alt="image-20231128185618750"></p><ul><li>这是因为虽然设置了回退源,但是我们并没有设置自定义主机名,也就是回退源并不知道要将哪个主机名回源到我们的服务器IP</li></ul><h1 id="设置自定义主机名-🏠"><a href="#设置自定义主机名-🏠" class="headerlink" title="设置自定义主机名 🏠"></a>设置自定义主机名 🏠</h1><h2 id="添加自定义主机名-🌐"><a href="#添加自定义主机名-🌐" class="headerlink" title="添加自定义主机名 🌐"></a>添加自定义主机名 🌐</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565c922e065d.jpg" alt="image-20231128190401927"></p><h2 id="设置主机名信息-🛠️"><a href="#设置主机名信息-🛠️" class="headerlink" title="设置主机名信息 🛠️"></a>设置主机名信息 🛠️</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565c9322b81f.jpg" alt="image-20231128190417387"></p><ul><li><p>自定义主机名: 填写你要解析的域名, 可以为一级或者二级均可,这里我填写 <code>tongyi.tw.cn</code></p></li><li><p>TLS版本默认填写1.0即可</p></li><li><p>证书验证方法填写TXT验证</p></li></ul><h2 id="验证域名所有权-📋"><a href="#验证域名所有权-📋" class="headerlink" title="验证域名所有权 📋"></a>验证域名所有权 📋</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565ca912e0fd.jpg" alt="image-20231128191006506"></p><ul><li><p>这里我们需要验证我们域名的所有权和证书验证</p></li><li><p>去到你的DNS解析面板添加这两个TXT解析</p></li><li><p>值得注意的是你的两个TXT验证名称应该不包含主域名, 例如直接复制下来是<code>_acme-challenge.tongyi.tw.cn</code> 你应该删去 <code>tongyi.tw.cn</code> 即为 <code>_acme-challenge</code> 因为它给你的是验证的完整地址,你的解析已经包括<code>tongyi.tw.cn</code></p></li><li><p>二级域名同理,例如 <code>_acme-challenge.1.tongyi.tw.cn</code> 你应该改为 <code>_acme-challenge.1</code></p></li><li><p>添加好之后稍等片刻,等待CF服务器去验证</p></li></ul><h1 id="设置优选IP-🚀"><a href="#设置优选IP-🚀" class="headerlink" title="设置优选IP 🚀"></a>设置优选IP 🚀</h1><p>经过我们一番折腾,最好玩的部分来了</p><h2 id="设置分流-🛣️"><a href="#设置分流-🛣️" class="headerlink" title="设置分流 🛣️"></a>设置分流 🛣️</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565cd52ead7e.jpg" alt="image-20231128192154083"></p><ul><li><p>添加两个二级域名记录,一个<code>线路</code>选择<code>境内</code>,另一个选择<code>境外</code></p></li><li><p>境外我们直接解析到 <code>1.0.0.5</code></p></li><li><p>境内我们CNAME解析到 <code>csgo.com</code> 你还可以选择很多,只要是国内访问速度不错,使用Cloudflare CDN的,你都可以cname解析上去</p><h3 id="可使用的CNAME优选域名参考-🌐"><a href="#可使用的CNAME优选域名参考-🌐" class="headerlink" title="可使用的CNAME优选域名参考 🌐"></a>可使用的CNAME优选域名参考 🌐</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Qatar2022</span><span class="hljs-params">(SAN JOSE IP)</span></span> : <br>www<span class="hljs-selector-class">.qatar2022</span><span class="hljs-selector-class">.qa</span><br><br>IP查询 : <br>ip<span class="hljs-selector-class">.skk</span><span class="hljs-selector-class">.moe</span><br>ping<span class="hljs-selector-class">.pe</span><br><br>政府网站:<br>乌克兰🇺🇦政府<br>www<span class="hljs-selector-class">.gov</span><span class="hljs-selector-class">.ua</span><br><br>泰国🇹🇭政府<br>www<span class="hljs-selector-class">.thaigov</span><span class="hljs-selector-class">.go</span><span class="hljs-selector-class">.th</span><br><br>卡塔尔🇶🇦政府<br>www<span class="hljs-selector-class">.gco</span><span class="hljs-selector-class">.gov</span><span class="hljs-selector-class">.qa</span><br><br>瑞典🇸🇪政府<br>www<span class="hljs-selector-class">.gov</span><span class="hljs-selector-class">.se</span><br><br>美国🇺🇸FBI:<br>FBI<span class="hljs-selector-class">.GOV</span><br><br>商业网站：<br>CSGO官方网站<br>(Cloudflare LONDON ASN)：<br>CSGO<span class="hljs-selector-class">.COM</span><br><br>DigitalOcean<br>digitalocean<span class="hljs-selector-class">.com</span><br><br>VISA官方网站：<br>(格式： VISA.国家顶级域名)<br>VISA<span class="hljs-selector-class">.COM</span><br>VISA<span class="hljs-selector-class">.CN</span><br>VISA<span class="hljs-selector-class">.FI</span><br>VISA<span class="hljs-selector-class">.HK</span><br><br>伪AMEX:<br>AMEX<span class="hljs-selector-class">.COM</span><br><br><span class="hljs-function"><span class="hljs-title">SHOPIFY</span><span class="hljs-params">(推荐)</span></span>:<br>SHOPIFY<span class="hljs-selector-class">.COM</span><br><br>域名注册商：<br>Dynadot<span class="hljs-selector-class">.COM</span><br><br>其它网站：<br>SINGAPORE<span class="hljs-selector-class">.COM</span><br>JAPAN<span class="hljs-selector-class">.COM</span><br>BRAZIL<span class="hljs-selector-class">.COM</span><br>MALAYSIA<span class="hljs-selector-class">.COM</span><br>RUSSIA.COM<br></code></pre></td></tr></table></figure><p>Makefile</p></li></ul><h2 id="添加解析-🧩"><a href="#添加解析-🧩" class="headerlink" title="添加解析 🧩"></a>添加解析 🧩</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565cea7f34da.jpg" alt="image-20231128192733483"></p><ul><li>再将我们要访问的域名,CNAME解析到我们的CDN记录上即可,</li></ul><h1 id="排查错误-🔍"><a href="#排查错误-🔍" class="headerlink" title="排查错误 🔍"></a>排查错误 🔍</h1><ul><li><p>注意如果要访问,我们的站点必须开启SSL证书和HTTPS访问,不然会直接404,因为回源只回源到443端口</p></li><li><p>现在我们打开网站测试下能否正常访问</p></li></ul><h2 id="重定向次数过多"><a href="#重定向次数过多" class="headerlink" title="重定向次数过多"></a>重定向次数过多</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565cf6930430.jpg" alt="image-20231128193047979"></p><p>提示我们重定向过多,这是因为HTTPS加密的问题,我们进入Cloudflare后台 -&gt; SSL&#x2F;TLS -&gt; 概述</p><p>​ <img src="https://image.dooo.ng/i/2023/11/28/6565cfc3f3346.jpg" alt="image-20231128193218725"></p><p>将SSL&#x2F;TLS加密模式改为 “完全” 再次尝试访问</p><h2 id="Invalid-SSL-Certificate"><a href="#Invalid-SSL-Certificate" class="headerlink" title="Invalid SSL Certificate"></a>Invalid SSL Certificate</h2><p><img src="https://image.dooo.ng/i/2023/11/28/65660ac867011.webp"></p><ul><li>出现此问题是因为我们的回源域名 <code>fallback.tech</code> 在进行回源时,访问的是 <code>tongyi.tw.cn</code></li><li>虽然我们在验证所有权时申请了一个证书,但那个证书是用于回源之后呈现给用户端的, 在回源过程中不会生效</li><li>所以我们需要给 <code>tongyi.tw.cn</code> 申请一个证书, 可以通过宝塔面板,NPM等等方式,只要申请一个证书并配置即可解决此问题</li></ul><h1 id="结果测试-🧪"><a href="#结果测试-🧪" class="headerlink" title="结果测试 🧪"></a>结果测试 🧪</h1><p><img src="https://image.dooo.ng/i/2023/11/28/6565d0b8e8501.jpg"></p><p>网站访问成功! 我们去itdog Ping一下试试看</p><h2 id="Ping-测试"><a href="#Ping-测试" class="headerlink" title="Ping 测试"></a>Ping 测试</h2><p><img src="https://image.dooo.ng/i/2023/11/28/6565d0ff7ae80.jpg" alt="image-20231128193734518"></p><ul><li>可以看到我们的网址是经过csgo.com同款的Cloudflare ASN进行解析的</li><li>海外是通过 1.0.0.5 进行解析的</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>通过这种方法,我们可以实现几乎国内全绿<br>Cloudflare + SaaS还有很多玩法,自建Cloudflare节点等等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go windows环境下编译成 linux可执行文件</title>
    <link href="/article/7ec68bf.html"/>
    <url>/article/7ec68bf.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />cmd执行以下命令：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">GOARCH</span>=amd64<br>go env -w <span class="hljs-attribute">GOARCH</span>=amd64<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">GOOS</span>=linux<br>go env -w <span class="hljs-attribute">GOOS</span>=linux<br></code></pre></td></tr></table></figure><p>go build -o myapp [<a href="https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E5%90%8D&spm=1001.2101.3001.7020">文件名</a>]</p><p>然后go build [文件名]，编译好的程序放到linux环境下</p><p>chmod 777 [文件名] 给权限，执行即可</p><p>再切换回windows</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">go env -w <span class="hljs-attribute">GOARCH</span>=amd64<br>go env -w <span class="hljs-attribute">GOOS</span>=windows<br></code></pre></td></tr></table></figure><p>又可以愉快的编译exe<a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">可执行文件</a>啦</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title> golang下划线的三种用法</title>
    <link href="/article/ea4c3f0f.html"/>
    <url>/article/ea4c3f0f.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />## 1\. 忽略返回值<blockquote><p>某个函数返回三个参数，但是我们只需要其中的两个，另外一个参数可以忽略</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">v1, v2, <span class="hljs-attr">_</span> := <span class="hljs-keyword">function</span>(<span class="hljs-params">...</span>)<br></code></pre></td></tr></table></figure><h2 id="2-用在-import-package"><a href="#2-用在-import-package" class="headerlink" title="2. 用在 import package"></a>2. 用在 import package</h2><blockquote><p>自动调用导入包的 init() 进行初始化，而不使用包中其他功能。</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> <span class="hljs-literal">_</span> <span class="hljs-string">&quot;test/foo&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>        <span class="hljs-string">&quot;fmt&quot;</span><br>        _ <span class="hljs-string">&quot;test/foo&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;hello world\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">init</span> foo <span class="hljs-built_in">object</span>: &amp;&#123;<span class="hljs-number">123</span> abc&#125;<br>hello world<br></code></pre></td></tr></table></figure><h2 id="3-变量断言"><a href="#3-变量断言" class="headerlink" title="3. 变量断言"></a>3. 变量断言</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elm">// 定义了一个接口<br><span class="hljs-keyword">type</span> <span class="hljs-type">Foo</span> interface &#123;<br>     <span class="hljs-type">Say</span>()<br>&#125;<br><br>// 结构体<br><span class="hljs-keyword">type</span> <span class="hljs-type">Dog</span> struct &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果Dog没有实现Foo，则会报编译错误</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> <span class="hljs-literal">_</span> Foo = Dog&#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS code中go的import失败、标红等问题</title>
    <link href="/article/71087366.html"/>
    <url>/article/71087366.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />属实有些烦<h1 id="导入官方库失败"><a href="#导入官方库失败" class="headerlink" title="导入官方库失败"></a>导入官方库失败</h1><p>查看一下<code>GOROOT</code>的配置是不是Go的安装目录</p><h1 id="导入第三方库失败"><a href="#导入第三方库失败" class="headerlink" title="导入第三方库失败"></a>导入第三方库失败</h1><p>在vscode中安装完go语言扩展插件后，会提示安装<code>gopls</code>（go please）。如果自动安装不了，可以手动使用go install 安装。</p><p>如果安装完gopls后，导入包还存在问题，大意是找不到<code>%GOPATH%\src\XXX</code>,那么可以检查一下：</p><ol><li>vscode的workspace，不要一下子打开整个GOPATH文件夹，而是打开GOPATH下单个项目的文件夹，错误提示应该就会消失。</li><li>设置go env的全局变量<code>go env -w GO111MODULE=on</code>, 重启vscode</li></ol><p>参考链接：<a href="https://stackoverflow.com/questions/58518588/vscode-could-not-import-golang-package">https://stackoverflow.com/questions/58518588/vscode-could-not-import-golang-package</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yml纯数字配置读取失败</title>
    <link href="/article/ffa963ad.html"/>
    <url>/article/ffa963ad.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />项目中碰到一个诡异问题，yml文件中配置了一个值为[字符串](https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020 "字符串")的属性（010112156），用@Value注入时确发现不对应，出现了全项目中都找不到的值。研究了半天才发现，yml会把0开头的数字作为8进制对待，注入时转化为十进制注入<p>例如</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/671fa7ddb76deb87403e7f2f8450701c.png"></p><p> 读取到的数值会变成555.0<br>正确配置</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/049c0c5970f91147ca33b4799e425953.png"></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud项目无法读取bootstrap.yml配置文件的解决办法</title>
    <link href="/article/c796e17b.html"/>
    <url>/article/c796e17b.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />### 问题描述<p>在使用spring clouod 2021.0.0，发现对接<a href="https://so.csdn.net/so/search?q=nacos%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83&spm=1001.2101.3001.7020">nacos配置中心</a>的时候，一直无法读取到bootstarp的配置信息。</p><h3 id="问题细究"><a href="#问题细究" class="headerlink" title="问题细究"></a>问题细究</h3><p>网上搜了一下，从Spring Boot 2.4版本开始，配置文件加载方式进行了重构。</p><p>spring cloud2.4之前的源码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package org.springframework.cloud.bootstrap;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BootstrapApplicationListener</span> <span class="hljs-title">implements</span> <span class="hljs-title">ApplicationListener</span>&lt;<span class="hljs-title">ApplicationEnvironmentPreparedEvent</span>&gt;, <span class="hljs-title">Ordered</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span>(<span class="hljs-params">ApplicationEnvironmentPreparedEvent <span class="hljs-keyword">event</span></span>)</span> &#123;        ConfigurableEnvironment environment = <span class="hljs-keyword">event</span>.getEnvironment();        <span class="hljs-keyword">if</span> ((Boolean)environment.getProperty(<span class="hljs-string">&quot;spring.cloud.bootstrap.enabled&quot;</span>, Boolean.<span class="hljs-keyword">class</span>, <span class="hljs-literal">true</span>)) &#123;        &#125;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>spring cloud2.4之后的源码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">package</span> org.springframework.cloud.util;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> PropertyUtils &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> bootstrapEnabled(Environment environment) &#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">Boolean</span>)environment.getProperty(<span class="hljs-string">&quot;spring.cloud.bootstrap.enabled&quot;</span>, <span class="hljs-keyword">Boolean</span>.<span class="hljs-keyword">class</span>, <span class="hljs-keyword">false</span>) || MARKER_CLASS_EXISTS;    &#125;&#125;<br></code></pre></td></tr></table></figure><p>对比之下，能看出问题，在spring cloud2.4之后将bootstrap.enabled设置为false。</p><h3 id="解决方式一："><a href="#解决方式一：" class="headerlink" title="解决方式一："></a>解决方式一：</h3><p>添加bootstrap的POM依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 自行修改相应版本--&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="解决方式二："><a href="#解决方式二：" class="headerlink" title="解决方式二："></a>解决方式二：</h3><p>添加环境变量：</p><p>spring.cloud.bootstrap.enabled&#x3D;true </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7ebbf16770e3420a6b64acf124399cc3.png"></p><p><strong>特殊说明：</strong>如果你不是spring cloud项目，只是spring boot项目，在启动无法加载到bootstrap的配置，应该为如下解决方式：</p><p>添加spring-cloud-context的POM依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMq集群</title>
    <link href="/article/28af8ecc.html"/>
    <url>/article/28af8ecc.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />-   [RabbitMQ 如何做分布式](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#rabbitmq-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F)    -   [前言](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E5%89%8D%E8%A8%80)    -   [集群配置方案](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88)        -   [cluster](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#cluster)            -   [普通模式](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F)            -   [镜像模式](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F)        -   [federation](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#federation)        -   [shovel](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#shovel)    -   [节点类型](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B)        -   [RAM node](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#ram-node)        -   [Disk node](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#disk-node)    -   [集群的搭建](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA)        -   [1、局域网配置](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#1%E5%B1%80%E5%9F%9F%E7%BD%91%E9%85%8D%E7%BD%AE)        -   [2、每台及其中安装 RabbitMQ](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#2%E6%AF%8F%E5%8F%B0%E5%8F%8A%E5%85%B6%E4%B8%AD%E5%AE%89%E8%A3%85-rabbitmq)        -   [3、设置不同节点间同一认证的Erlang Cookie](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#3%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E9%97%B4%E5%90%8C%E4%B8%80%E8%AE%A4%E8%AF%81%E7%9A%84erlang-cookie)        -   [4、使用 -detached运行各节点](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#4%E4%BD%BF%E7%94%A8--detached%E8%BF%90%E8%A1%8C%E5%90%84%E8%8A%82%E7%82%B9)        -   [5、将节点加入到集群中](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#5%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD)        -   [6、查看集群状态](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#6%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81)    -   [参考](https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E5%8F%82%E8%80%83)<h2 id="RabbitMQ-如何做分布式"><a href="#RabbitMQ-如何做分布式" class="headerlink" title="RabbitMQ 如何做分布式"></a>RabbitMQ 如何做分布式<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#rabbitmq-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F"></a></h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E5%89%8D%E8%A8%80"></a></h3><p>前面几篇文章介绍了消息队列中遇到的问题，这篇来聊聊 RabbitMQ 的集群搭建。</p><h3 id="集群配置方案"><a href="#集群配置方案" class="headerlink" title="集群配置方案"></a>集群配置方案<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88"></a></h3><p>RabbitMQ 中集群的部署方案有三种 cluster,federation,shovel。</p><h4 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#cluster"></a></h4><p>cluster 有两种模式，分别是普通模式和镜像模式</p><p>cluster 的特点：</p><p>1、不支持跨网段，用于同一个网段内的局域网；</p><p>2、可以随意的动态增加或者减少；</p><p>3、节点之间需要运行相同版本的 RabbitMQ 和 Erlang 。</p><h5 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F"></a></h5><p>cluster 普通模式(默认的集群模式)，所有节点中的元数据是一致的，RabbitMQ 中的元数据会被复制到每一个节点上。</p><p>队列里面的数据只会存在创建它的节点上，其他节点除了存储元数据，还存储了指向 Queue 的主节点(owner node)的指针。</p><p>集群中节点之间没有主从节点之分。</p><p><img src="https://boilingfrog.github.io//img/mq/mq-rabbitmq-cluster.png" alt="mq"></p><p>举个栗子来说明下普通模式的消息传输：</p><p>假设我们 RabbitMQ 中有是三个节点，分别是 <code>node1,node2,node3</code>。如果队列 queue1 的连接创建发生在 node1 中，那么该队列的元数据会被同步到所有的节点中，但是 queue1 中的消息，只会在 node1 中。</p><ul><li>如果一个消费者通过 node2 连接，然后来消费 queue1 中的消息?</li></ul><p>RabbitMQ 会临时在 node1、node2 间进行消息传输，因为非 owner 节点除了存储元数据，还会存储指向 Queue 的主节点(owner node)的指针。RabbitMQ 会根据这个指向，把 node1 中的消息实体取出并经过 node2 发送给 consumer 。</p><ul><li>如果一个生产者通过 node2 连接，然后来向 queue1 中生产数据?</li></ul><p>同理，RabbitMQ 会根据 node2 中的主节点(owner node)的指针，把消息转发送给 owner 节点 node1,最后插入的数据还是在 node1 中。</p><p><img src="https://boilingfrog.github.io//img/mq/mq-rabbitmq-cluster-data.png" alt="mq"></p><p>同时对于队列的创建，要平均的落在每个节点上，如果只在一个节点上创建队列，所有的消费，最终都会落到这个节点上，会产生瓶颈。</p><p>存在的问题：</p><p>如果 node1 节点故障了，那么 node2 节点无法取出 node1 中还未消费的消息实体。</p><p>1、如果做了队列的持久化，消息不会被丢失，等到 node1 恢复了，就能接着进行消费，但是在恢复之前其他节点不能创建 node1 中已将创建的队列。</p><p>2、如果没有做持久化，消息会丢失，但是 node1 中的队列，可以在其他节点重新创建，不用等待 node1 的恢复。</p><p>普通模式不支持消息在每个节点上的复制，当然 RabbitMQ 中也提供了支持复制的模式，就是镜像模式(参见下文)。</p><h5 id="镜像模式"><a href="#镜像模式" class="headerlink" title="镜像模式"></a>镜像模式<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E9%95%9C%E5%83%8F%E6%A8%A1%E5%BC%8F"></a></h5><p>镜像队列会在节点中同步队列的数据，最终的队列数据会存在于每个节点中，而不像普通模式中只会存在于创建它的节点中。</p><p>优点很明显，当有主机宕机的时候，因为队列数据会同步到所有节点上，避免了普通模式中的单点故障。</p><p>缺点就是性能不好，集群内部的同步通讯会占用大量的网络带宽，适合一些可靠性要求比较高的场景。</p><p>针对镜像模式 RabbitMQ 也提供了几种模式，有效值为 <code>all，exactly，nodes</code> 默认为 all。</p><ul><li><p>all 表示集群中所有的节点进行镜像；</p></li><li><p>exactly 表示指定个数的节点上进行镜像，节点个数由<code>ha-params</code>指定;</p></li><li><p>nodes 表示在指定的节点上进行镜像，节点名称由<code>ha-params</code>指定;</p></li></ul><p>所以针对普通队列和镜像队列，我们可以选择其中几个队列作为镜像队列，在性能和可靠性之间找到一个平衡。</p><p>关于镜像模式中消息的复制，这里也用的很巧妙，值得借鉴</p><p>1、master 节点向 slave 节点同步消息是通过组播 GM(Guaranteed Multicast) 来同步的。</p><p>2、所有的消息经过 master 节点，master 对消息进行处理，同时也会通过 GM 广播给所有的 slave，slave收到消息之后在进行数据的同步操作。</p><p>3、GM 实现的是一种可靠的组播通信协议，该协议能保证组播消息的原子性。具体如何实现呢？</p><p>它的实现大致为:将所有的节点形成一个循环链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新的节点上 当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。</p><p>因为是一个循环链表，所以 master 发出去的消息最后也会返回到 master 中，master 如果收到了自己发出的操作命令，这时候就可以确定命令已经同步到了所有的节点。</p><p><img src="https://boilingfrog.github.io//img/mq/mq-rabbitmq-cluster-mirror.png" alt="mq"></p><h4 id="federation"><a href="#federation" class="headerlink" title="federation"></a>federation<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#federation"></a></h4><p>federation 插件的设计目标是使 RabbitMQ 在不同的 Broker 节点之间进行消息传递而无需建立集群。</p><p>看了定义还是很迷糊，来举举栗子吧</p><p>假设我们有一个 RabbitMQ 的集群，分别部署在不同的城市，那么我们假定分别是在北京，上海，广州。</p><p>![mq]<a href="https://boilingfrog.github.io/(/img/mq/mq-rabbitmq-federation.png)">https://boilingfrog.github.io/(/img/mq/mq-rabbitmq-federation.png)</a></p><p>如果一个现在有一个业务 clientA，部署的机器在北京，然后连接到北京节点的 broker1 。然后网络连通性也很好，发送消息到 broker1 中的 exchangeA 中，消息能够很快的发送到，就算在开启了 <code>publisher confirm</code> 机制或者事务机制的情况下，也能快速确认信息，这种情况下是没有问题的。</p><p>如果一个现在有一个业务 clientB，部署的机器在上海，然后连接到北京节点的 broker1 。然后网络连通性不好，发送消息到 broker1 中的 exchangeA 中，因为网络不好，所以消息的确认有一定的延迟，这对于我们无疑使灾难，消息量大情况下，必然造成数据的阻塞，在开启了 <code>publisher confirm</code> 机制或者事务机制的情况下，这种情况将会更严重。</p><p>当然如果把 clientB ，部署在北京的机房中，这个问题就解决了，但是多地容灾就不能实现了。</p><p>针对这种情况如何解决呢，这时候 federation 就登场了。</p><p>比如位于上海的业务 clientB，连接北京节点的 broker1。然后发送消息到 broker1 中的 exchangeA 中。这时候是存在网络连通性的问题的。</p><ul><li><p>1、让上海的业务 clientB，连接上海的节点 broker2；</p></li><li><p>2、通过 Federation ，在北京节点的 broker1 和上海节点的 broker2 之间建立一条单向的 <code>Federation link</code>；</p></li><li><p>3、Federation 插件会在上海节点的 broker2 中创建一个同名的交换器 exchangeA (具体名字可配置，默认同名), 同时也会创建一个内部交换器，通过路由键 rkA ,将这两个交换器进行绑定，同时也会在 broker2 中创建一个</p><p>1、Federation 插件会在上海节点的 broker2 中创建一个同名的交换器 exchangeA (具体名字可配置，默认同名)；</p><p>2、Federation 插件会在上海节点的 broker2 中创建一个内部交换器，通过路由键 rkA ,将 exchangeA 和内部交换器进行绑定；</p><p>3、Federation 插件会在上海节点的 broker2 中创建队列，和内部交换器进行绑定，同时这个队列会和北京节点的 broker1 中的 exchangeA，建立一条 AMQP 链接，来实时的消费队列中的消息了；</p></li><li><p>4、经过上面的流程，就相当于在上海节点 broker2 中的 exchangeA 和北京节点 broker1 中的 exchangeA 建立了<code>Federation link</code>；</p></li></ul><p>这样位于上海的业务 clientB 链接到上海的节点 broker2，然后发送消息到该节点中的 exchangeA，这个消息会通过<code>Federation link</code>，发送到北京节点 broker1 中的 exchangeA，所以可以减少网络连通性的问题。</p><p><img src="https://boilingfrog.github.io//img/mq/mq-rabbitmq-federation-link.png" alt="mq"></p><h4 id="shovel"><a href="#shovel" class="headerlink" title="shovel"></a>shovel<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#shovel"></a></h4><p>连接方式与 federation 的连接方式类似，不过 shovel 工作更低一层。federation 是从一个交换器中转发消息到另一个交换器中，而 shovel 只是简单的从某个 broker 中的队列中消费数据，然后转发消息到另一个 broker 上的交换器中。</p><p>shovel 主要是：保证可靠连续地将 message 从某个 broker 上的 queue （作为源端）中取出，再将其 publish 到另外一个 broker 中的相应 exchange 上（作为目的端）。</p><p>作为源的 queue 和作为目的的 exchange 可以同时位于一个 broker 上，也可以位于不同 broker 上。Shovel 行为就像优秀的客户端应用程序能够负责连接源和目的地、负责消息的读写及负责连接失败问题的处理。</p><p>Shovel 的主要优势在于：</p><p>1、松藕合：Shovel 可以移动位于不同管理域中的 Broker (或者集群)上的消息，这些 Broker (或者集群〉可以包含不同的用户和 vhost ，也可以使用不同的 RabbitMQ 和 Erlang 版本；</p><p>2、支持广域网：Shovel 插件同样基于 AMQP 协议 Broker 之间进行通信 被设计成可以容忍时断时续的连通情形 井且能够保证消息的可靠性；</p><p>3、高度定制：当 Shove 成功连接后，可以对其进行配置以执行相关的 AMQP 命令。</p><p>使用 Shove 解决消息堆积</p><p>对于消息堆积，如果消息堆积的数量巨大时，消息队列的性能将严重收到影响，通常的做法是增加消费者的数量或者优化消费者来处理</p><p>如果一些消息堆积场景不能简单的增加消费者的数量来解决，就只能优化消费者的消费能力了，但是优化毕竟需要时间，这时候可以通过 Shove 解决</p><p>可以通过 Shove 将阻塞的消息，移交给另一个备份队列，等到本队列的消息没有阻塞了，然后将备份队列中的消息重新’铲’过来</p><p><img src="https://boilingfrog.github.io//img/mq/mq-rabbitmq-cluster-shove.png" alt="mq"></p><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B"></a></h3><h4 id="RAM-node"><a href="#RAM-node" class="headerlink" title="RAM node"></a>RAM node<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#ram-node"></a></h4><p>内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。</p><h4 id="Disk-node"><a href="#Disk-node" class="headerlink" title="Disk node"></a>Disk node<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#disk-node"></a></h4><p>元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启RabbitMQ的时候，丢失系统的配置信息</p><p>RabbitMQ要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。</p><p>如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。针对这种情况可以设置两个磁盘节点、至少保证一个是可用的，就能保证元数据的修改了。</p><p>看了很多文章，有的地方会认为所有持久化的消息都会存储到磁盘节点中，这是不正确的。对于内存节点，如果消息进行了持久化的操作，持久化的消息会存储在该节点中的磁盘中，而不是磁盘节点的磁盘中。</p><p>来个栗子：</p><p>这里构建了一个普通的 cluster 集群(见下文)，选择其中的一个内存节点，推送消息到该节点中，并且每条消息都选择持久化，来看下，这个节点的内存变化</p><p>来看下没有消息时，节点中的内存占用</p><p><img src="https://boilingfrog.github.io//img/mq/rabbitmq-cluster-data-empty.jpg" alt="mq"></p><p>这里向<code>rabbitmqcluster1</code>推送了 397330 条消息，发现磁盘内存从原来的 6.1GiB 变成了 3.9GiB，而磁盘节点的内存没有变化</p><p><img src="https://boilingfrog.github.io//img/mq/rabbitmq-cluster-data.jpg" alt="mq"></p><p>对于内存节点，如果消息进行了持久化的操作，持久化的消息会存储在该节点中的磁盘中，而不是磁盘节点的磁盘中。</p><h3 id="集群的搭建"><a href="#集群的搭建" class="headerlink" title="集群的搭建"></a>集群的搭建<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E9%9B%86%E7%BE%A4%E7%9A%84%E6%90%AD%E5%BB%BA"></a></h3><p>这是搭建一个普通的 cluster 模式,使用 vagrant 构建三台 centos7 虚拟机，<a href="https://www.cnblogs.com/ricklz/p/14724934.html">vagrant构建centos虚拟环境</a></p><h4 id="1、局域网配置"><a href="#1、局域网配置" class="headerlink" title="1、局域网配置"></a>1、局域网配置<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#1%E5%B1%80%E5%9F%9F%E7%BD%91%E9%85%8D%E7%BD%AE"></a></h4><p>首先配置 hostname</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$ <span class="hljs-string">hostnamectl</span> <span class="hljs-built_in">set-hostname</span> <span class="hljs-string">rabbitmqcluster1</span> <span class="hljs-built_in">--static</span><br></code></pre></td></tr></table></figure><p>重启即可查看最新的 hostname</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">$ hostnamectl</span><br><span class="hljs-attribute">   Static hostname</span><span class="hljs-punctuation">:</span> <span class="hljs-string">rabbitmqcluster1</span><br>         <span class="hljs-attribute">Icon name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">computer-vm</span><br>           <span class="hljs-attribute">Chassis</span><span class="hljs-punctuation">:</span> <span class="hljs-string">vm</span><br>        <span class="hljs-attribute">Machine ID</span><span class="hljs-punctuation">:</span> <span class="hljs-string">e147b422673549a3b4fda77127bd4bcd</span><br>           <span class="hljs-attribute">Boot ID</span><span class="hljs-punctuation">:</span> <span class="hljs-string">aa195e0427d74d079ea39f344719f59b</span><br>    <span class="hljs-attribute">Virtualization</span><span class="hljs-punctuation">:</span> <span class="hljs-string">oracle</span><br>  <span class="hljs-attribute">Operating System</span><span class="hljs-punctuation">:</span> <span class="hljs-string">CentOS Linux 7 (Core)</span><br>       <span class="hljs-attribute">CPE OS Name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">cpe:/o:centos:centos:7</span><br>            <span class="hljs-attribute">Kernel</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Linux 3.10.0-327.4.5.el7.x86_64</span><br>      <span class="hljs-attribute">Architecture</span><span class="hljs-punctuation">:</span> <span class="hljs-string">x86-64</span><br></code></pre></td></tr></table></figure><p>然后在三个节点的<code>/etc/hosts</code>下设置相同的配置信息</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">192.168.56.111</span> rabbitmqcluster1<br><span class="hljs-number">192.168.56.112</span> rabbitmqcluster2<br><span class="hljs-number">192.168.56.113</span> rabbitmqcluster3<br></code></pre></td></tr></table></figure><h4 id="2、每台及其中安装-RabbitMQ"><a href="#2、每台及其中安装-RabbitMQ" class="headerlink" title="2、每台及其中安装 RabbitMQ"></a>2、每台及其中安装 RabbitMQ<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#2%E6%AF%8F%E5%8F%B0%E5%8F%8A%E5%85%B6%E4%B8%AD%E5%AE%89%E8%A3%85-rabbitmq"></a></h4><p>具体的安装过程可参见<a href="https://blog.csdn.net/weixin_40584261/article/details/106826044">Centos7安装RabbitMQ最新版3.8.5，史上最简单实用安装步骤</a></p><h4 id="3、设置不同节点间同一认证的Erlang-Cookie"><a href="#3、设置不同节点间同一认证的Erlang-Cookie" class="headerlink" title="3、设置不同节点间同一认证的Erlang Cookie"></a>3、设置不同节点间同一认证的Erlang Cookie<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#3%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E8%8A%82%E7%82%B9%E9%97%B4%E5%90%8C%E4%B8%80%E8%AE%A4%E8%AF%81%E7%9A%84erlang-cookie"></a></h4><p>每台机器中安装 RabbitMQ ,都会生成单独的<code>Erlang Cookie</code>。<code>Erlang Cookie</code>是保证不同节点可以相互通信的密钥，要保证集群中的不同节点相互通信必须共享相同的<code>Erlang Cookie</code>。具体的目录存放在<code>/var/lib/rabbitmq/.erlang.cookie</code>。</p><p>所以这里把 <code>rabbitmqcluster1</code> 中的<code>Erlang Cookie</code>，复制到其他机器中，覆盖原来的<code>Erlang Cookie</code>。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>scp /var/lib/rabbitmq/.erlang.cookie <span class="hljs-number">192.168</span>.<span class="hljs-number">56.112</span><span class="hljs-symbol">:/var/lib/rabbitmq</span><br><span class="hljs-variable">$ </span>scp /var/lib/rabbitmq/.erlang.cookie <span class="hljs-number">192.168</span>.<span class="hljs-number">56.113</span><span class="hljs-symbol">:/var/lib/rabbitmq</span><br></code></pre></td></tr></table></figure><p>复制<code>Erlang Cookie</code>之后重启 rabbitmq</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ systemctl <span class="hljs-keyword">restart</span> rabbitmq-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><h4 id="4、使用-detached运行各节点"><a href="#4、使用-detached运行各节点" class="headerlink" title="4、使用 -detached运行各节点"></a>4、使用 -detached运行各节点<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#4%E4%BD%BF%E7%94%A8--detached%E8%BF%90%E8%A1%8C%E5%90%84%E8%8A%82%E7%82%B9"></a></h4><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbscript">rabbitmqctl <span class="hljs-keyword">stop</span><br>rabbitmq-<span class="hljs-built_in">server</span> -detached <br></code></pre></td></tr></table></figure><h4 id="5、将节点加入到集群中"><a href="#5、将节点加入到集群中" class="headerlink" title="5、将节点加入到集群中"></a>5、将节点加入到集群中<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#5%E5%B0%86%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5%E5%88%B0%E9%9B%86%E7%BE%A4%E4%B8%AD"></a></h4><p>在 <code>rabbitmqcluster2</code> 和 <code>rabbitmqcluster3</code> 中执行</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rabbitmqctl stop_app<br><span class="hljs-variable">$ </span>rabbitmqctl join_cluster rabbit<span class="hljs-variable">@rabbitmqcluster1</span><br><span class="hljs-variable">$ </span>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><p>默认 rabbitmq 启动后是磁盘节点，所以可以看到集群启动之后，节点类型都是磁盘类型</p><p><img src="https://boilingfrog.github.io//img/mq/rabbitmq-cluster-disc.jpg" alt="mq"></p><p>一般添加1到2个磁盘节点，别的节点节点为内存节点，这里我们将 <code>rabbitmqcluster3</code> 设置成磁盘节点，其他节点设置成内存节点</p><p>修改 <code>rabbitmqcluster1</code> 和 <code>rabbitmqcluster2</code> 节点类型为内存节点</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rabbitmqctl stop_app<br><span class="hljs-variable">$ </span>rabbitmqctl change_cluster_node_type ram<br><span class="hljs-variable">$ </span>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><p><img src="https://boilingfrog.github.io//img/mq/rabbitmq-cluster-ram.jpg" alt="mq"></p><h4 id="6、查看集群状态"><a href="#6、查看集群状态" class="headerlink" title="6、查看集群状态"></a>6、查看集群状态<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#6%E6%9F%A5%E7%9C%8B%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81"></a></h4><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>rabbitmqctl cluster_status<br></code></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考<a href="https://boilingfrog.github.io/2022/01/07/rabbitmq%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F/#%E5%8F%82%E8%80%83"></a></h3><p>【RabbitMQ分布式集群架构和高可用性（HA）】<a href="http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/">http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/</a><br>【RabbitMQ分布式部署方案简介】<a href="https://www.jianshu.com/p/c7a1a63b745d">https://www.jianshu.com/p/c7a1a63b745d</a><br>【RabbitMQ实战指南】<a href="https://book.douban.com/subject/27591386/">https://book.douban.com/subject/27591386/</a><br>【RabbitMQ两种集群模式配置管理】<a href="https://blog.csdn.net/fgf00/article/details/79558498">https://blog.csdn.net/fgf00/article/details/79558498</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux 查看主机是否重启</title>
    <link href="/article/3eb81ee9.html"/>
    <url>/article/3eb81ee9.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />## 了解 Linux 重启日志<p>&#x2F;var&#x2F;log 目录隐藏着 Linux 日志机制的核心信息，它是记录系统活动的宝贵仓库。然而，仅仅有日志还不够，真正的难题在于，如何从大量数据中提炼出与系统重启相关的关键信息。</p><p>在 &#x2F;var&#x2F;log 目录中，可别错过那几个至关重要的家伙，如：wtmp 和 btmp。它们不仅是些普通的日志，更是了解 Linux 系统行为的途径。它们精细地记录着 Linux 重启日志，并同时会捕获详细的用户登录会话。透过这些文件，我们能够深入探究系统的活动，审视 Linux 的重启历史，以确保在决策和系统监管时能做到心中有数。</p><h3 id="方法-1：使用-last-命令查看-Linux-重启记录"><a href="#方法-1：使用-last-命令查看-Linux-重启记录" class="headerlink" title="方法 1：使用 last 命令查看 Linux 重启记录"></a>方法 1：使用 last 命令查看 Linux 重启记录</h3><p>last 命令是在 Linux 中获取重启历史记录的瑞士军刀，它能够读取 &#x2F;var&#x2F;log&#x2F;wtmp 文件，并显示最后登录用户和重启记录列表。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">last</span> reboot<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eee6a39e9866e3a36a37872721d3e723.png" alt="在这里插入图片描述"></p><p>该命令显示了重启的时间顺序列表，能够通过时间戳分析出系统的持续运行时间。</p><p>尽管基础的 last 命令提供了系统重启信息的全面概览，但有时我们可能需要更加详细或以不同格式呈现的输出，这时就需要用到自定义选项了。只查看特定数量的最近条目时，使用 <code>-n</code> 选项可以很方便地指定输出行数，让输出会变得更加精简和专注：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bed0b9cba06803809e4d28889f1f67e5.png" alt="在这里插入图片描述"></p><p>对于需要详细时间戳的用户来说，通过 <code>-F</code> 选项可以显示完整的日期和时间来增强输出，以提供每次重启实例的更全面视角：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">last</span> reboot -F<br></code></pre></td></tr></table></figure><p>通过执行这条命令，可以获得一个带有完整日期和时间格式的输出，以准确地辨别每次系统重启的准确时刻。</p><h2 id="方法-2：使用-uptime-命令查看-Linux-运行时间"><a href="#方法-2：使用-uptime-命令查看-Linux-运行时间" class="headerlink" title="方法 2：使用 uptime 命令查看 Linux 运行时间"></a>方法 2：使用 uptime 命令查看 Linux 运行时间</h2><p>虽然 uptime 命令简洁明了，但也能够提供有价值的信息。它能够输出自上次重启以来 Linux 的持续运行时间，为系统的稳定性和性能评估提供了数据依据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uptime</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ed2c260fc3609d2aec5f097c69bbd012.png" alt="在这里插入图片描述"><br>系统自上次重启以来已连续运行了 7 天 19 小时 24 分钟。</p><h2 id="方法-3：使用-journalctl-命令查看-Linux-重启历史记录"><a href="#方法-3：使用-journalctl-命令查看-Linux-重启历史记录" class="headerlink" title="方法 3：使用 journalctl 命令查看 Linux 重启历史记录"></a>方法 3：使用 journalctl 命令查看 Linux 重启历史记录</h2><p>对于使用 systemd 服务的 Linux 发行版来说，journalctl 命令提供了详细且经过筛选的日志视图，是获取 Linux 重启历史记录的得力工具：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo journalctl <span class="hljs-comment">--list-boots</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d8d8718dcd06e7f24f05dc80d8866d93.png" alt="在这里插入图片描述"></p><h2 id="方法-4：使用-who-b-命令查看-Linux-最后启动时间"><a href="#方法-4：使用-who-b-命令查看-Linux-最后启动时间" class="headerlink" title="方法 4：使用 who -b 命令查看 Linux 最后启动时间"></a>方法 4：使用 who -b 命令查看 Linux 最后启动时间</h2><p>另一种快速查看 Linux 系统（最后）重启时间的方法是使用带有 -b 选项的 who 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">who</span> -b<br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5c5295dc191fdd45dbb5c49651d3239d.png" alt="在这里插入图片描述"></p><p>上述命令可以输出 Linux 系统的最后启动或重启时间。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>容器异常退出</title>
    <link href="/article/cebefee3.html"/>
    <url>/article/cebefee3.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /># The node was low on resource: ephemeral-storage. Container kube-proxy was using 12Ki, which exceeds<p>启动kubernetes时候，发现kube-proxy无法启动，状态是Evicted。查看详情是：</p><p>The node was low on resource: ephemeral-storage. Container kube-proxy was using 12Ki, which exceeds its request of 0。</p><p>用df -h查看磁盘的使用空间，发现根目录占用85%，删除了一些后，发现可以正常启动了。</p><p>原因可能是根目录的磁盘空间不足，删除部分空间即可。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><blockquote><p>磁盘使用空间高于85%后，集群会在该节点打上污点<code>node.kubernetes.io/disk-pressure:NoSchedule</code>,并触发k8s节点驱逐pod策略，pod被驱逐后，当前节点pod处于停止状态，同时image处于未使用状态，因此删除image，导致image被删除。参考如下</p></blockquote><ul><li>驱逐Node级别资源<ul><li>配置了 imagefs 阈值时<ul><li>达到 nodefs 阈值：删除已停止的 Pod</li><li>达到 imagefs 阈值：删除未使用的镜像</li></ul></li><li>未配置 imagefs 阈值时<ul><li>达到 nodefs阈值时，按照删除已停止的 Pod 和删除未使用镜像的顺序清理资源</li></ul></li></ul></li><li>驱逐用户 Pod<ul><li>驱逐顺序为：BestEffort、Burstable、Guaranteed</li><li>配置了 imagefs 阈值时<ul><li>达到 nodefs 阈值，基于 nodefs 用量驱逐（local volume + logs）</li><li>达到 imagefs 阈值，基于 imagefs 用量驱逐（容器可写层）</li></ul></li><li>未配置 imagefs 阈值时<ul><li>达到 nodefs阈值时，按照总磁盘使用驱逐（local volume + logs + 容器可写层）</li></ul></li></ul></li></ul><hr><ul><li><code>image-gc-high-threshold</code>：磁盘使用率上限，有效范围[0-100],默认<code>85</code></li><li><code>image-gc-low-threshold</code>：磁盘使用率下限，有效范围[0-100],默认<code>80</code></li><li><code>minimum-image-ttl-duration</code>：镜像最短应该生存的年龄，默认为<code>2</code>分钟</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring Cloud gateway rest调用报错</title>
    <link href="/article/ee343eb6.html"/>
    <url>/article/ee343eb6.html</url>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有时候我们需要在spring cloud gateway中进行一些远程接口的调用，比如网关的<a href="https://so.csdn.net/so/search?q=%E9%89%B4%E6%9D%83&spm=1001.2101.3001.7020">鉴权</a>，需要调用rpc接口查询用户信息，如果直接调用feign接口，会出现如下报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalStateException</span>: <span class="hljs-built_in">block</span>()/<span class="hljs-built_in">blockFirst</span>()/<span class="hljs-built_in">blockLast</span>() are blocking, which is not supported <span class="hljs-keyword">in</span> thread reactor-http-nio-<span class="hljs-number">3</span>at reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span><span class="hljs-selector-class">.BlockingSingleSubscriber</span><span class="hljs-selector-class">.blockingGet</span>(BlockingSingleSubscriber<span class="hljs-selector-class">.java</span>:<span class="hljs-number">83</span>)Suppressed: reactor<span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.publisher</span>.FluxOnAssembly<span class="hljs-variable">$OnAssemblyException</span>: <br></code></pre></td></tr></table></figure><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>这是因为新版的 gateway 采用的是非阻塞式编程，但是在获取注册中心实例时，调用了block()方法阻塞式获取实例，只要你敢 block，就会</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">IllegalStateException(<span class="hljs-string">&quot;block()/blockFirst()/blockLast() are blocking, which is not supported in thread &quot;</span> + Thread.<span class="hljs-params">currentThread</span>()</span>.get<span class="hljs-constructor">Name()</span>);<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">public &lt;T&gt; ServiceInstance choose(<span class="hljs-built_in">String</span> serviceId, Request&lt;T&gt; request) &#123;        ReactiveLoadBalancer&lt;ServiceInstance&gt; loadBalancer = this.loadBalancerClientFactory.getInstance(serviceId);        <span class="hljs-keyword">if</span> (loadBalancer == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            Response&lt;ServiceInstance&gt; loadBalancerResponse = (Response)Mono.<span class="hljs-keyword">from</span>(loadBalancer.choose(request)).block();            <span class="hljs-keyword">return</span> loadBalancerResponse == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : (ServiceInstance)loadBalancerResponse.getServer();        &#125;    &#125; final T blockingGet() &#123;<span class="hljs-keyword">if</span> (Schedulers.isInNonBlockingThread()) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;block()/blockFirst()/blockLast() are blocking, which is not supported in thread &quot;</span> + Thread.currentThread().getName());&#125;<span class="hljs-keyword">if</span> (getCount() != <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">try</span> &#123;<span class="hljs-keyword">await</span>();&#125;<span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;dispose();<span class="hljs-keyword">throw</span> Exceptions.propagate(ex);&#125;&#125; Throwable e = error;<span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;RuntimeException re = Exceptions.propagate(e);//this <span class="hljs-keyword">is</span> ok, <span class="hljs-keyword">as</span> re <span class="hljs-keyword">is</span> always a <span class="hljs-keyword">new</span> non-singleton instancere.addSuppressed(<span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;#block terminated with an error&quot;</span>));<span class="hljs-keyword">throw</span> re;&#125;<span class="hljs-keyword">return</span> value;&#125;<br></code></pre></td></tr></table></figure><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>问题找到了，解决起来就简单了，我们只需要重写获取实例的方法就好了，上代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript">    @&lt;!-- toc --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-referrer&quot;</span> /&gt;</span></span><br><span class="hljs-title class_">Bean</span> <span class="hljs-keyword">public</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span> <span class="hljs-title function_">blockingLoadBalancerClient</span>(<span class="hljs-params">ReactiveLoadBalancer.Factory &lt; ServiceInstance &gt; loadBalancerClientFactory, DiscoveryClient discoveryClient</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingLoadBalancerClient</span>(loadBalancerClientFactory) &#123;@<br>          <span class="hljs-title class_">Override</span> <span class="hljs-keyword">public</span> &lt; T &gt; <span class="hljs-title class_">ServiceInstance</span> <span class="hljs-title function_">choose</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> serviceId, Request &lt; T &gt; request</span>) &#123;<br>              <span class="hljs-title class_">List</span> &lt; <span class="hljs-title class_">ServiceInstance</span> &gt; instanceList = discoveryClient.<span class="hljs-title function_">getInstances</span>(serviceId);<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">loadBalancerInstance</span>(instanceList);<br>          &#125;<br>      &#125;;<br>  &#125;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">ServiceInstance</span> <span class="hljs-title function_">loadBalancerInstance</span>(<span class="hljs-params">List &lt; ServiceInstance &gt; instanceList</span>) &#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-title class_">CollUtil</span>.<span class="hljs-title function_">isEmpty</span>(instanceList)) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (instanceList.<span class="hljs-title function_">size</span>() == <span class="hljs-number">1</span>) &#123;<br>              <span class="hljs-keyword">return</span> instanceList.<span class="hljs-title function_">get</span>(<span class="hljs-number">0</span>);<br>          &#125; <span class="hljs-comment">// 随机负载        int index = RandomUtil.randomInt(0, instanceList.size());        return instanceList.get(index);    &#125;</span><br></code></pre></td></tr></table></figure><p>这里的负载均衡是随机负载的，各位可以根据自己的机器数量，设置不同的负载均衡策略（我这生产其实只有一个节点，负载不负载无所谓）</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DrissionPage学习</title>
    <link href="/article/c8098d99.html"/>
    <url>/article/c8098d99.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /># DrissionPage学习<p>官网：<a href="http://drissionpage.cn/features/intimate/">http://drissionpage.cn/features/intimate/</a></p><p><a href="https://blog.csdn.net/weixin_43936332/article/details/135977426">自动化测试框架：DrissionPage</a></p><h2 id="1-DrissionPage事件"><a href="#1-DrissionPage事件" class="headerlink" title="1.DrissionPage事件"></a>1.DrissionPage事件</h2><h3 id="1-1元素定位查找"><a href="#1-1元素定位查找" class="headerlink" title="1.1元素定位查找"></a>1.1元素定位查找</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 根据属性查找，@ 后面可跟任意属性<br>page.ele(<span class="hljs-string">&#x27;@id:ele_id&#x27;</span>, timeout=<span class="hljs-number">2</span>)  # 查找 id 为 ele_id 的元素，设置等待时间<span class="hljs-number">2</span>秒  <br>page.eles(<span class="hljs-string">&#x27;@class&#x27;</span>)  # 查找所有拥有 <span class="hljs-keyword">class</span> 属性的元素<br>page.eles(<span class="hljs-string">&#x27;@class:class_name&#x27;</span>)  # 查找所有 <span class="hljs-keyword">class</span> 含有 ele_class 的元素 <br>page.eles(<span class="hljs-string">&#x27;@class=class_name&#x27;</span>)  # 查找所有 <span class="hljs-keyword">class</span> 等于 ele_class 的元素 <br> <br># 根据 <span class="hljs-keyword">class</span> 或 id 查找<br>page.ele(<span class="hljs-string">&#x27;#ele_id&#x27;</span>)  # 等价于 page.ele(<span class="hljs-string">&#x27;@id=ele_id&#x27;</span>)<br>page.ele(<span class="hljs-string">&#x27;#:ele_id&#x27;</span>)  # 等价于 page.ele(<span class="hljs-string">&#x27;@id:ele_id&#x27;</span>)<br>page.ele(<span class="hljs-string">&#x27;.ele_class&#x27;</span>)  # 等价于 page.ele(<span class="hljs-string">&#x27;@class=ele_class&#x27;</span>)<br>page.ele(<span class="hljs-string">&#x27;.:ele_class&#x27;</span>)  # 等价于 page.ele(<span class="hljs-string">&#x27;@class:ele_class&#x27;</span>)<br> <br># 根据 tag name 查找<br>page.ele(<span class="hljs-string">&#x27;tag:li&#x27;</span>)  # 查找第一个 li 元素  <br>page.eles(<span class="hljs-string">&#x27;tag:li&#x27;</span>)  # 查找所有 li 元素  <br> <br># 根据 tag name 及属性查找<br>page.ele(<span class="hljs-string">&#x27;tag:div@class=div_class&#x27;</span>)  # 查找 <span class="hljs-keyword">class</span> 为 div_class 的 div 元素<br>page.ele(<span class="hljs-string">&#x27;tag:div@class:ele_class&#x27;</span>) # 查找 <span class="hljs-keyword">class</span> 含有 ele_class 的 div 元素<br>page.ele(<span class="hljs-string">&#x27;tag:div@class=ele_class&#x27;</span>) # 查找 <span class="hljs-keyword">class</span> 等于 ele_class 的 div 元素<br>page.ele(<span class="hljs-string">&#x27;tag:div@text():search_text&#x27;</span>) # 查找文本含有 search_text 的 div 元素<br>page.ele(<span class="hljs-string">&#x27;tag:div@text()=search_text&#x27;</span>) # 查找文本等于 search_text 的 div 元素<br> <br># 根据文本内容查找<br>page.ele(<span class="hljs-string">&#x27;search text&#x27;</span>)  # 查找包含传入文本的元素  <br>page.eles(<span class="hljs-string">&#x27;text:search text&#x27;</span>)  # 如文本以 @、tag:、css:、xpath:、text: 开头，则应在前加上 text: 避免冲突  <br>page.eles(<span class="hljs-string">&#x27;text=search text&#x27;</span>)  # 文本等于 search_text 的元素<br> <br># 根据 xpath 或 css selector 查找<br>page.eles(<span class="hljs-string">&#x27;xpath://div[@class=&quot;ele_class&quot;]&#x27;</span>)  <br>page.eles(<span class="hljs-string">&#x27;css:div.ele_class&#x27;</span>)  <br> <br># 根据 loc 查找<br>loc1 = By.ID, <span class="hljs-string">&#x27;ele_id&#x27;</span><br>loc2 = By.XPATH, <span class="hljs-string">&#x27;//div[@class=&quot;ele_class&quot;]&#x27;</span><br>page.ele(loc1)<br>page.ele(loc2)<br> <br># 查找下级元素<br>element = page.ele(<span class="hljs-string">&#x27;@id:ele_id&#x27;</span>)<br>element.ele(<span class="hljs-string">&#x27;@class:class_name&#x27;</span>)  # 在 element 下级查找第一个 <span class="hljs-keyword">class</span> 为 ele_class 的元素<br>element.eles(<span class="hljs-string">&#x27;tag:li&#x27;</span>)  # 在 ele_id 下级查找所有li元素<br> <br># 根据位置查找<br>element.parent  # 父元素  <br>element.next  # 下一个兄弟元素  <br>element.prev  # 上一个兄弟元素  <br> <br># 获取 shadow-root，把它作为元素对待。只支持 open 的 shadow-root<br>ele1 = element.shadow_root.ele(<span class="hljs-string">&#x27;tag:div&#x27;</span>)<br> <br># 串连查找<br>page.ele(<span class="hljs-string">&#x27;@id:ele_id&#x27;</span>).ele(<span class="hljs-string">&#x27;tag:div&#x27;</span>).next.ele(<span class="hljs-string">&#x27;some text&#x27;</span>).eles(<span class="hljs-string">&#x27;tag:a&#x27;</span>)<br> <br># 简化写法<br>eles = page(<span class="hljs-string">&#x27;@id:ele_id&#x27;</span>)(<span class="hljs-string">&#x27;tag:div&#x27;</span>).next(<span class="hljs-string">&#x27;some text&#x27;</span>).eles(<span class="hljs-string">&#x27;tag:a&#x27;</span>)<br>ele2 = ele1(<span class="hljs-string">&#x27;tag:li&#x27;</span>).next(<span class="hljs-string">&#x27;some text&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="1-2元素操作"><a href="#1-2元素操作" class="headerlink" title="1.2元素操作"></a>1.2元素操作</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">element</span>.click(by_js)  <span class="hljs-comment"># 点击元素，可选择是否用 js 方式点击</span><br><span class="hljs-keyword">element</span>.input(<span class="hljs-built_in">value</span>)  <span class="hljs-comment"># 输入文本</span><br><span class="hljs-keyword">element</span>.run_script(js)  <span class="hljs-comment"># 对元素运行 JavaScript 脚本</span><br><span class="hljs-keyword">element</span>.submit()  <span class="hljs-comment"># 提交</span><br><span class="hljs-keyword">element</span>.<span class="hljs-built_in">clear</span>()  <span class="hljs-comment"># 清空元素</span><br><span class="hljs-keyword">element</span>.screenshot(path, filename)  <span class="hljs-comment"># 对元素截图</span><br><span class="hljs-keyword">element</span>.select(<span class="hljs-keyword">text</span>)  <span class="hljs-comment"># 根据文本选择下拉列表</span><br><span class="hljs-keyword">element</span>.set_attr(attr, <span class="hljs-built_in">value</span>)  <span class="hljs-comment"># 设置元素属性值</span><br><span class="hljs-keyword">element</span>.remove_attr(attr)  <span class="hljs-comment"># 删除属性</span><br><span class="hljs-keyword">element</span>.drag(x, y, speed, shake)  <span class="hljs-comment"># 拖动元素相对距离，可设置速度和是否随机抖动</span><br><span class="hljs-keyword">element</span>.drag_to(ele_or_loc, speed, shake)  <span class="hljs-comment"># 拖动元素到另一个元素或某个坐标，可设置速度和是否随机抖动</span><br><span class="hljs-keyword">element</span>.hover()  <span class="hljs-comment"># 在元素上悬停鼠标</span><br></code></pre></td></tr></table></figure><h3 id="1-3获取元素属性"><a href="#1-3获取元素属性" class="headerlink" title="1.3获取元素属性"></a>1.3获取元素属性</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">element</span>.html  <span class="hljs-comment"># 返回元素 outerHTML</span><br><span class="hljs-keyword">element</span>.inner_html  <span class="hljs-comment"># 返回元素 innerHTML</span><br><span class="hljs-keyword">element</span>.tag  <span class="hljs-comment"># 返回元素 tag name</span><br><span class="hljs-keyword">element</span>.<span class="hljs-keyword">text</span>  <span class="hljs-comment"># 返回元素 innerText 值</span><br><span class="hljs-keyword">element</span>.comments  <span class="hljs-comment"># 返回元素内注释列表</span><br><span class="hljs-keyword">element</span>.link  <span class="hljs-comment"># 返回元素 href 或 src 绝对 url</span><br><span class="hljs-keyword">element</span>.texts()  <span class="hljs-comment"># 返回元素内所有直接子节点的文本，包括元素和文本节点，可指定只返回文本节点</span><br><span class="hljs-keyword">element</span>.attrs  <span class="hljs-comment"># 返回元素所有属性的字典</span><br><span class="hljs-keyword">element</span>.attr(attr)  <span class="hljs-comment"># 返回元素指定属性的值</span><br><span class="hljs-keyword">element</span>.css_path  <span class="hljs-comment"># 返回元素绝对 css 路径</span><br><span class="hljs-keyword">element</span>.xpath  <span class="hljs-comment"># 返回元素绝对 xpath 路径</span><br><span class="hljs-keyword">element</span>.parent  <span class="hljs-comment"># 返回元素父元素</span><br><span class="hljs-keyword">element</span>.next  <span class="hljs-comment"># 返回元素后一个兄弟元素</span><br><span class="hljs-keyword">element</span>.prev  <span class="hljs-comment"># 返回元素前一个兄弟元素</span><br><span class="hljs-keyword">element</span>.parents(<span class="hljs-built_in">num</span>)  <span class="hljs-comment"># 返回第 num 级父元素</span><br><span class="hljs-keyword">element</span>.nexts(<span class="hljs-built_in">num</span>, mode)  <span class="hljs-comment"># 返回后面第几个元素或节点</span><br><span class="hljs-keyword">element</span>.prevs(<span class="hljs-built_in">num</span>, mode)  <span class="hljs-comment"># 返回前面第几个元素或节点</span><br><span class="hljs-keyword">element</span>.ele(loc_or_str, timeout)  <span class="hljs-comment"># 返回当前元素下级第一个符合条件的子元素、属性或节点文本</span><br><span class="hljs-keyword">element</span>.eles(loc_or_str, timeout)  <span class="hljs-comment"># 返回当前元素下级所有符合条件的子元素、属性或节点文本</span><br></code></pre></td></tr></table></figure><h2 id="2-DrissionPage基本使用"><a href="#2-DrissionPage基本使用" class="headerlink" title="2.DrissionPage基本使用"></a>2.DrissionPage基本使用</h2><h3 id="2-1控制浏览器，导入ChromiumPage："><a href="#2-1控制浏览器，导入ChromiumPage：" class="headerlink" title="2.1控制浏览器，导入ChromiumPage："></a><strong>2.1控制浏览器，导入<code>ChromiumPage</code>：</strong></h3><blockquote><p>from DrissionPage import ChromiumPage</p></blockquote><h4 id="2-1-1-示例代码1："><a href="#2-1-1-示例代码1：" class="headerlink" title="2.1.1 示例代码1："></a>2.1.1 示例代码1：</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nsis">from DrissionPage import ChromiumPage<br> <br><span class="hljs-comment"># 创建页面对象，并启动或接管浏览器</span><br><span class="hljs-keyword">page</span> = ChromiumPage()<br><span class="hljs-comment"># 跳转到登录页面</span><br><span class="hljs-keyword">page</span>.get(<span class="hljs-string">&#x27;https://gitee.com/login&#x27;</span>)    <span class="hljs-comment"># get()方法用于访问参数中的网址。它会等待页面完全加载，再继续执行后面的代码。</span><br> <br><span class="hljs-comment"># 定位到账号文本框</span><br>ele = <span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;#user_login&#x27;</span>)    <span class="hljs-comment"># ele()方法用于查找元素,&#x27;#user_login&#x27;是定位符文本，#意思是按id属性查找元素。ele()内置了等待，如果元素未加载，它会执行等待，直到元素出现或到达时限。默认超时时间 10 秒。</span><br> <br><span class="hljs-comment"># 输入对文本框输入账号</span><br>ele.input(<span class="hljs-string">&#x27;账号&#x27;</span>)<br><span class="hljs-comment"># 定位到密码文本框并输入密码</span><br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;#user_password&#x27;</span>).input(<span class="hljs-string">&#x27;密码&#x27;</span>)<br><span class="hljs-comment"># 点击登录按钮</span><br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;@value=登 录&#x27;</span>).click()    <span class="hljs-comment"># @表示按属性名查找</span><br><br></code></pre></td></tr></table></figure><h4 id="2-1-2示例代码2-Recorder是追加写入-："><a href="#2-1-2示例代码2-Recorder是追加写入-：" class="headerlink" title="2.1.2示例代码2(Recorder是追加写入)："></a>2.1.2示例代码2(Recorder是追加写入)：</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-built_in">from</span> DrissionPage import ChromiumPage<br><span class="hljs-built_in">from</span> DataRecorder import Recorder  <span class="hljs-comment"># 这个是追加写入</span><br><span class="hljs-built_in">from</span> <span class="hljs-built_in">time</span> import sleep<br> <br><span class="hljs-comment"># 创建页面对象</span><br> <br>page = ChromiumPage()<br> <br><span class="hljs-comment"># 创建记录器对象</span><br> <br>recorder = Recorder(<span class="hljs-string">&#x27;data.csv&#x27;</span>)<br>recorder.add_data((<span class="hljs-string">&quot;标题&quot;</span>, <span class="hljs-string">&quot;导演&quot;</span>, <span class="hljs-string">&quot;上映时间&quot;</span>, <span class="hljs-string">&quot;评分&quot;</span>))<br> <br><span class="hljs-comment"># 访问网页</span><br> <br>page.<span class="hljs-built_in">get</span>(<span class="hljs-string">&#x27;https://www.maoyan.com/board/4&#x27;</span>)<br> <br><span class="hljs-keyword">while</span> True:<br>    <span class="hljs-comment"># 遍历页面上所有 dd 元素</span><br>    <span class="hljs-keyword">for</span> mov <span class="hljs-keyword">in</span> page.eles(<span class="hljs-string">&#x27;t:dd&#x27;</span>):<br>        <span class="hljs-comment"># 获取须要的信息</span><br>        score = mov(<span class="hljs-string">&#x27;.score&#x27;</span>).<span class="hljs-keyword">text</span><br>        title = mov(<span class="hljs-string">&#x27;@data-act=boarditem-click&#x27;</span>).attr(<span class="hljs-string">&#x27;title&#x27;</span>)<br>        star = mov(<span class="hljs-string">&#x27;.star&#x27;</span>).<span class="hljs-keyword">text</span><br>        <span class="hljs-built_in">time</span> = mov(<span class="hljs-string">&#x27;.releasetime&#x27;</span>).<span class="hljs-keyword">text</span><br>        <span class="hljs-comment"># 写入到记录器</span><br>        recorder.add_data((title, star, <span class="hljs-built_in">time</span>, score))<br>    sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 获取下一页按钮，有就点击</span><br>    btn = page(<span class="hljs-string">&#x27;下一页&#x27;</span>, timeout=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">if</span> btn:<br>        btn.click()<br>        page.<span class="hljs-built_in">wait</span>.load_start()<br>    <span class="hljs-comment"># 没有则退出程序</span><br>    <span class="hljs-keyword">else</span>:<br>        break<br>recorder.record()<br><br></code></pre></td></tr></table></figure><h4 id="2-1-3-示例代码3"><a href="#2-1-3-示例代码3" class="headerlink" title="2.1.3 示例代码3"></a>2.1.3 示例代码3</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#抓取震坤行商品</span><br><span class="hljs-attribute">from</span> DrissionPage import  ChromiumPage<br><span class="hljs-attribute">import</span>  time<br><br><span class="hljs-attribute">page</span> = ChromiumPage()<br><span class="hljs-comment"># page = ChromiumPage()这句意思是打开一个浏览器，这个浏览器是安装DrissionPage时自动安装的</span><br><br><span class="hljs-comment"># 跳转到震坤行页面</span><br><span class="hljs-attribute">page</span>.get(&#x27;https://www.zkh.com/?utm_source=baidu&amp;utm_medium=CPT&#x27;)<br><span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">1</span>)<br><span class="hljs-attribute">page</span>.ele(&#x27;xpath://*[@id=<span class="hljs-string">&quot;app&quot;</span>]/div/div/div[<span class="hljs-number">3</span>]/div/div[<span class="hljs-number">1</span>]/div[<span class="hljs-number">1</span>]/input&#x27;).input(<span class="hljs-string">&quot;口罩&quot;</span>)<br><span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">1</span>)<br><span class="hljs-attribute">page</span>.ele(&#x27;xpath://*[@id=<span class="hljs-string">&quot;app&quot;</span>]/div/div/div[<span class="hljs-number">3</span>]/div/div[<span class="hljs-number">1</span>]/button&#x27;).click()<br><span class="hljs-comment"># page.to_tab(page.latest_tab)  goods-title</span><br><br><span class="hljs-attribute">while</span> True:<br>    <span class="hljs-attribute">page</span>.wait.load_start()<br><br>    <span class="hljs-attribute">page</span>.scroll.to_location(<span class="hljs-number">0</span>,<span class="hljs-number">10000</span>) #滚动到指定位置<br>    <span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br>    <span class="hljs-attribute">page</span>.scroll.to_location(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>    <span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br>    <span class="hljs-attribute">page</span>.scroll.to_location(<span class="hljs-number">0</span>, <span class="hljs-number">10000</span>)<br>    <span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>)<br>    <span class="hljs-attribute">divs</span>=page.eles(&#x27;xpath://div[@class=<span class="hljs-string">&quot;goods-name clamp2&quot;</span>]&#x27;)<br>    <span class="hljs-attribute">for</span> i in divs:<br>        <span class="hljs-attribute">title</span> = i.attr(&#x27;title&#x27;)<br>        <span class="hljs-attribute">print</span>(title)<br><br><br></code></pre></td></tr></table></figure><h3 id="2-2收发数据包，导入SessionPage："><a href="#2-2收发数据包，导入SessionPage：" class="headerlink" title="2.2收发数据包，导入SessionPage："></a>2.2收发数据包，导入<code>SessionPage</code>：</h3><blockquote><p>from DrissionPage import SessionPage</p></blockquote><h4 id="2-2-1示例代码："><a href="#2-2-1示例代码：" class="headerlink" title="2.2.1示例代码："></a>2.2.1示例代码：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> DrissionPage <span class="hljs-keyword">import</span> SessionPage<br> <br><span class="hljs-comment"># 创建页面对象</span><br>page = SessionPage()<br> <br><span class="hljs-comment"># 爬取前5页</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>):<br>    page.get(<span class="hljs-string">f&#x27;https://gitee.com/explore/all?page=<span class="hljs-subst">&#123;i&#125;</span>&#x27;</span>)<br>    <span class="hljs-comment"># 获取所有开源库&lt;a&gt;元素列表</span><br>    links = page.eles(<span class="hljs-string">&#x27;.title project-namespace-path&#x27;</span>)    <span class="hljs-comment"># 页面对象的eles()获取页面中所有class属性为&#x27;title project-namespace-path&#x27;的元素对象，eles()方法用于查找多个符合条件的元素，返回由它们组成的list</span><br>    <span class="hljs-comment"># 遍历所有&lt;a&gt;元素</span><br>    <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:<br>        <span class="hljs-comment"># 打印链接信息</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;link.text&#125;</span>:<span class="hljs-subst">&#123;link.link&#125;</span>&quot;</span>)    <span class="hljs-comment"># .text获取元素的文本，.link获取元素的href或src属性</span><br></code></pre></td></tr></table></figure><h4 id="2-2-2下载网页"><a href="#2-2-2下载网页" class="headerlink" title="2.2.2下载网页"></a>2.2.2下载网页</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> DrissionPage <span class="hljs-keyword">import</span> SessionPage<br> <br>url = <span class="hljs-string">&#x27;https://www.baidu.com/img/flexible/logo/pc/result.png&#x27;</span><br>save_path = <span class="hljs-string">r&#x27;images&#x27;</span>  <span class="hljs-comment"># 保存的路径，当前的项目路径，如为空则保存在与py同目录</span><br> <br>page = SessionPage()<br>page.download(url, save_path, <span class="hljs-string">&#x27;img&#x27;</span>)  <span class="hljs-comment"># 支持重命名，处理文件名冲突，img是图片名字</span><br></code></pre></td></tr></table></figure><h2 id="3-获取新窗口句柄"><a href="#3-获取新窗口句柄" class="headerlink" title="3.获取新窗口句柄"></a>3.获取新窗口句柄</h2><h3 id="3-1-无需切入切出，逻辑清晰"><a href="#3-1-无需切入切出，逻辑清晰" class="headerlink" title="3.1.无需切入切出，逻辑清晰"></a>3.1.无需切入切出，逻辑清晰</h3><p>使用过 selenium 的人都知道，selenium 同一时间只能操作一个标签页或<code>&lt;iframe&gt;</code>元素，要操作其它标签页，或<code>&lt;iframe&gt;</code>元素，需要用<code>switch_to()</code> 方法切换，操作后还要切换回来。如果是多级<code>&lt;iframe&gt;</code>，还要逐级切入，相当麻烦。</p><p>DrissionPage 则无需这些麻烦的操作，它把每个标签页和<code>&lt;iframe&gt;</code>都看作独立的对象，可以同时并发操作，而且可以直接跨多层<code>&lt;iframe&gt;</code>获取里面的元素，然后直接处理，非常方便。</p><p>对比一下，获取 2 层<code>&lt;iframe&gt;</code>内一个 id 为<code>&#39;div1&#39;</code>的元素：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 使用 selenium</span><br>driver.<span class="hljs-keyword">switch_to.frame(0)</span><br><span class="hljs-keyword"></span>driver.<span class="hljs-keyword">switch_to.frame(0)</span><br><span class="hljs-keyword"></span>ele = driver.find_element(<span class="hljs-keyword">By.ID, </span><span class="hljs-string">&#x27;div1&#x27;</span>)<br>driver.<span class="hljs-keyword">switch_to.default_content()</span><br><span class="hljs-keyword"></span><br><span class="hljs-comment"># 使用 DrissionPage</span><br>ele = page(<span class="hljs-string">&#x27;#div1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>多标签页同时操作，selenium 无此功能：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">tab1</span> = page.get_tab(1)<br><span class="hljs-keyword">tab2</span> = page.get_tab(2)<br><br><span class="hljs-keyword">tab1</span>.<span class="hljs-built_in">get</span>(&#x27;https:<span class="hljs-comment">//www.baidu.com&#x27;)</span><br><span class="hljs-keyword">tab2</span>.<span class="hljs-built_in">get</span>(&#x27;https:<span class="hljs-comment">//www.163.com&#x27;)</span><br></code></pre></td></tr></table></figure><h3 id="3-2-示例代码1"><a href="#3-2-示例代码1" class="headerlink" title="3.2 示例代码1"></a>3.2 示例代码1</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment">#登录百度爬取</span><br>from DrissionPage import  ChromiumPage<br>import  time<br><br><span class="hljs-keyword">page</span> = ChromiumPage()这句意思是打开一个浏览器，这个浏览器是安装DrissionPage时自动安装的<br><br><span class="hljs-comment"># 跳转百度页面</span><br><span class="hljs-keyword">page</span>.get(<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>)<br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;xpath://*[@id=&quot;kw&quot;]&#x27;</span>).input(<span class="hljs-string">&quot;宿舍&quot;</span>)<br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;xpath://*[@id=&quot;su&quot;]&#x27;</span>).click()<br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;xpath://*[@id=&quot;3&quot;]/div/div[1]/h3/a&#x27;</span>).click()<br><br><span class="hljs-comment">#切换到新页面</span><br>ab=<span class="hljs-keyword">page</span>.get_tab(<span class="hljs-keyword">page</span>.latest_tab) <span class="hljs-comment">#获取新窗口页面句柄</span><br><span class="hljs-comment"># 等待页面跳转</span><br><span class="hljs-keyword">page</span>.wait.load_start()<br><span class="hljs-comment"># ab = page.geqwt_tab(0) #这样也可以获取新框框页面句柄</span><br><br><span class="hljs-literal">print</span>(ab.title) <span class="hljs-comment">#获取页面标题</span><br><span class="hljs-comment"># exit()</span><br><br><br><span class="hljs-comment">#切换到新页面</span><br><span class="hljs-comment"># ab=page.get_tab(1)</span><br><span class="hljs-comment"># page.get_tab(page.latest_tab)</span><br><span class="hljs-comment"># print(ab.title)</span><br><span class="hljs-comment"># page.get_tab(page.latest_tab)</span><br><span class="hljs-comment"># print(page.title)</span><br><span class="hljs-comment"># exit()</span><br><br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>)<br><span class="hljs-comment">#通过用新窗口的句柄来进行操作</span><br>ab.ele(<span class="hljs-string">&#x27;xpath:/html/body/div[1]/div[3]/form/div/input[4]&#x27;</span>).input(<span class="hljs-string">&quot;家&quot;</span>)<br>ab.ele(<span class="hljs-string">&#x27;xpath:/html/body/div[1]/div[3]/form/div/span&#x27;</span>).click()<br><br>lis = ab.ele(<span class="hljs-string">&#x27;xpath:/html/body/div[2]/div[1]/div/div[2]/ul&#x27;</span>)<br><span class="hljs-comment"># lis = page.ele(&#x27;xpath://ul[@class=&quot;w4]&#x27;)</span><br><span class="hljs-comment"># print(lis)</span><br>lis1 = lis.eles(<span class="hljs-string">&#x27;tag:li&#x27;</span>)<br>for i in lis1:<br>    lis2 = i.eles(<span class="hljs-string">&#x27;tag:a&#x27;</span>)<br>    for j in lis2:<br>        href=j.attr(<span class="hljs-string">&#x27;href&#x27;</span>) <span class="hljs-comment">#获取href属性值</span><br>        <span class="hljs-comment"># title=i.text </span><br>        title=j.attr(<span class="hljs-string">&#x27;title&#x27;</span>) <span class="hljs-comment">#获取title属性值</span><br>        <span class="hljs-literal">print</span>(href,title)<br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">4</span>)<br><span class="hljs-comment"># ab.close()  #关闭当前页面 （这样也可以）</span><br><span class="hljs-keyword">page</span>.close_tabs(ab) <span class="hljs-comment">#关闭当前页面</span><br><br><span class="hljs-comment"># ac=page.get_tab(-1)</span><br>ac=<span class="hljs-keyword">page</span>.get_tab(<span class="hljs-keyword">page</span>.latest_tab) <span class="hljs-comment">#将句柄调回原来的页面中</span><br><span class="hljs-literal">print</span>(ac.title)<br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">1</span>)<br><br>ac.ele(<span class="hljs-string">&#x27;xpath://*[@id=&quot;6&quot;]/div/div[1]/h3/a&#x27;</span>).click()<br><br>time.<span class="hljs-keyword">sleep</span>(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">page</span>.<span class="hljs-keyword">quit</span>() <span class="hljs-comment">#退出浏览器</span><br></code></pre></td></tr></table></figure><h2 id="4-与selenium对比"><a href="#4-与selenium对比" class="headerlink" title="4.与selenium对比"></a>4.与selenium对比</h2><p><a href="http://drissionpage.cn/features/features_demos/selenium/">与selenium对比</a></p><h3 id="4-1跳转到一个标签页"><a href="#4-1跳转到一个标签页" class="headerlink" title="4.1跳转到一个标签页"></a>4.1跳转到一个标签页</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 使用 selenium：</span><br><span class="hljs-attribute">driver</span>.switch_to.window(driver.window_handles[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># 使用 DrissionPage：</span><br><span class="hljs-attribute">tab</span> = page.get_tab(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h3 id="4-2按文本选择下拉列表"><a href="#4-2按文本选择下拉列表" class="headerlink" title="4.2按文本选择下拉列表"></a>4.2按文本选择下拉列表</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># 使用 selenium：</span><br>from selenium.webdriver.support.<span class="hljs-keyword">select</span> import <span class="hljs-keyword">Select</span><br>select_element = <span class="hljs-keyword">Select</span>(element)<br>select_element.select_by_visible_text(<span class="hljs-string">&#x27;text&#x27;</span>)<br><br><span class="hljs-meta"># 使用 DrissionPage：</span><br>element.<span class="hljs-keyword">select</span>(<span class="hljs-string">&#x27;text&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3拖拽一个元素"><a href="#4-3拖拽一个元素" class="headerlink" title="4.3拖拽一个元素"></a>4.3拖拽一个元素</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 使用 selenium：<br>ActionChains(driver).drag_and_drop(ele1, ele2).<span class="hljs-keyword">perform</span>()<br><br># 使用 DrissionPage：<br>ele1.drag_to(ele2)<br></code></pre></td></tr></table></figure><h3 id="4-4滚动窗口到底部（保持水平滚动条不变）"><a href="#4-4滚动窗口到底部（保持水平滚动条不变）" class="headerlink" title="4.4滚动窗口到底部（保持水平滚动条不变）"></a>4.4滚动窗口到底部（保持水平滚动条不变）</h3><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment"># 使用 selenium：</span><br>driver.execute_script(<span class="hljs-string">&quot;window.scrollTo(document.documentElement.scrollLeft, document.body.scrollHeight);&quot;</span>)<br><br><span class="hljs-comment"># 使用 DrissionPage：</span><br><span class="hljs-keyword">page</span>.scroll.to_bottom()<br></code></pre></td></tr></table></figure><h3 id="4-5设置-headless-模式"><a href="#4-5设置-headless-模式" class="headerlink" title="4.5设置 headless 模式"></a>4.5设置 headless 模式</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 使用 selenium：</span><br><span class="hljs-attribute">options</span> = webdriver.ChromeOptions()<br><span class="hljs-attribute">options</span>.add_argument(<span class="hljs-string">&quot;--headless&quot;</span>)<br><br><span class="hljs-comment"># 使用 DrissionPage：</span><br><span class="hljs-attribute">set_headless</span>(True)<br></code></pre></td></tr></table></figure><h3 id="4-6获取伪元素内容"><a href="#4-6获取伪元素内容" class="headerlink" title="4.6获取伪元素内容"></a>4.6获取伪元素内容</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 使用 selenium：</span><br><span class="hljs-built_in">text</span> = webdriver.execute_script(&#x27;<span class="hljs-literal">return</span> window.getComputedStyle(arguments[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;::after&quot;</span>).getPropertyValue(<span class="hljs-string">&quot;content&quot;</span>);&#x27;, element)<br><br><span class="hljs-comment"># 使用 DrissionPage：</span><br><span class="hljs-built_in">text</span> = element.pseudo.<span class="hljs-keyword">after</span><br></code></pre></td></tr></table></figure><h3 id="4-7用-xpath-直接获取属性或文本节点（返回文本）"><a href="#4-7用-xpath-直接获取属性或文本节点（返回文本）" class="headerlink" title="4.7用 xpath 直接获取属性或文本节点（返回文本）"></a>4.7用 xpath 直接获取属性或文本节点（返回文本）</h3><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-comment"># 使用 selenium：</span><br>相当复杂<br><br><span class="hljs-comment"># 使用 DrissionPage：</span><br>class_name = element(&#x27;xpath://div[<span class="hljs-meta">@id</span>=<span class="hljs-string">&quot;div_id&quot;</span>]/<span class="hljs-meta">@class</span>&#x27;)<br>text = element(&#x27;xpath://div[<span class="hljs-meta">@id</span>=<span class="hljs-string">&quot;div_id&quot;</span>]/text()[<span class="hljs-number">2</span>]&#x27;)<br></code></pre></td></tr></table></figure><h2 id="5-模式切换"><a href="#5-模式切换" class="headerlink" title="5.模式切换"></a>5.模式切换</h2><p><a href="http://drissionpage.cn/features/features_demos/change_mode/">http://drissionpage.cn/features/features_demos&#x2F;change_mode&#x2F;</a></p><p><strong>用浏览器登录网站，然后切换到 requests 读取网页。两者会共享登录信息。</strong></p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nsis">from DrissionPage import WebPage<br>from time import <span class="hljs-keyword">sleep</span><br><br><span class="hljs-comment"># 创建页面对象，默认 d 模式</span><br><span class="hljs-keyword">page</span> = WebPage()  <br><span class="hljs-comment"># 访问个人中心页面（未登录，重定向到登录页面）</span><br><span class="hljs-keyword">page</span>.get(<span class="hljs-string">&#x27;https://gitee.com/profile&#x27;</span>)  <br><br><span class="hljs-comment"># 输入账号密码登录</span><br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;@id:user_login&#x27;</span>).input(<span class="hljs-string">&#x27;your_user_name&#x27;</span>)  <br><span class="hljs-keyword">page</span>.ele(<span class="hljs-string">&#x27;@id:user_password&#x27;</span>).input(<span class="hljs-string">&#x27;your_password\n&#x27;</span>)<br><span class="hljs-keyword">page</span>.wait.load_start()<br><br><span class="hljs-comment"># 切换到 s 模式</span><br><span class="hljs-keyword">page</span>.change_mode()  <br><span class="hljs-comment"># 登录后 session 模式的输出</span><br><span class="hljs-literal">print</span>(<span class="hljs-string">&#x27;登录后title：&#x27;</span>, <span class="hljs-keyword">page</span>.title, <span class="hljs-string">&#x27;\n&#x27;</span>)  <br><br><span class="hljs-comment">#输出：</span><br>登录后title： 个人资料 - 码云 Gitee.com<br></code></pre></td></tr></table></figure><h4 id="获取登录后的元素"><a href="#获取登录后的元素" class="headerlink" title="获取登录后的元素"></a>获取登录后的元素</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 接上段代码</span><br>foot = page.ele(<span class="hljs-string">&#x27;#footer-left&#x27;</span>)  <span class="hljs-comment"># 用 id 查找元素</span><br>first_col = foot.ele(<span class="hljs-string">&#x27;css:&gt;div&#x27;</span>)  <span class="hljs-comment"># 使用 css selector 在元素的下级中查找元素（第一个）</span><br>lnk = first_col.ele(<span class="hljs-string">&#x27;text:命令学&#x27;</span>)  <span class="hljs-comment"># 使用文本内容查找元素</span><br><span class="hljs-keyword">text</span> = lnk.<span class="hljs-keyword">text</span>  <span class="hljs-comment"># 获取元素文本</span><br>href = lnk.attr(<span class="hljs-string">&#x27;href&#x27;</span>)  <span class="hljs-comment"># 获取元素属性值</span><br><br>print(<span class="hljs-keyword">text</span>, href, <span class="hljs-string">&#x27;\n&#x27;</span>)<br><br><span class="hljs-comment"># 简洁模式串联查找</span><br><span class="hljs-keyword">text</span> = page(<span class="hljs-string">&#x27;@id:footer-left&#x27;</span>)(<span class="hljs-string">&#x27;css:&gt;div&#x27;</span>)(<span class="hljs-string">&#x27;text:命令学&#x27;</span>).<span class="hljs-keyword">text</span><br>print(<span class="hljs-keyword">text</span>)<br><br><span class="hljs-comment">#输出</span><br>Git 命令学习 <span class="hljs-keyword">https</span>://oschina.gitee.io/learn-git-branching/<br><br>Git 命令学习<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器中的程序，为什么一定要前台运行</title>
    <link href="/article/a730ba11.html"/>
    <url>/article/a730ba11.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />#### [docker](https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020) 容器默认会把容器内部第一个进程，也就是`pid=1`的程序作为docker[容器](https://so.csdn.net/so/search?q=%E5%AE%B9%E5%99%A8&spm=1001.2101.3001.7020)是否正在运行的依据，如果docker容器中 pid = 1 的进程挂了，那么docker容器便会直接退出，也就是说Docker容器中必须有一个前台进程，否则认为容器已经挂掉。<p>代码语言：javascript</p><p>复制</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker容器之后台运行 我们 docker <span class="hljs-built_in">run</span> 启动容器的时候，常需要将其在后台运行，通常我们设置参数 -d 即可。 但后台运行，其实是有前提的，如果没有前台进程，那么实际运行完docker <span class="hljs-built_in">run</span>命令后，会处于退出状态，即exited。 例子：docker <span class="hljs-built_in">run</span> -d <span class="hljs-comment">--name my-redis redis bash # 指定命令是bash，但显然bash在容器起来后，很快就会结束，导致没有前台进程，故容器处于退出状态</span><br></code></pre></td></tr></table></figure><h4 id="Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行ping，sleep），就是会自动退出的。-而上面的代码中bash就是需要执行的指定的命令。"><a href="#Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行ping，sleep），就是会自动退出的。-而上面的代码中bash就是需要执行的指定的命令。" class="headerlink" title="Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行ping，sleep），就是会自动退出的。 而上面的代码中bash就是需要执行的指定的命令。"></a>Docker容器后台运行，必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行ping，sleep），就是会自动退出的。 而上面的代码中bash就是需要执行的指定的命令。</h4><h4 id="命令如果执行完毕了，或者叫指定的应用终结时，容器会自动停止。"><a href="#命令如果执行完毕了，或者叫指定的应用终结时，容器会自动停止。" class="headerlink" title="命令如果执行完毕了，或者叫指定的应用终结时，容器会自动停止。"></a>命令如果执行完毕了，或者叫指定的应用终结时，容器会自动停止。</h4><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a><strong>解决办法</strong></h4><p>目前了解的可以使用以下3种方法，具体用哪种方法，依据实际情况，生产情况下，通常用<code>docker-compose</code>结合具体<code>cmd</code>作为<a href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065" title="容器">容器</a>初起的命令。</p><h5 id="1-指定挂起阻塞命令启动容器"><a href="#1-指定挂起阻塞命令启动容器" class="headerlink" title="1.指定挂起阻塞命令启动容器"></a><strong>1.指定挂起阻塞命令启动容器</strong></h5><p>代码语言：javascript</p><p>复制</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -d <span class="hljs-comment">--name my-redis redis sleep 99999999999999</span><br></code></pre></td></tr></table></figure><p><a href="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C&spm=1001.2101.3001.7020">命令执行</a>后，通过**<code>docker ps -a | grep my-redis</code><strong>，可以看到容器处于运行状态，即</strong><code>up</code>**。</p><h5 id="2-使用交互界面后退出容器"><a href="#2-使用交互界面后退出容器" class="headerlink" title="2.使用交互界面后退出容器"></a><strong>2.使用交互界面后退出容器</strong></h5><p>代码语言：javascript</p><p>复制</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -<span class="hljs-keyword">it</span> <span class="hljs-comment">--name my-redis redis bash</span><br></code></pre></td></tr></table></figure><p>之后会进入容器，如果想保持容器后台运行，我们可以 **<code>Ctrl + p + q</code><strong>，再次查看容器运行状态，也可以看到容器处于</strong><code>up</code>**状态。</p><h5 id="3-td命令结合使用"><a href="#3-td命令结合使用" class="headerlink" title="3.-td命令结合使用"></a><strong>3.-td命令结合使用</strong></h5><p>代码语言：javascript</p><p>复制</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker <span class="hljs-built_in">run</span> -itd <span class="hljs-comment">--name my-redis2 redis bash# -i 不是必需，加了，容器起来后终端返回容器ID</span><br></code></pre></td></tr></table></figure><p>刚也提到，就是<code>-d</code>运行容器时，需要有前台进程，<code>-t</code>提供一个伪终端，类似前台进程，查看容器运行状态，也可以看到，容器处于<code>**up**</code>状态。</p><h5 id="补充-进入容器的4种方法"><a href="#补充-进入容器的4种方法" class="headerlink" title="补充-进入容器的4种方法"></a><strong>补充-进入容器的4种方法</strong></h5><p><a href="https://cloud.tencent.com/product/tke?from_column=20065&from=20065" title="docker">docker</a>提供了多种进入容器的方法，这里补充4种常见的方法：</p><ul><li>使用docker attach</li><li>使用SSH</li><li>使用nsenter</li><li>使用exec</li></ul><p><strong>docker attach</strong></p><p>代码语言：javascript</p><p>复制</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">docker attach 容器ID<span class="hljs-string">|容器name </span><br></code></pre></td></tr></table></figure><p>使用该命令有一个问题。当多个窗口同时使用该命令进入该容器时，所有的窗口都会同步显示。如果有一个窗口阻塞了，那么其他窗口也无法再进行操作，建议开发时使用。</p><p><strong>ssh</strong> 在镜像（或容器）中安装SSH Server，这样就能保证多人进入，不建议使用，具体见<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://www.oschina.net/translate/why-you-dont-need-to-run-sshd-in-docker?cmp&source=article&objectId=2137830" title="为什么不需要在 Docker 容器中运行 sshd">为什么不需要在 Docker 容器中运行 sshd</a></p><p><strong>nsenter</strong> <a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://www.cnblogs.com/xhyan/p/6593075.html&source=article&objectId=2137830" title="nsenter使用方法">nsenter使用方法</a></p><p><strong>docker exec-推荐使用</strong> 通常我们可以通过<code>容器name</code>或<code>容器ID</code>进入到容器中：</p><ul><li>如果我们在启动容器的时候指定<code>-name</code>选项，我们可以：<code>docker exec -it container_name bash</code></li><li>没指定name，我们可以通过<code>docker ps</code>查看容器的ID，之后再通过<code>docker exec -it containerID bash</code>进入容器</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign 和 RestTemplate</title>
    <link href="/article/356b653b.html"/>
    <url>/article/356b653b.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />Feign 和 RestTemplate 是两种用于在 Spring 应用中进行 HTTP 请求的工具。以下是它们的介绍和主要区别：<h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>Feign 是一种声明式的 HTTP 客户端，由 Netflix 开发，通常与 Spring Cloud 一起使用。它通过接口来定义 HTTP 请求，并在运行时生成实现类。使用 Feign 可以大大减少样板代码，让代码更简洁。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>声明式编程</strong>：通过注解定义 HTTP 请求，代码更加简洁直观。</li><li><strong>集成性强</strong>：与 Spring Cloud、Eureka、Ribbon 等组件无缝集成。</li><li><strong>可扩展性</strong>：支持自定义编码器、解码器、错误处理等。</li></ol><h4 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h4><p>java</p><p>复制代码</p><p><code>@FeignClient(name = &quot;service-name&quot;) public interface MyFeignClient &#123;      @GetMapping(&quot;/endpoint&quot;)     String getData(); &#125;</code></p><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>RestTemplate 是 Spring 提供的一个同步 HTTP 客户端，用于在 Java 应用中发起 HTTP 请求。它功能强大且灵活，可以配置各种消息转换器和错误处理机制。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ol><li><strong>灵活性高</strong>：可以配置各种请求头、参数、消息转换器等。</li><li><strong>细粒度控制</strong>：提供了对 HTTP 请求的全面控制。</li><li><strong>广泛使用</strong>：适用于各种 HTTP 请求场景。</li></ol><h4 id="使用示例：-1"><a href="#使用示例：-1" class="headerlink" title="使用示例："></a>使用示例：</h4><p>java</p><p>复制代码</p><p><code>RestTemplate restTemplate = new RestTemplate(); String url = &quot;http://service-name/endpoint&quot;; String response = restTemplate.getForObject(url, String.class);</code></p><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol><li><strong>编程方式</strong>：Feign 采用声明式编程，通过注解定义请求；RestTemplate 则是编程式的，需要手动构建请求。</li><li><strong>集成和配置</strong>：Feign 更适合与 Spring Cloud 生态系统集成，特别是在微服务架构中；RestTemplate 更加灵活，可用于任何 Spring 项目中。</li><li><strong>代码简洁度</strong>：Feign 更加简洁，适合快速开发；RestTemplate 提供了更高的灵活性和控制能力。</li></ol><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li>如果你使用的是 Spring Cloud 微服务架构，并且希望简化 HTTP 客户端代码，建议使用 Feign。</li><li>如果你需要对 HTTP 请求进行细粒度控制，或者不依赖 Spring Cloud 生态系统，RestTemplate 会是一个不错的选择。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ribbon和Spring Cloud Loadbalancer</title>
    <link href="/article/c1b21328.html"/>
    <url>/article/c1b21328.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />转载于：https://www.modb.pro/db/380587<blockquote><p>2020年以后随着Netflix的相关SpringCloud组件进入停更状态，Cloud吸收前人经验，自己创造了一套相关组件，今天就跟大家揭秘一下客户端负载均衡组件Ribbon和LoadBalancer。</p></blockquote><h1 id="现状大PK"><a href="#现状大PK" class="headerlink" title="现状大PK"></a>现状大PK</h1><h2 id="Ribbon："><a href="#Ribbon：" class="headerlink" title="Ribbon："></a>Ribbon：</h2><blockquote><p>目前处于停更维护阶段，由于Ribbon比较优秀，生命力顽强，在生产环境还处在大规模使用中， 暂时还没有完全被替换，但是在2020年以后的cloud版本中已经删除了Ribbon的依赖。</p></blockquote><h2 id="LoadBalancer："><a href="#LoadBalancer：" class="headerlink" title="LoadBalancer："></a>LoadBalancer：</h2><ul><li><p>cloud正在大规模引入LoadBalancer，还未全部占领高地，随着时间的推移，再加上cloud的大力扶持，未来迟早有一天LoadBalancer会一统江湖。</p></li><li><p>还支持响应式客户端的负载均衡，Spring Cloud LoadBalancer结合Spring Web Flux实现客户端负载均衡调用。即：WebClient。</p></li></ul><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20220322_c5564100-a9b5-11ec-8d1e-fa163eb4f6be.png"></p><h1 id="Ribbon简介-amp-实战"><a href="#Ribbon简介-amp-实战" class="headerlink" title="Ribbon简介&amp;实战"></a>Ribbon简介&amp;实战</h1><blockquote><p>Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单说，就是在配置文件中列出LoadBalancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如轮询，随机等）去连接这些机器，很容易使用Ribbon实现自定义的负载均衡算法。</p></blockquote><h2 id="LB负载均衡是什么"><a href="#LB负载均衡是什么" class="headerlink" title="LB负载均衡是什么"></a>LB负载均衡是什么</h2><ul><li><p>我给大家讲一下什么是客户端负载均衡，服务消费者从注册中心拿到服务提供者集群，自己决定使用何种算法找到目标服务，这个过程就是客户端负载均衡，即主动权掌握在自己手里</p></li><li><p>相对客户端负载均衡，服务端负载均衡，就是消费者把请求交给服务端，由服务端来负责找到目标服务提供者，即主动权掌握在被人手里。</p></li><li><p>我看大家还有一种分类方式：集中式LB和进程内LB，都是一个意思。</p></li></ul><h2 id="Ribbon工作流程"><a href="#Ribbon工作流程" class="headerlink" title="Ribbon工作流程"></a>Ribbon工作流程</h2><ol><li><p>从注册中心获取服务列表</p></li><li><p>根据用户指定的策略，找到目标服务提供者</p></li><li><p>通过Feign或者OpenFeign，Web客户端调用工具完成用户请求</p></li></ol><p> </p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><ul><li><p><strong>RoundRobinRule：</strong>轮询</p></li><li><p><strong>RandomRule：</strong>随机</p></li><li><p><strong>RetryRule：</strong>先按照轮询策略获取服务，如果获取服务失败则在指定时间内进行重试，获取可用的服务</p></li><li><p><strong>WeightedResponseTimeRule：</strong>对轮询的扩展，响应速度越快的实例选择权重越大，越容易被选择</p></li><li><p><strong>BestAvailableRule：</strong>会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务</p></li><li><p><strong>AvailabiliyFilteringRule：</strong>先过滤掉故障实例，再选择并发较小的实例</p></li><li><p><strong>ZoneAvoidanceRule：</strong>默认规则，复合判断server所在区域的性能和server的可用性选择服务器</p></li></ul><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20220322_c5776ec0-a9b5-11ec-8d1e-fa163eb4f6be.png"></p><h2 id="自定义负载均衡策略"><a href="#自定义负载均衡策略" class="headerlink" title="自定义负载均衡策略"></a>自定义负载均衡策略</h2><ol><li><h2 id="Ribbon官方明确规定，自动以的配置类，不能放在-ComponentScan所扫描的当前包下以及子包下，否则我们定义的配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的。"><a href="#Ribbon官方明确规定，自动以的配置类，不能放在-ComponentScan所扫描的当前包下以及子包下，否则我们定义的配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的。" class="headerlink" title="Ribbon官方明确规定，自动以的配置类，不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们定义的配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的。"></a>Ribbon官方明确规定，自动以的配置类，不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们定义的配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的。</h2></li><li><p>在某些特殊场景下，我们可能需要targetId相同，所有请求应该落到同一服务上。这个时候随机和轮询都不满足，所以就需要自定义一致性hash算法。</p></li><li><p>在某一个服务中，如果只调用一个服务提供方，可以写在@ComponentScan所扫描的包及子包下。如果是调用多个服务提供方，需要不同的策略，且互不干扰。就需要遵守第一条原则。</p></li><li><p>一般boot工程默认配置了@ComponentScan所扫描的包是启动类Application所在包及子包，所以在有时候我们不配置自动扫描也能正常运行的原因。</p></li></ol><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20220322_c5a391da-a9b5-11ec-8d1e-fa163eb4f6be.png"></p><ul><li><strong>自定义配置类，比如使用随机替换默认的轮询</strong></li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRule</span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">IRule</span> <span class="hljs-title function_">myRule</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomRule</span>();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>在启动类上使用@RibbonClient注解，设置自定义负载均衡策略使其生效，name是服务名，即调用哪个服务集群的时候使用自定义规则。</strong></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaClient</span><br><span class="hljs-variable">@RibbonClient</span>(name = <span class="hljs-string">&quot;cloud-payment-service&quot;</span>,configuration=MyRule.class)<br>public class Application8080 &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(Application8080.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="LoadBalancer简介-amp-实战"><a href="#LoadBalancer简介-amp-实战" class="headerlink" title="LoadBalancer简介&amp;实战"></a>LoadBalancer简介&amp;实战</h1><h2 id="LoadBalancer的优势"><a href="#LoadBalancer的优势" class="headerlink" title="LoadBalancer的优势"></a>LoadBalancer的优势</h2><ul><li><p>跟Ribbon一样也支持RestTemplate，使用方法一样，由于cloud的其他组件还在使用Ribbon，所以在使用LoadBalancer的时候要屏蔽Ribbon。</p></li><li><p>LoadBalancer还支持<strong>响应式编程</strong>方式的<strong>异步访问</strong>客户端的负载均衡，依赖Spring Web Flux实现客户端负载均衡调用，底层依赖Netty的<strong>AIO</strong>。</p></li></ul><h2 id="引入LoadBalancer依赖jar包"><a href="#引入LoadBalancer依赖jar包" class="headerlink" title="引入LoadBalancer依赖jar包"></a>引入LoadBalancer依赖jar包</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="配置文件application-yml屏蔽Ribbon负载均衡"><a href="#配置文件application-yml屏蔽Ribbon负载均衡" class="headerlink" title="配置文件application.yml屏蔽Ribbon负载均衡"></a>配置文件application.yml屏蔽Ribbon负载均衡</h2><blockquote><p>在Ribbon和LoadBalancer依赖都引入的情况，cloud默认优先启用Ribbon，当我们想使用LoadBalancer的时候就要先屏蔽到Ribbon</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">ribbon:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="业务类和启动类都没有区别，还是使用RestTemplate作为客户端来完成服务调用，此方式跟Ribbon在编码方面没什么区别。是Ribbon还是LoadBalancer，主要体现在jar包引入和yml文件关闭默认Ribbon。"><a href="#业务类和启动类都没有区别，还是使用RestTemplate作为客户端来完成服务调用，此方式跟Ribbon在编码方面没什么区别。是Ribbon还是LoadBalancer，主要体现在jar包引入和yml文件关闭默认Ribbon。" class="headerlink" title="业务类和启动类都没有区别，还是使用RestTemplate作为客户端来完成服务调用，此方式跟Ribbon在编码方面没什么区别。是Ribbon还是LoadBalancer，主要体现在jar包引入和yml文件关闭默认Ribbon。"></a>业务类和启动类都没有区别，还是使用RestTemplate作为客户端来完成服务调用，此方式跟Ribbon在编码方面没什么区别。是Ribbon还是LoadBalancer，主要体现在jar包引入和yml文件关闭默认Ribbon。</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//配置RestTemplate</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-keyword">public</span> RestTemplate getRestTemplate()&#123;<br>        <span class="hljs-keyword">return</span> new RestTemplate();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//controller部分</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/consumer&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerCtrol</span> &#123;<br>    <span class="hljs-keyword">private</span> static String PAYMENTURL = <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getPayment/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> MsgResponseBody getPaymet(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id)&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;adada&quot;</span>);<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENTURL+<span class="hljs-string">&quot;/payment/getPayment/&quot;</span>+id+<span class="hljs-string">&quot;?userName=123&quot;</span>, MsgResponseBody.<span class="hljs-keyword">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="WebClient方式发起服务调用"><a href="#WebClient方式发起服务调用" class="headerlink" title="WebClient方式发起服务调用"></a>WebClient方式发起服务调用</h2><h3 id="引入webflux的相关依赖"><a href="#引入webflux的相关依赖" class="headerlink" title="引入webflux的相关依赖"></a>引入webflux的相关依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- Spring Webflux响应式web编程--&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置类中声明要注入的WebClient-Builder，是WebClient的内部类，也是编程的入口"><a href="#配置类中声明要注入的WebClient-Builder，是WebClient的内部类，也是编程的入口" class="headerlink" title="配置类中声明要注入的WebClient.Builder，是WebClient的内部类，也是编程的入口"></a>配置类中声明要注入的WebClient.Builder，是WebClient的内部类，也是编程的入口</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//配置RestTemplate</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApplicationConfig</span> &#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-keyword">public</span> RestTemplate getRestTemplate()&#123;<br>        <span class="hljs-keyword">return</span> new RestTemplate();<br>    &#125;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-keyword">public</span> WebClient.Builder builder() &#123;<br>        <span class="hljs-keyword">return</span> WebClient.builder();<br>    &#125;<br> <br>&#125;<br> <br><span class="hljs-comment">//controller部分</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/consumer&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerCtrol</span> &#123;<br>    <span class="hljs-keyword">private</span> static String PAYMENTURL = <span class="hljs-string">&quot;http://CLOUD-PAYMENT-SERVICE&quot;</span>;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br> <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getPayment/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> MsgResponseBody getPaymet(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id)&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;adada&quot;</span>);<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENTURL+<span class="hljs-string">&quot;/payment/getPayment/&quot;</span>+id+<span class="hljs-string">&quot;?userName=123&quot;</span>, MsgResponseBody.<span class="hljs-keyword">class</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getPayment/webClient/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Mono&lt;MsgResponseBody&gt; getPaymetByWebClient(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;bbbbbbb&quot;</span>);<br>        <span class="hljs-comment">//return restTemplate.getForObject(PAYMENTURL + &quot;/payment/getPayment/&quot; + id + &quot;?userName=123&quot;, MsgResponseBody.class);</span><br>        <span class="hljs-keyword">return</span> clientBuilder.baseUrl(PAYMENTURL).build().<span class="hljs-keyword">get</span>().uri(<span class="hljs-string">&quot;/payment/getPayment/&quot;</span> + id + <span class="hljs-string">&quot;?userName=123&quot;</span>).retrieve().bodyToMono(MsgResponseBody.<span class="hljs-keyword">class</span>);<br>    &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="默认跟Ribbon是一样的，都是轮询策略，自定义配置使用的是-LoadBalancerClient，用法跟Ribbon的-RibbonClient一样。"><a href="#默认跟Ribbon是一样的，都是轮询策略，自定义配置使用的是-LoadBalancerClient，用法跟Ribbon的-RibbonClient一样。" class="headerlink" title="默认跟Ribbon是一样的，都是轮询策略，自定义配置使用的是@LoadBalancerClient，用法跟Ribbon的@RibbonClient一样。"></a>默认跟Ribbon是一样的，都是轮询策略，自定义配置使用的是@LoadBalancerClient，用法跟Ribbon的@RibbonClient一样。</h3><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20220322_c5d008aa-a9b5-11ec-8d1e-fa163eb4f6be.png"></p><p>在Springcloud alibaba的2.2.6版本对应的Spring-cloud版本是Hoxton.SR9，而spring-cloud-loadbalancer2.2.6版本负载均衡策略仅支持轮询策略。</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20220322_c5fc852e-a9b5-11ec-8d1e-fa163eb4f6be.png"></p><h3 id="Hoxton-SR10版本以后增加了随机负载均衡策略"><a href="#Hoxton-SR10版本以后增加了随机负载均衡策略" class="headerlink" title="Hoxton.SR10版本以后增加了随机负载均衡策略"></a>Hoxton.SR10版本以后增加了随机负载均衡策略</h3><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20220322_c61d6b68-a9b5-11ec-8d1e-fa163eb4f6be.png">  </p><h3 id="切换随机负载均衡策略，新建两个Module分别绑定8004和8005端口，服务名是CLOUD-PAYMENT-SERVICE1，使用轮询策略，上面说了，MyLoadBalancerRandomConfig要放在-ComponentScan不能扫描到的package中。"><a href="#切换随机负载均衡策略，新建两个Module分别绑定8004和8005端口，服务名是CLOUD-PAYMENT-SERVICE1，使用轮询策略，上面说了，MyLoadBalancerRandomConfig要放在-ComponentScan不能扫描到的package中。" class="headerlink" title="切换随机负载均衡策略，新建两个Module分别绑定8004和8005端口，服务名是CLOUD-PAYMENT-SERVICE1，使用轮询策略，上面说了，MyLoadBalancerRandomConfig要放在@ComponentScan不能扫描到的package中。"></a>切换随机负载均衡策略，新建两个Module分别绑定8004和8005端口，服务名是CLOUD-PAYMENT-SERVICE1，使用轮询策略，上面说了，MyLoadBalancerRandomConfig要放在@ComponentScan不能扫描到的package中。</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">@<span class="hljs-keyword">Configuration</span><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> MyLoadBalancerRandomConfig &#123;<br> <br>    @Bean<br>    <span class="hljs-built_in">public</span> ReactorLoadBalancer&lt;ServiceInstance&gt; reactorServiceInstanceLoadBalancer(Environment environment,<br>                                                                                   LoadBalancerClientFactory loadBalancerClientFactory) &#123;<br>        String <span class="hljs-type">name</span> = environment.getProperty(LoadBalancerClientFactory.PROPERTY_NAME);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> RandomLoadBalancer(<br>                loadBalancerClientFactory.getLazyProvider(<span class="hljs-type">name</span>, ServiceInstanceListSupplier.<span class="hljs-keyword">class</span>), <span class="hljs-type">name</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启动类配置-LoadBalancerClient，配置原来的8001和8002，CLOUD-PAYMENT-SERVICE服务使用随机策略"><a href="#启动类配置-LoadBalancerClient，配置原来的8001和8002，CLOUD-PAYMENT-SERVICE服务使用随机策略" class="headerlink" title="启动类配置@LoadBalancerClient，配置原来的8001和8002，CLOUD-PAYMENT-SERVICE服务使用随机策略"></a>启动类配置@LoadBalancerClient，配置原来的8001和8002，CLOUD-PAYMENT-SERVICE服务使用随机策略</h3><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaClient</span><br><span class="hljs-variable">@LoadBalancerClient</span>(value = <span class="hljs-string">&quot;CLOUD-PAYMENT-SERVICE&quot;</span>, configuration = MyLoadBalancerRandomConfig.class)<br>public class Application6060 &#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(Application6060.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="controller类的修改，getPayment对应轮询，getPaymentWebClient对应随机"><a href="#controller类的修改，getPayment对应轮询，getPaymentWebClient对应随机" class="headerlink" title="controller类的修改，getPayment对应轮询，getPaymentWebClient对应随机"></a>controller类的修改，getPayment对应轮询，getPaymentWebClient对应随机</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/consumer&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerCtrol</span> &#123;<br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> String PAYMENTURL = <span class="hljs-string">&quot;https://CLOUD-PAYMENT-SERVICE&quot;</span>;<span class="hljs-comment">//随机</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> String PAYMENTURL2 = <span class="hljs-string">&quot;https://CLOUD-PAYMENT-SERVICE1&quot;</span>;<span class="hljs-comment">//轮询</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WebClient.Builder clientBuilder;<br> <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getPayment/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> MsgResponseBody getPaymet(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;adada&quot;</span>);<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENTURL2 + <span class="hljs-string">&quot;/payment/getPayment/&quot;</span> + id + <span class="hljs-string">&quot;?userName=123&quot;</span>, MsgResponseBody.<span class="hljs-keyword">class</span>);<br>    &#125;<br> <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/getPayment/webClient/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Mono&lt;MsgResponseBody&gt; getPaymetByWebClient(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;bbbbbbb&quot;</span>);<br>        <span class="hljs-comment">//return restTemplate.getForObject(PAYMENTURL + &quot;/payment/getPayment/&quot; + id + &quot;?userName=123&quot;, MsgResponseBody.class);</span><br>        <span class="hljs-keyword">return</span> clientBuilder.baseUrl(PAYMENTURL).build().<span class="hljs-keyword">get</span>().uri(<span class="hljs-string">&quot;/payment/getPayment/&quot;</span> + id + <span class="hljs-string">&quot;?userName=123&quot;</span>).retrieve().bodyToMono(MsgResponseBody.<span class="hljs-keyword">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>armbian 定时任务</title>
    <link href="/article/74ef2116.html"/>
    <url>/article/74ef2116.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />五个\*分别对应 分 时 日 月 周<p>    &#x2F;1是每1小时对时1次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">sudo crontab -e<span class="hljs-emphasis">* *</span>/1 <span class="hljs-emphasis">* *</span> <span class="hljs-emphasis">* ntpdate ntp1.aliyun.com</span><br></code></pre></td></tr></table></figure><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a068b0b3cfe9d959ce0ce7e91d012dab.png"><a href="https://so.csdn.net/so/search?q=crontab&spm=1001.2101.3001.7020">crontab</a> -l</p><p>查看<a href="https://so.csdn.net/so/search?q=%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&spm=1001.2101.3001.7020">定时任务</a></p><p>systemctl <a href="https://so.csdn.net/so/search?q=enable&spm=1001.2101.3001.7020">enable</a> cron –now</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux设置http代理</title>
    <link href="/article/117f87cd.html"/>
    <url>/article/117f87cd.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />服务器有时为了安全起见，是不允许全网联通，这时需要一个网络代理进行访问，最近我在部署环境时，服务器只能内网间访问，如果想使用yum，[wget](https://so.csdn.net/so/search?q=wget&spm=1001.2101.3001.7020)都不行，十分苦恼，后来运维提供了一个代理解决了该问题。这里分为两种情况讨论：<p><strong>临时使用</strong><br>只是临时使用一下，安装一个软件，只需这样</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">env http_proxy=http:<span class="hljs-regexp">//</span><span class="hljs-number">172.30</span>.<span class="hljs-number">1.145</span>:<span class="hljs-number">3128</span>  https_proxy=http:<span class="hljs-regexp">//</span><span class="hljs-number">172.30</span>.<span class="hljs-number">1.145</span>:<span class="hljs-number">3128</span>   wget or yum<br></code></pre></td></tr></table></figure><p><strong>永久使用</strong><br>在&#x2F;etc&#x2F;profile最后加入</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">export=http_proxy=http:<span class="hljs-regexp">//</span><span class="hljs-number">172.30</span>.<span class="hljs-number">1.145</span>:<span class="hljs-number">3128</span>  https_proxy=http:<span class="hljs-regexp">//</span><span class="hljs-number">172.30</span>.<span class="hljs-number">1.145</span>:<span class="hljs-number">3128</span><span class="hljs-comment">#source 生效环境变量#source /etc/profile</span><br></code></pre></td></tr></table></figure><p>说明：为什么说是http代理，其实这个还不能说是全称走代理，罪名写的区别就是ICMP协议这个设置就无效，只能说是90%的应用都可以使用这个设置来实现代理访问，只有个别不行，比如一些软件根本不走http协议的，那么此种方法绝对不行；下面是讲解http的代理配置，以后会讲解全局级别的代理实现，其实也就是网关，配置网关绝对能100%，这里不做讲解。全局代理配置主要在于环境变量的设置。</p><p>还有网上很多都说http配置代理不支持socks协议，其实是不对的。我测试的结果已经支持了。</p><p>个人理解：我谈一下这个http_proxy的设置，首先，设置了这个变量不是说只会走http协议，上面我说的应该是普通认为会这样说的说法，我后面觉得上面已经是错误了，比如curl，git这些软件默认使用http_proxy这个环境变量来设置代理服务器，所以在linux下只要设置了这个环境变量就能被这些软件识别，而对于代理服务器用什么协议都行，比如使用http协议或者socks协议等。</p><p>那么对于一些比如chrome和yum这些针对http_proxy可能不会生效，比如chrome用的是server_proxy这个变量，而且是在启动时设置才生效。</p><p>下面是代理变量的配置：</p><table><thead><tr><th>环境变量</th><th>描述</th><th>值示例</th></tr></thead><tbody><tr><td>http_proxy</td><td>为http变量设置代理；默认不填开头以http协议传输</td><td>10.0.0.51:8080</td></tr><tr><td>https_proxy</td><td>为https变量设置代理；</td><td>同上</td></tr><tr><td>ftp_proxy</td><td>为ftp变量设置代理；</td><td>同上</td></tr><tr><td>all_proxy</td><td>全部变量设置代理，设置了这个时候上面的不用设置</td><td>同上</td></tr><tr><td>no_proxy</td><td>无需代理的主机或域名；</td><td></td></tr><tr><td>可以使用通配符；</td><td></td><td></td></tr><tr><td>多个时使用“,”号分隔；</td><td>*.aiezu.com,10.*.*.*,192.168.*.*,</td><td></td></tr><tr><td>*.local,localhost,127.0.0.1</td><td></td><td></td></tr></tbody></table><p>针对上面变量的设置方法：</p><p>1、在&#x2F;etc&#x2F;profile文件</p><p>2、在~&#x2F;.bashrc</p><p>3、在~&#x2F;.zshrc</p><p>4、在&#x2F;etc&#x2F;profile.d&#x2F;文件夹下新建一个文件xxx.sh</p><p>写入如下配置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">proxy</span>=<span class="hljs-string">&quot;http://192.168.5.14:8118&quot;</span>export <span class="hljs-attribute">http_proxy</span>=<span class="hljs-variable">$proxyexport</span> <span class="hljs-attribute">https_proxy</span>=<span class="hljs-variable">$proxyexport</span> <span class="hljs-attribute">ftp_proxy</span>=<span class="hljs-variable">$proxyexport</span> <span class="hljs-attribute">no_proxy</span>=<span class="hljs-string">&quot;localhost, 127.0.0.1, ::1&quot;</span><br></code></pre></td></tr></table></figure><p>而对于要取消设置可以使用如下命令，其实也就是取消环境变量的设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">unset</span> http_proxyunset https_proxyunset ftp_proxyunset no_proxy<br></code></pre></td></tr></table></figure><p>针对yum配置走代理：</p><p>经过测试其实只要设置上面的变量之后已经可以走代理了，但如果要单独设置，可以设置如下文件的变量：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">echo <span class="hljs-string">&quot;proxy=http://127.0.0.1:8080/&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/yum</span>.conf<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>maven 推送snashorts包</title>
    <link href="/article/f48fc22b.html"/>
    <url>/article/f48fc22b.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>mvn deploy:deploy-file -DgroupId&#x3D;com.baidu.test -DartifactId&#x3D;hello-service-interface -Dversion&#x3D;1.0.0-SNAPSHOT -Dpackaging&#x3D;jar -Dfile&#x3D;C:\maven\apache-maven-3\repository\com\baidu\test\hello-service-interface\1.0.0-SNAPSHOT\hello-service-interface-1.0.0.jar -Durl&#x3D;<a href="https://test.nexus.com/repository/maven-snapshots">https://test.nexus.com/repository/maven-snapshots</a> -DrepositoryId&#x3D;nexus</p><p>前提<br>本地maven的settings.xml已配置好私服地址。<br>注意service的id。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis6节点集群down的情况</title>
    <link href="/article/788c592a.html"/>
    <url>/article/788c592a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>1.互为主从的两个节点挂掉。<br>2.半数主节点同时挂掉</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis主从切换时间配置</title>
    <link href="/article/b2be028d.html"/>
    <url>/article/b2be028d.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />## redis集群主从节点自动切换<p>最近在将redis作为数据库使用（redis中存放大量数据）的项目中，偶然发现redis的主从节点发生了变化，但是没有任务报错，redis集群的各节点也没有fail状态，因此记录学习一下，redis的深层机制。</p><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>首先redis是单线程的，所有的命令发送的redis会进入一个队列，依次执行。</p><p>当数据量很大时，执行flushall、keys、scan等耗时较长的命令时，就会照成redis节点阻塞。</p><p>其次，了解一下redis的集群节点检测机制。redis集群的其他节点，每隔一断时间，就会向集群中的其他节点发送ping包，以检测节点是否还活着。</p><p>如果此时，某个主节点阻塞了，收到pong包的时间超时，大于 cluster-node-timeout，就会自动切换主从节点。</p><p>此时，在redis-cli中查看cluster nodes，会发现节点会短暂的出现fail状态。</p><p>当主从节点切换完毕，redis又会重新扫描一下集群中的所有redis节点，当阻塞的redis节点，执行完之后，又会重新回到正常状态。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>了解了上面说的redis机制之后，如果想要避免redis节点自动切换就很简单了，只需要调大redis.conf中的配置项cluster-node-timeout（默认15000 millisec）即可。</p><h2 id="Redis的主从复制"><a href="#Redis的主从复制" class="headerlink" title="Redis的主从复制"></a>Redis的主从复制</h2><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>主机数据更新后根据配置和策略，自动同步到从机的master&#x2F;slave机制，Master以写为主，Slave以读为主。</p><h3 id="一主二从"><a href="#一主二从" class="headerlink" title="一主二从"></a>一主二从</h3><p><strong>一主二从原理</strong></p><p>1、配从(库)不配主(库)</p><p>2、配从(库): slaveof 主库IP 主库端口</p><p>3、主写从读、读写分离</p><p>4、从连前后同</p><p>5、主断从待命、从断重新连</p><h3 id="一主二从搭建"><a href="#一主二从搭建" class="headerlink" title="一主二从搭建"></a>一主二从搭建</h3><p><strong>1、一台服务器模拟三台主机：</strong></p><ul><li>第一步：将redis.conf 拷贝三份，名字分别是，redis6379.conf，redis6380.conf，redis6381.conf</li><li>第二步：修改三个文件的port端口，pid文件名，日志文件名，rdb文件名</li></ul><p>如：</p><p><a href="https://www.jb51.net/database/313331pji.htm#">?</a></p><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div><div>2</div><div>3</div><div>4</div></td><td><div><div><code>port 6379</code></div><div><code>pidfile </code><code>/var/run/redis_6379</code><code>.pid</code></div><div><code>logfile “6379.log”</code></div><div><code>dbfilename dump6379.rdb</code></div></div></td></tr></tbody></table><p><a href="javascript:;">登录后复制</a></p><ul><li>第三步：分别打开三个窗口模拟三台服务器，开启redis服务。</li></ul><p>2、查询主从信息：info replication</p><p>3、写操作6379：</p><p>4、设置主从关系：</p><p>在6380和6381主机上分别执行命令：slaveof 127.0.0.1 6379</p><p>另一种方式，就是修改6380和6381的配置文件，在最后加上：</p><p>注意：如果主redis设置了密码，从库的redis.conf中还需要设置masterauth为主redis的密码。</p><p>5、全量复制：在6380和6381分别执行命令get k1</p><p>6、增量复制：6379执行命令：set k2 v2。然后6380端口和6381端口，分别执行命令：get k2</p><p>7、主写从读、读写分离：在6380和6381上执行写操作set k3 v3</p><p>8、主机宕机：6379执行指令shutdown，并查看6380和6381的redis信息 从机原地待命。</p><p>9、主机宕机后恢复：重启6379，并且执行写命令set k4 v4；6380和6381上分别执行get k4 主机重启后，一切正常。</p><p>10、从机宕机：6380执行指令shutdown，并查看6379和6381的redis信息</p><p>11、从机宕机后恢复：重启6380，并查看6380、6379和6381的redis信息</p><p>注意：从机跟master断开联系，必须重新连接，除非写进配置文件。</p><p>12、从机恢复连主机前，主机写操作：6379执行写命令set k5 v5，6380和6381分别执行命令get k5</p><p>13、从机恢复连接主机，6380执行命令：slaveof 127.0.0.1 6379，并且执行命令：get k5</p><p>14、从机上位：</p><ul><li>第一步：主机宕机，6379执行命令：shutdown</li><li>第二步：6380断开主从关系，执行命令：SLAVEOF no one</li><li>第三步：重新搭建主从，6381执行命令：info replication，SLAVEOF 127.0.0.1 6380</li><li>第四步：之前主机恢复，重启6379的Redis服务，并执行命令：info replication</li></ul><p>在6379主机宕机后，6380从机断开主从关系，6381开始还在原地待命；后来6380从机上位，6381投靠6380，6379主机即使回来但它已是孤寡老人，空头司令。</p><p>15、天堂变地狱：6379执行命令saveof 127.0.0.1 6381，并在6379和6381执行info replication</p><p>一台主机配多台从机，一台从机再配多台从机，从而实现了庞大的集群架构。同时也减轻了一台主机的压力，缺点是增加了服务器间的延迟。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>彻底搞懂Redis主从复制原理及实战</title>
    <link href="/article/51e3a86c.html"/>
    <url>/article/51e3a86c.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />## 主从复制概述<p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；</p><p>数据的复制是单向的，只能由主节点到从节点。</p><p>默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p><p>目前很多中小企业都没有使用到 Redis 的集群，但是至少都做了主从。有了主从，当 master 挂掉的时候，运维让从库过来接管，服务就可以继续，否则 master 需要经过数据恢复和重启的过程，这就可能会拖很长的时间，影响线上业务的持续服务。</p><p>Redis主从复制服务器架构图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/1446087-456af4793e1914ca?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Redis主从复制架构图"></p><h4 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h4><p>主从复制的作用主要包括：</p><ul><li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li><li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li><li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li><li><strong>高可用基石</strong>：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li></ul><h2 id="CAP-原理"><a href="#CAP-原理" class="headerlink" title="CAP 原理"></a>CAP 原理</h2><p>在了解 Redis 的主从复制之前，让我们先来理解一下现代分布式系统的理论基石——CAP 原理。</p><p>CAP 原理就好比分布式领域的牛顿定律，它是分布式存储的理论基石。自打 CAP 的论文发表之后，分布式存储中间件犹如雨后春笋般一个一个涌现出来。理解这个原理其实很简单，本节我们首先对这个原理进行一些简单的讲解。</p><ul><li>C - Consistent ，<strong>一致性</strong></li><li>A - Availability ，<strong>可用性</strong></li><li>P - Partition tolerance ，<strong>分区容忍性</strong><br>分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，这个网络断开的场景的专业词汇叫着「<strong>网络分区</strong>」。</li></ul><p>在网络分区发生时，两个分布式节点之间无法进行通信，我们对一个节点进行的修改操作将无法同步到另外一个节点，所以数据的「<strong>一致性</strong>」将无法满足，因为两个分布式节点的数据不再保持一致。除非我们牺牲「<strong>可用性</strong>」，也就是暂停分布式节点服务，在网络分区发生时，不再提供修改数据的功能，直到网络状况完全恢复正常再继续对外提供服务。</p><p>一句话概括 CAP 原理就是——<code>网络分区发生时，一致性和可用性两难全</code>。</p><h4 id="Redis-主从同步最终一致性"><a href="#Redis-主从同步最终一致性" class="headerlink" title="Redis 主从同步最终一致性"></a>Redis 主从同步最终一致性</h4><p>Redis 的主从数据是<code>异步</code>同步的，所以分布式的 Redis 系统并不满足「<strong>一致性</strong>」要求。当客户端在 Redis 的主节点修改了数据后，立即返回，即使在主从网络断开的情况下，主节点依旧可以正常对外提供修改服务，所以 Redis 满足「<strong>可用性</strong>」。</p><p>Redis 保证「<strong>最终一致性</strong>」，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。如果网络断开了，主从节点的数据将会出现大量不一致，一旦网络恢复，从节点会采用多种策略努力追赶上落后的数据，继续尽力保持和主节点一致。</p><h2 id="主从复制的实现原理"><a href="#主从复制的实现原理" class="headerlink" title="主从复制的实现原理"></a>主从复制的实现原理</h2><p>总的来说主从复制功能的详细步骤可以分为7个步骤：</p><ol><li>设置主节点的地址和端口</li><li>建立套接字连接</li><li>发送PING命令</li><li>权限验证</li><li>同步</li><li>命令传播</li></ol><p>接下来分别叙述每个步骤，整个流程图如下：<br><img src="https://git.521566.xyz/https://upload-images.jianshu.io/upload_images/1446087-151d84ec0b9e63a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"><br>为了测试，我在本地机开启两个Redis节点，分别监听：<br>127.0.0.1 6379（主）<br>127.0.0.1 6380（从）<br><img src="https://upload-images.jianshu.io/upload_images/1446087-f91a4b1d26e29434.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h4 id="1-设置主服务器的地址和端口"><a href="#1-设置主服务器的地址和端口" class="headerlink" title="1. 设置主服务器的地址和端口"></a>1. 设置主服务器的地址和端口</h4><p>第一步首先是在从服务器设置需要同步的主服务器信息，包括机器IP, 端口。<br>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</p><p>从节点开启主从复制，有3种方式：</p><p>（1）配置文件</p><p>在从服务器的配置文件中加入：slaveof masterip masterport</p><p>（2）启动命令</p><p>redis-server启动命令后加入 –slaveof masterip masterport</p><p>（3）客户端命令</p><p>Redis服务器启动后，直接通过客户端执行命令：slaveof masterip masterport，则该Redis实例成为从节点。</p><p>上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p><p>完成上面的配置后， 从服务器会将主服务器的ip地址和端口号保存到服务器状态的属性里面。可以Redis使用<code>info Replication</code> 命令分别查看从服务器和主服务器的主从信息</p><h4 id="2-建立套接字连接"><a href="#2-建立套接字连接" class="headerlink" title="2. 建立套接字连接"></a>2. 建立套接字连接</h4><p>在slaveof命令执行之后，从服务器会根据设置的ip和端口，向主服务器简历socket连接。<br>在6380从服务器里面执行完<code>slave of 127.0.0.1 6379</code> 后意味着，从服务器向主服务器发起socket连接<br>在执行info Replication 命令，可以看到6380服务器的角色是slave了<br><img src="https://upload-images.jianshu.io/upload_images/1446087-c720e3b085b69053?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我们在"><br>而6379 服务器已经成为主服务器角色：<br><img src="https://upload-images.jianshu.io/upload_images/1446087-0a2a2e70600d8be5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h4 id="3-发送PING命令"><a href="#3-发送PING命令" class="headerlink" title="3. 发送PING命令"></a>3. 发送PING命令</h4><p>从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是：<strong>检查socket连接是否可用</strong>，以及主节点当前是否能够处理请求。</p><p>从节点发送ping命令后，可能出现3种情况：</p><p>（1）返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</p><p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</p><p>（3）返回pong以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</p><p>主从发送PING命令流程图如下:<br><img src="https://upload-images.jianshu.io/upload_images/1446087-81d4122403b825e2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h4 id="4-身份验证"><a href="#4-身份验证" class="headerlink" title="4. 身份验证"></a>4. 身份验证</h4><p>如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p><p>如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p><p>主从身份验证流程图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1446087-2d99b3e306347f81?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h4 id="5-同步"><a href="#5-同步" class="headerlink" title="5. 同步"></a>5. 同步</h4><p>同步就是将从节点的数据库状态更新成主节点当前的数据库状态。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。<br>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<code>全量复制</code>和<code>部分复制</code><br>下面会有详细介绍全量复制和部分复制内容，这里暂不详述</p><h4 id="6-命令传播"><a href="#6-命令传播" class="headerlink" title="6. 命令传播"></a>6. 命令传播</h4><p>经过上面同步操作，此时主从的数据库状态其实已经一致了，但这种一致的状态的并不是一成不变的。<br>在完成同步之后，也许主服务器马上就接受到了新的写命令，执行完该命令后，主从的数据库状态又不一致。</p><p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p><p>另外命令转播我们需要关注两个点： <code>延迟与不一致</code> 和 <code>心跳机制</code> 我们下面介绍一下</p><p><strong>延迟与不一致</strong><br>需要注意的是，命令传播是<strong>异步</strong>的过程，即主节点发送写命令后并不会等待从节点的回复；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的<code>repl-disable-tcp-nodelay</code>配置等有关。</p><p><code>repl-disable-tcp-nodelay</code> 配置如下：</p><ul><li>假如设置成yes，则redis会合并小的TCP包从而节省带宽，但会增加同步延迟（40ms），造成master与slave数据不一致</li><li>假如设置成no，则redis master会立即发送同步数据，没有延迟</li></ul><p>概括来说就是：<code>前者关注性能，后者关注一致性</code></p><p>具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p><p>一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no</p><p><strong>Redis是如何保证主从服务器一致处于连接状态以及命令是否丢失？</strong><br>答：命令传播阶段，从服务器会利用心跳检测机制定时的向主服务发送消息。<br>心跳机制我们下面再详细说。</p><h2 id="全量复制和部分复制"><a href="#全量复制和部分复制" class="headerlink" title="全量复制和部分复制"></a>全量复制和部分复制</h2><p>在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。后文介绍以Redis2.8及以后版本为例。</p><ol><li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li><li>部分复制：用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li></ol><h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><p>Redis通过psync命令进行全量复制的过程如下：</p><p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行部分复制；具体判断过程需要在讲述了部分复制原理后再介绍。</p><p>（2）主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</p><p>（3）主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态</p><p>（4）主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</p><p>（5）如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态<br><img src="https://upload-images.jianshu.io/upload_images/1446087-4248ddd4cafb8afd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Redis全量复制流程"><br>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p><p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的；关于bgsave的性能问题，可以参考我另外一篇文章： 深入剖析Redis高可用系列：持久化 AOF和RDB</p><p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p><p>（3）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</p><h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><p>由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p><p>部分复制的实现，依赖于三个重要的概念：</p><ol><li>复制偏移量</li><li>复制积压缓冲区</li><li>服务器运行ID(runid)<br>下面我们分别讲解一下这三个概念：</li></ol><h4 id="1-复制偏移量："><a href="#1-复制偏移量：" class="headerlink" title="1. 复制偏移量："></a>1. 复制偏移量：</h4><p>执行复制的双方，主从节点，分别会维护一个复制偏移量offset：<br>主节点每次向从节点同步了N字节数据后，将修改自己的复制偏移量offset+N<br>从节点每次从主节点同步了N字节数据后，将修改自己的复制偏移量offset+N</p><p>offset用于判断主从节点的数据库状态是否一致：<br>如果二者offset相同，则一致；<br>如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p><p>例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p><h4 id="2-复制积压缓冲区："><a href="#2-复制积压缓冲区：" class="headerlink" title="2. 复制积压缓冲区："></a>2. 复制积压缓冲区：</h4><p>主节点内部维护了一个<strong>固定长度的、先进先出(FIFO)队列</strong> 作为复制积压缓冲区，其默认大小为1MB<br>在主节点进行命令传播时，不仅会将写命令同步到从节点，还会将写命令写入复制积压缓冲区。</p><p>由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。因此，<strong>当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</strong></p><p>为了提高网络中断时<strong>部分复制</strong>执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置<code>repl-backlog-size</code>)；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p><p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p><ul><li>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行<strong>部分复制</strong>；</li><li>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行<strong>全量复制</strong>。</li></ul><p>复制积压缓冲区示意图：<br><img src="https://upload-images.jianshu.io/upload_images/1446087-09c94ff5186a5b57?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></p><h4 id="3-服务器运行ID-runid-："><a href="#3-服务器运行ID-runid-：" class="headerlink" title="3. 服务器运行ID(runid)："></a>3. 服务器运行ID(runid)：</h4><p>每个Redis节点，都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点，从节点会将主节点的运行ID存起来。<br>从节点Redis断开重连的时候，就是根据运行ID来判断同步的进度：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><h3 id="psync-命令的执行"><a href="#psync-命令的执行" class="headerlink" title="psync 命令的执行"></a>psync 命令的执行</h3><p>在了解了复制偏移量、复制积压缓冲区、节点运行id之后，本节将介绍psync命令的参数和返回值，从而说明psync命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。<br>psync命令流程图如下：<br><img src="https://upload-images.jianshu.io/upload_images/1446087-50f80af53e5d7259?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"><br>psync命令的大体流程如下：</p><ul><li>如果从节点之前没有复制过任何主节点，或者之前执行过slaveof no one命令，从节点就会向主节点发送<code>psync</code>命令，请求主节点进行数据的全量同步</li><li>如果前面从节点已经同步过部分数据，此时从节点就会发送psync {runid} {offset}命令给主节点，其中runid是上一次主节点的运行ID，offset是当前从节点的复制偏移量</li></ul><p>主节点收到psync命令后，会出现以下三种可能：</p><ul><li>主节点返回 fullresync {runid} {offset}回复，表示主节点要求与从节点进行数据的完整全量复制，其中runid表示主节点的运行ID，offset表示当前主节点的复制偏移量</li><li>如果主服务器返回 +continue，表示主节点与从节点会进行部分数据的同步操作，将从服务器缺失的数据复制过来即可</li><li>如果主服务器返回 -err，表示主服务器的Redis版本低于2.8，无法识别psync命令，此时从服务器会向主服务器发送sync命令，进行完整的数据全量复制</li></ul><h2 id="心跳检测机制"><a href="#心跳检测机制" class="headerlink" title="心跳检测机制"></a>心跳检测机制</h2><p>心跳检测机制的作用有三个：</p><ol><li>检查主从服务器的网络连接状态</li><li>辅助实现min-slaves选项</li><li>检测命令丢失</li></ol><h4 id="检查主从服务器的网络连接状态"><a href="#检查主从服务器的网络连接状态" class="headerlink" title="检查主从服务器的网络连接状态"></a>检查主从服务器的网络连接状态</h4><p>主节点信息中可以看到所属的从节点的连接信息：</p><ul><li>state 表示从节点状态</li><li>offset 表示复制偏移量</li><li>lag 表示延迟值（几秒之前有过心跳检测机制）<br><img src="https://upload-images.jianshu.io/upload_images/1446087-9d6ee7dfbf773436.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在这里插入图片描述"></li></ul><h4 id="辅助实现min-slaves选项"><a href="#辅助实现min-slaves选项" class="headerlink" title="辅助实现min-slaves选项"></a>辅助实现min-slaves选项</h4><p>Redis.conf配置文件中有下方两个参数</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 未达到下面两个条件时，写操作就不会被执行</span><br><span class="hljs-meta"># 最少包含的从服务器</span><br><span class="hljs-meta"># min-slaves-to-write 3</span><br><span class="hljs-meta"># 延迟值</span><br><span class="hljs-meta"># min-slaves-max-lag 10</span><br></code></pre></td></tr></table></figure><p>如果将两个参数的注释取消，那么如果从服务器的数量少于3个，或者三个从服务器的延迟（lag）大于等于10秒时，主服务器都会拒绝执行写命令。</p><h4 id="检测命令丢失"><a href="#检测命令丢失" class="headerlink" title="检测命令丢失"></a>检测命令丢失</h4><p>在从服务器的连接信息中可以看到复制偏移量，如果此时主服务器的复制偏移量与从服务器的复制偏移量不一致时，主服务器会补发缺失的数据。</p><h2 id="实践中的问题"><a href="#实践中的问题" class="headerlink" title="实践中的问题"></a>实践中的问题</h2><h3 id="1-读写分离及其中的问题"><a href="#1-读写分离及其中的问题" class="headerlink" title="1.读写分离及其中的问题"></a>1.读写分离及其中的问题</h3><p>在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。下面介绍在使用Redis读写分离时，需要注意的问题。</p><p><strong>1. 延迟与不一致问题</strong><br>前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。</p><p>在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的slave-serve-stale-data参数便与此有关：它控制这种情况下从节点的表现；如果为yes（默认值），则从节点仍能够响应客户端的命令，如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。</p><p><strong>2. 数据过期问题</strong><br>在单机版Redis中，存在两种删除策略：</p><p>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。<br>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。<br>在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p><p>Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题。</p><p><strong>3. 故障切换问题</strong><br>在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p><p><strong>4. 总结</strong><br>在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p><h3 id="2-复制超时问题"><a href="#2-复制超时问题" class="headerlink" title="2. 复制超时问题"></a>2. 复制超时问题</h3><p>主从节点复制超时是导致复制中断的最重要的原因之一，本小节单独说明超时问题，下一小节说明其他会导致复制中断的问题。</p><p>超时判断意义</p><p>在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于：</p><ol><li><p>如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。</p></li><li><p>如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。</p></li></ol><p>判断机制</p><p>主从复制超时判断的核心，在于repl-timeout参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效；主从节点触发超时的条件分别如下：</p><ol><li><p>主节点：每秒1次调用复制定时函数replicationCron()，在其中判断当前时间距离上次收到各个从节点REPLCONF ACK的时间，是否超过了repl-timeout值，如果超过了则释放相应从节点的连接。</p></li><li><p>从节点：从节点对超时的判断同样是在复制定时函数中判断，基本逻辑是：</p><ul><li>如果当前处于连接建立阶段，且距离上次收到主节点的信息的时间已超过repl-timeout，则释放与主节点的连接；</li><li>如果当前处于数据同步阶段，且收到主节点的RDB文件的时间超时，则停止数据同步，释放连接；</li><li>如果当前处于命令传播阶段，且距离上次收到主节点的PING命令或数据的时间已超过repl-timeout值，则释放与主节点的连接。</li></ul></li></ol><p><strong>需要注意的坑</strong></p><p>下面介绍与复制阶段连接超时有关的一些实际问题：</p><ol><li><p>数据同步阶段：在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。</p></li><li><p>命令传播阶段：如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时。</p></li><li><p>慢查询导致的阻塞：如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redis 高可用系列的第二弹：主从复制的核心内容已经讲解完毕了，希望大家阅读完会有一点收获，另外如果大家觉得看完文章有帮助的话，可以点赞，收藏微微表示一下支持，好让我能有动力继续写技术文章。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmqctl 命令指南</title>
    <link href="/article/f5d79d26.html"/>
    <url>/article/f5d79d26.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h1 id="名称"><a href="#名称" class="headerlink" title="名称"></a>名称</h1><p>rabbitmqctl — 用于管理中间件的命令行工具</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>rabbitmqctl [-n _node_] [-t _timeout_] [-q] {<em>command</em>} [<em>command options</em>…]</p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>RabbitMQ是AMQP的实现, 后者是高性能企业消息通信的新兴标准. RabbitMQ server是AMQP 中间件健壮的，可扩展的实现.</p><p><strong>rabbitmqctl</strong> 用来管理RabbitMQ中间件的命令行工具.它通过连接中间件节点来执行所有操作。</p><p>如果中间件没有运行，将会显示诊断信息, 不能到达，或因不匹配Erlang cookie而拒绝连接.</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>[-n _node_]</p><p>默认节点是”rabbit@server”,此处的server是本地主机. 在一个名为”server.example.com”的主机上, RabbitMQ Erlang node 的节点名称通常是rabbit@server (除非RABBITMQ_NODENAME在启动时设置了非默认值). <strong>hostname -s</strong> 的输出通常是”@” 标志后的东西.查看rabbitmq-server(1)来了解配置RabbitMQ broker的细节.</p><p>[-q]</p><p>使用-q标志来启用宁静(quiet)模式，这会一致消息输出.</p><p>[-t _timeout_]</p><p>操作超时时间（秒为单位）. 只适用于”list” 命令. 默认是无穷大.</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="应用程序和集群管理"><a href="#应用程序和集群管理" class="headerlink" title="应用程序和集群管理"></a>应用程序和集群管理</h3><h3 id="stop-pid-file"><a href="#stop-pid-file" class="headerlink" title="stop [_pid_file_]"></a>stop [_pid_file_]</h3><p>用于停止运行RabbitMQ的Erlang node.如果指定了pid_file，还将等待指定的过程结束。例如：</p><p>rabbitmqctl stop</p><p>此命令会终止RabbitMQ node的运行.</p><p>stop_app</p><p>停止RabbitMQ application,但Erlang node会继续运行.此命令主要用于优先执行其它管理操作（这些管理操作需要先停止RabbitMQ application），如. <a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#reset"><strong>reset</strong></a>.例如：</p><p>rabbitmqctl stop_app</p><p>start_app</p><p>启动RabbitMQ application.</p><p>此命令典型用于在执行了其它管理操作之后，重新启动停止的RabbitMQ application。如<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#reset"><strong>reset</strong></a>.例如：</p><p>rabbitmqctl start_app</p><p>此命令来指导RabbitMQ node来启动RabbitMQ application.</p><p>wait {<em>pid_file</em>}</p><p>等待RabbitMQ application启动.此命令用来等待RabbitMQ application来启动node。它会等待创建pid文件，然后等待pid文件中的特定pid过程启动，最后等待RabbitMQ  application 来启动node. </p><p>pid file是通过<strong>rabbitmq-server</strong> 脚本来创建的.默认情况下，它存放于Mnesia目录中. 修改<strong>RABBITMQ_PID_FILE</strong> 环境变量可以改变此位置。如：</p><p>rabbitmqctl wait &#x2F;var&#x2F;run&#x2F;rabbitmq&#x2F;pid</p><p>此命令会在RabbitMQ node启动后返回.</p><p>reset</p><p>将RabbitMQ node还原到最初状态.包括从所在群集中删除此node,从管理数据库中删除所有配置数据，如已配置的用户和虚拟主机，以及删除所有持久化消息.</p><p>执行<strong>reset和****force_reset之前，必须停止</strong>RabbitMQ application ,如使用<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#stop_app"><strong>stop_app</strong></a>.</p><p>示例:</p><p>rabbitmqctl reset</p><p>此命令会重设RabbitMQ　node.</p><p>force_reset</p><p>强制RabbitMQ node还原到最初状态.</p><p>不同于<strong>reset</strong> ， <strong>force_reset</strong> 命令会无条件地重设node,不论当前管理数据库的状态和集群配置是什么. 它只能在数据库或集群配置已损坏的情况下才可使用。</p><p>执行<strong>reset和****force_reset之前，必须停止</strong>RabbitMQ application ,如使用<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#stop_app"><strong>stop_app</strong></a>.</p><p>示例:</p><p>rabbitmqctl force_reset</p><p>此命令会重设RabbitMQnode.</p><p>rotate_logs {<em>suffix</em>}</p><p>指示RabbitMQ node循环日志文件.</p><p>RabbitMQ 中间件会将原来日志文件中的内容追加到原始名称和后辍的日志文件中，然后再将原始日志文件内容复制到新创建的日志上。实际上，当前日志内容会移到以此后辍结尾的文件上。当目标文件不存在时，将会进行创建。如果不指定后辍，则不会发生循环，日志文件只是重新打开。示例：</p><p>rabbitmqctl rotate_logs .1</p><p>此命令指示RabbitMQ node将日志文件的内容追加到新日志文件（文件名由原日志文件名和.1后辍构成）中。如. <a href="mailto:&#x72;&#x61;&#x62;&#x62;&#105;&#116;&#x40;&#x6d;&#121;&#x6d;&#97;&#99;&#104;&#x69;&#110;&#101;&#46;&#x6c;&#111;&#x67;&#46;&#x31;">&#x72;&#x61;&#x62;&#x62;&#105;&#116;&#x40;&#x6d;&#121;&#x6d;&#97;&#99;&#104;&#x69;&#110;&#101;&#46;&#x6c;&#111;&#x67;&#46;&#x31;</a> 和 <a href="mailto:&#114;&#x61;&#98;&#x62;&#105;&#116;&#x40;&#109;&#121;&#x6d;&#97;&#99;&#104;&#x69;&#110;&#x65;&#45;&#115;&#x61;&#x73;&#x6c;&#46;&#x6c;&#111;&#x67;&#46;&#49;">&#114;&#x61;&#98;&#x62;&#105;&#116;&#x40;&#109;&#121;&#x6d;&#97;&#99;&#104;&#x69;&#110;&#x65;&#45;&#115;&#x61;&#x73;&#x6c;&#46;&#x6c;&#111;&#x67;&#46;&#49;</a>. 最后, 日志会在原始位置恢复到新文件中.</p><h3 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h3><p>join_cluster {<em>clusternode</em>} [–ram]</p><p>clusternode</p><p>加入集群的节点.</p><p>[–ram]</p><p>如果进行了设置，节点将以RAM节点身份加入集群.</p><p>指导节点成为集群中的一员. 在加入集群之前，节点会重置,因此在使用此命令时，必须小心. 这个命令要成功,RabbitMQ应用程序必须先停止,如<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#stop_app"><strong>stop_app</strong></a>.</p><p>集群节点可以是两种类型: 磁盘节点(Disc Node) 或 内存节点(RAM Node).磁盘节点会在RAM和磁盘中复制数据, 通过冗余可以防止节点失效事件，并可从断电这种全局事件中进行恢复. RAM节点只在RAM中复制数据(除了队列的内容外，还依赖于队列是否是持久化的或者内容对于内存来说是否过大) ，并主要用于可伸缩性. RAM节点只有当管理资源(如，增加&#x2F;删除队列,交换机,或绑定)的时候才具有更高的性能.一个集群必须至少有一个磁盘节点，通常来说还不止一个.</p><p>默认情况下，节点是磁盘节点.如果你想要创建内存节点,需要提供<strong>--ram</strong> 标志.</p><p>在执行<strong>cluster</strong>命令之后, 无论何时，当前节点上启动的RabbitMQ 应用程序在节点宕机的情况下，会尝试连接集群中的其它节点。</p><p>要脱离集群, 必须重设(reset)节点. 你也可以通过<strong>forget_cluster_node</strong> 命令来远程删除节点.</p><p>更多详情，参考<a href="http://www.rabbitmq.com/clustering.html">集群指南</a>.</p><p>例如:</p><p>rabbitmqctl join_cluster hare@elena –ram</p><p>此命令用于指示RabbitMQ node以ram节点的形式将 <strong>hare@elena</strong> 加入集群.</p><p>cluster_status</p><p>按节点类型来分组展示集群中的所有节点，包括当前运行的节点.</p><p>例如:</p><p>rabbitmqctl cluster_status</p><p>此命令会显示集群中的所有节点.</p><p>change_cluster_node_type {disc | ram}</p><p>修改集群节点的类型. 要成功执行此操作，必须首先停止节点，要将节点转换为RAM节点，则此节点不能是集群中的唯一disc节点。</p><p>例如:</p><p>rabbitmqctl change_cluster_node_type disc</p><p>此命令会将一个RAM节点转换为disc节点.</p><p>forget_cluster_node [–offline]</p><p>[–offline]</p><p>允许节点从脱机节点中删除. 这只在所有节点都脱机且最后一个掉线节点不能再上线的情况下有用，从而防止整个集群从启动。它不能使用在其它情况下，因为这会导致不一致．</p><p>远程删除一个集群节点.要删除的节点必须是脱机的, 而在删除节点期间节点必须是在线的，除非使用了<strong>--offline</strong> 标志.</p><p>当使用<strong>--offline</strong> 标志时，rabbitmqctl不会尝试正常连接节点;相反，它会临时改变节点以作修改.如果节点不能正常启动的话，这是非常有用的.在这种情况下，节点将变成集群元数据的规范源（例如，队列的存在），即使它不是以前的。因此，如果有可能，你应该在最新的节点上使用这个命令来关闭。</p><p>例如:</p><p>rabbitmqctl -n hare@mcnulty forget_cluster_node rabbit@stringer</p><p>此命令会从节点<strong>hare@mcnulty中删除****rabbit@stringer节点</strong>.</p><p>rename_cluster_node {oldnode1} {newnode1} [oldnode2] [newnode2 …]</p><p>支持在本地数据库中重命名集群节点.</p><p>此子命令会促使rabbitmqctl临时改变节点以作出修改. 因此本地集群必须是停止的，其它节点可以是在线或离线的．</p><p>这个子命令接偶数个参数，成对表示节点的旧名称和新名称.你必须指定节点的旧名称和新名称，因为其它停止的节点也可能在同一时间重命名.</p><p>同时停止所有节点来重命名也是可以的(在这种情况下，每个节点都必须给出旧名称和新名称)或一次停止一个节点来重命名(在这种情况下，每个节点只需要被告知其名句是如何变化的).</p><p>例如:</p><p>rabbitmqctl rename_cluster_node rabbit@misshelpful rabbit@cordelia</p><p>此命令来将节点名称<strong>rabbit@misshelpful</strong> 重命名为<strong>rabbit@cordelia</strong>.</p><p>update_cluster_nodes {clusternode}</p><p>clusternode</p><p>用于咨询具有最新消息的节点.</p><p>指示已集群的节点醒来时联系<strong>clusternode</strong>.这不同于<strong>join_cluster</strong> ，因为它不会加入任何集群 - 它会检查节点已经以<strong>clusternode</strong>的形式存在于集群中了．</p><p>需要这个命令的动机是当节点离线时，集群可以变化.考虑这样的情况，节点Ａ和节点Ｂ都在集群里边，这里节点Ａ掉线了，Ｃ又和Ｂ集群了，然后Ｂ又离开了集群．当Ａ醒来的时候，它会尝试联系Ｂ，但这会失败，因为Ｂ已经不在集群中了.<strong>update_cluster_nodes -n A C</strong> 可解决这种场景．</p><p>force_boot</p><p>确保节点将在下一次启动，即使它不是最后一个关闭的。通常情况下，当你关闭整个RabbitMQ 集群时，你重启的第一个节点应该是最后一个下线的节点，因为它可以看到其它节点所看不到的事情. 但有时这是不可能的:例如，如果整个集群是失去了电力而所有节点都在想它不是最后一个关闭的．</p><p>在这种节点掉线情况下，你可以调用<strong>rabbitmqctl force_boot</strong> ．这就告诉节点下一次无条件的启动节点.在此节点关闭后，集群的任何变化，它都会丢失．</p><p>如果最后一个掉线的节点永久丢失了，那么你需要优先使用<strong>rabbitmqctl forget_cluster_node –offline</strong>, 因为它可以确保在丢失的节点上掌握的镜像队列得到提升。</p><p>例如:</p><p>rabbitmqctl force_boot</p><p>这可以强制节点下次启动时不用等待其它节点．</p><p>sync_queue [-p _vhost_] {queue}</p><p>queue</p><p>同步队列的名称</p><p>指示未同步slaves上的镜像队列自行同步.同步发生时，队列会阻塞(所有出入队列的发布者和消费者都会阻塞).此命令成功执行后，队列必须是镜像的．</p><p>注意，未同步队列中的消息被耗尽后，最终也会变成同步. 此命令主要用于未耗尽的队列。</p><p>cancel_sync_queue [-p _vhost_] {queue}</p><p>queue</p><p>取消同步的队列名称.</p><p>指示同步镜像队列停止同步.</p><p>purge_queue [-p _vhost_] {queue}</p><p>queue</p><p>要清除队列的名称.</p><p>清除队列(删除其中的所有消息).</p><p>set_cluster_name {name}</p><p>设置集群名称. 集群名称在client连接时，会通报给client,也可用于federation和shovel插件记录消息的来源地. 群集名称默认是来自在群集中的第一个节点的主机名，但可以改变。</p><p>例如:</p><p>rabbitmqctl set_cluster_name london</p><p>设置集群名称为”london”.</p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>注意<strong>rabbitmqctl</strong> 管理RabbitMQ 内部用户数据库. 任何来自其它认证后端的用户对于<strong>rabbitmqctl</strong>来说是不可见的.</p><p>add_user {<em>username</em>} {<em>password</em>}</p><p>username</p><p>要创建的用户名称.</p><p>password</p><p>设置创建用户登录broker的密码.       </p><p>rabbitmqctl add_user tonyg changeit</p><p>此命令用于指示RabbitMQ broker 创建一个拥有非管理权限的用户，其名称为<strong>tonyg，</strong> 初始密码为<strong>changeit</strong>.</p><p>delete_user {<em>username</em>}</p><p>username</p><p>要删除的用户名称.</p><p>例如:</p><p>rabbitmqctl delete_user tonyg</p><p>此命令用于指示RabbitMQ broker删除名为<strong>tonyg的用户</strong></p><p>change_password {<em>username</em>} {<em>newpassword</em>}</p><p>username</p><p>要修改密码的用户名称.</p><p>newpassword</p><p>用户的新密码.</p><p>例如:</p><p>rabbitmqctl change_password tonyg newpass</p><p>此命令用于指定RabbitMQ broker将<strong>tonyg</strong> 用户的密码修改为<strong>newpass</strong>.</p><p>clear_password {<em>username</em>}</p><p>username</p><p>要清除密码的用户名称.</p><p>例如:</p><p>rabbitmqctl clear_password tonyg</p><p>此命令会指示RabbitMQ broker清除名为tonyg的用户密码.现在，此用户不能使用密码登录(但可以通过SASL EXTERNAL登录，如果配置了的话).</p><p>authenticate_user {<em>username</em>} {<em>password</em>}</p><p>username</p><p>用户的名称.</p><p>password</p><p>用户的密码.</p><p>例如:</p><p>rabbitmqctl authenticate_user tonyg verifyit</p><p>此命令会指示RabbitMQ broker以名称为tonyg， 密码为verifyit来进行验证.</p><p>set_user_tags {<em>username</em>} {<em>tag</em> …}</p><p>username</p><p>要设置tag的用户名称.</p><p>tag</p><p>用于设置0个，1个或多个tags.任何现有的tags都将被删除.</p><p>例如:</p><p>rabbitmqctl set_user_tags tonyg administrator</p><p>此命令指示RabbitMQ broker用于确保<strong>tonyg</strong> 是administrator.当通过AMQP来登录时，这没有什么效果,但用户通过其它的途经来登录时，它可用来管理用户,虚拟主机和权限(如使用管理插件).</p><p>rabbitmqctl set_user_tags tonyg</p><p>此命令会指示RabbitMQ broker删除tonyg上的任何现有的tag.</p><p>list_users</p><p>列出用户. 每个结果行都包含用户名，其后紧跟用户的tags.</p><p>例如:</p><p>rabbitmqctl list_users</p><p>此命令指示RabbitMQ broker列出所有用户.</p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>注意<strong>rabbitmqctl</strong> 会管理RabbitMQ的内部用户数据库. 无权限的用户将不能使用<strong>rabbitmqctl</strong>.</p><p>add_vhost {<em>vhost</em>}</p><p>vhost</p><p>要创建虚拟主机名称.</p><p>创建一个虚拟主机.</p><p>例如:</p><p>rabbitmqctl add_vhost test</p><p>此命令指示RabbitMQ broker来创建一个新的名为test的虚拟主机.</p><p>delete_vhost {<em>vhost</em>}</p><p>vhost</p><p>要删除的虚拟主机的名称.</p><p>删除一个虚拟主机.</p><p>删除一个虚拟主机，同时也会删除所有交换机，队列，绑定，用户权限，参数和策略.</p><p>例如:</p><p>rabbitmqctl delete_vhost test</p><p>此命令指示RabbitMQ broker删除名为test的虚拟主机.</p><p>list_vhosts [<em>vhostinfoitem</em> …]</p><p>列出所有虚拟主机.</p><p><strong>vhostinfoitem</strong> 参数用于标识哪些虚拟主机应该包含在结果集中.结果集中的列顺序会匹配参数的顺序.<strong>vhostinfoitem</strong> 可接受下面的值：</p><p>name</p><p>虚拟主机的名称.</p><p>tracing</p><p>是否对虚拟主机启用追踪.</p><p>如果没有指定<strong>vhostinfoitem</strong> 参数，那么会显示虚拟主机名称.</p><p>例如：</p><p>rabbitmqctl list_vhosts name tracing</p><p>此命令用于指示RabbitMQ broker显示所有虚拟主机.</p><p>set_permissions [-p _vhost_] {<em>user</em>} {<em>conf</em>} {<em>write</em>} {<em>read</em>}</p><p>vhost</p><p>授予用户可访问的虚拟机名称，默认是**&#x2F;**.</p><p>user</p><p>可访问指定虚拟主机的用户名称.</p><p>conf</p><p>一个用于匹配用户在哪些资源名称上拥有配置权限的正则表达式</p><p>write</p><p>一个用于匹配用户在哪些资源名称上拥有写权限的正则表达式.</p><p>read</p><p>一个用于匹配用户在哪些资源名称上拥有读权限的正则表达式.</p><p>设置用户权限.</p><p>例如:</p><p>rabbitmqctl set_permissions -p &#x2F;myvhost tonyg “^tonyg-.*“ “.*“ “.*“</p><p>此命令表示RabbitMQ broker授予<strong>tonyg</strong> 用户可访问 <strong>&#x2F;myvhost虚拟主机</strong>,并在资源名称以”tonyg-“开头的所有资源上都具有配置权限，并在所有资源上都拥有读写权限。</p><p>clear_permissions [-p _vhost_] {<em>username</em>}</p><p>vhost</p><p>用于设置禁止用户访问的虚拟主机名称,默认为**&#x2F;**.</p><p>username</p><p>禁止访问特定虚拟主机的用户名称.</p><p>设置用户权限.</p><p>例如:</p><p>rabbitmqctl clear_permissions -p &#x2F;myvhost tonyg</p><p>此命令用于指示RabbitMQ broker禁止tonyg 用户访问&#x2F;myvhost虚拟主机.</p><p>list_permissions [-p _vhost_]</p><p>vhost</p><p>用于指定虚拟主机名称，将会列出所有可访问此虚拟主机的所有用户名称和权限.默认为**&#x2F;**.</p><p>显示虚拟机上权限.</p><p>例如:</p><p>rabbitmqctl list_permissions -p &#x2F;myvhost</p><p>此命令指示RabbitMQ broker列出所有已授权访问**&#x2F;myvhost** 虚拟主机的用户，同时也会列出这些用户能在虚拟主机资源可操作的权限.注意，空字符串表示没有任何授予的权限。</p><p>list_user_permissions {<em>username</em>}</p><p>username</p><p>要显示权限的用户名称.</p><p>列出用户权限.</p><p>例如:</p><p>rabbitmqctl list_user_permissions tonyg</p><p>此命令指示RabbitMQ broker列出tonyg可授权访问的所有虚拟主机名称，以及在这些虚拟主机上的操作.</p><h3 id="参数管理"><a href="#参数管理" class="headerlink" title="参数管理"></a>参数管理</h3><p>RabbitMQ的某些特性(如联合插件)是动态控制的. 每个参数都是与特定虚拟主机相关的组件名称, name和value构成的. 组件名称和name都是字符串,值是Erlang term. 参数可被设置，清除和显示.通常你可以参考文档来了解如何设置参数.</p><p>set_parameter [-p _vhost_] {<em>component_name</em>} {<em>name</em>} {<em>value</em>}</p><p>设置一个参数.</p><p>component_name</p><p>要设置的组件名称.</p><p>name</p><p>要设置的参数名称.</p><p>value</p><p>要设置的参数值，作不JSON项。在多数shells中，你更喜欢将其引起来.</p><p>例如:</p><p>rabbitmqctl set_parameter federation local_username ‘“guest”‘</p><p>此命令用于在默认虚拟主机上设置<strong>federation</strong> 组件的<strong>local_username 参数值</strong><strong>“guest”</strong>.</p><p>clear_parameter [-p _vhost_] {<em>component_name</em>} {<em>key</em>}</p><p>清除参数.</p><p>component_name</p><p>要清除参数的组件名称.</p><p>name</p><p>要清除的参数名称.</p><p>例如:</p><p>rabbitmqctl clear_parameter federation local_username</p><p>此命令用于清除默认虚拟主机上的<strong>federation</strong> 组件的<strong>local_username</strong> 参数值.</p><p>list_parameters [-p _vhost_]</p><p>列出虚拟主机上的所有参数.</p><p>示例:</p><p>rabbitmqctl list_parameters</p><p>此命令用于列出默认虚拟主机上的所有参数.</p><h3 id="策略管理"><a href="#策略管理" class="headerlink" title="策略管理"></a>策略管理</h3><p>策略用于在集群范围的基础上用于控制和修改队列和交换机的行为. 策略应用于虚拟主机,由name, pattern, definition或可选的priority组成. 策略可被设置，清除和列举.</p><p>set_policy [-p _vhost_] [–priority _priority_] [–apply-to _apply-to_] {<em>name</em>} {<em>pattern</em>} {<em>definition</em>}</p><p>设置策略.</p><p>name</p><p>策略名称.</p><p>pattern</p><p>正则表达式, 匹配要应用的资源</p><p>definition</p><p>策略的定义,JSON形式．在大多数shells中，你很可能需要引用这个</p><p>priority</p><p>策略的整数优先级. 数字越高则优先级越高.默认是０.</p><p>apply-to</p><p>策略适用的对象类型，其值可为 “queues”, “exchanges” 或 “all”.默认是”all”.</p><p>例如:</p><p>rabbitmqctl set_policy federate-me “^amq.” ‘{“federation-upstream-set”:”all”}’</p><p>此命令在默认虚拟主机上设置策略为<strong>federate-me，</strong>这样内建的交换器将进行联合.</p><p>clear_policy [-p _vhost_] {<em>name</em>}</p><p>清除策略.</p><p>name</p><p>要清除的策略名称.</p><p>例如:</p><p>rabbitmqctl clear_policy federate-me</p><p>此命令来清除默认虚拟主机上的<strong>federate-me</strong> 策略.</p><p>list_policies [-p _vhost_]</p><p>显示虚拟主机上的所有策略.</p><p>例如:</p><p>rabbitmqctl list_policies</p><p>此命令会显示默认虚拟主机上的所有策略.</p><h3 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h3><p>服务器状态查询查询服务器返回一个结果以制表符分隔的列表. 某些查询(<strong>list_queues</strong>, <strong>list_exchanges</strong>, <strong>list_bindings</strong>, 和 <strong>list_consumers</strong>) 接受一个可选的<strong>vhost</strong> 参数. 如果这个参数出现了，那么它必须指定在查询的后面.</p><p>list_queues, list_exchanges and list_bindings 命令接受一个可选的虚拟主机参数以显示其结果．默认值为”&#x2F;“.</p><p>list_queues [-p _vhost_] [<em>queueinfoitem</em> …]</p><p>返回队列的详细信息. 如果无-p标志，将显示／虚拟主机上的队列详情．”-p” 标志可用来覆盖此默认值．</p><p><strong>queueinfoitem</strong> 参数用于指示哪些队列信息项会包含在结果集中.结果集的列顺序将匹配参数的顺序.<strong>queueinfoitem</strong> 可以是下面列表中的任何值:</p><p>name</p><p>非ASCII字符的队列名称.</p><p>durable</p><p>服务器重启后，队列是否能幸存.</p><p>auto_delete</p><p>不再使用时，是否需要自动删除队列.</p><p>arguments</p><p>队列参数.</p><p>policy</p><p>应用到队列上的策略名称.</p><p>pid</p><p>关联队列的Erlang进程ID.</p><p>owner_pid</p><p>表示队列专用所有者的代表连接的Erlang进程ID.如果队列是非专用的，此值将为空．</p><p>exclusive</p><p>True:如果队列是专用的(即有owner_pid), 反之false</p><p>exclusive_consumer_pid</p><p>表示此channel的专用消费者订阅到此队列的Erlang进程Id. 如果没有专用消费者，则为空．</p><p>exclusive_consumer_tag</p><p>专用消费者订阅到此队列的Consumer tag.如果没有专用消费者，则为空.</p><p>messages_ready</p><p>准备分发给客户端的消息数目.</p><p>messages_unacknowledged</p><p>分发到客户端但尚未应答的消息数目.</p><p>messages</p><p>准备分发和未应答消息的总和(队列深度).</p><p>messages_ready_ram</p><p>驻留在ram中messages_ready的消息数目.</p><p>messages_unacknowledged_ram</p><p>驻留在ram中messages_unacknowledged的消息数目.</p><p>messages_ram</p><p>驻留在ram中的消息总数.</p><p>messages_persistent</p><p>队列中持久化消息的数目(对于瞬时队列总是0).</p><p>message_bytes</p><p>队列中所有消息体的大小总和.这不包括消息属性(包括headers) 或任何开销(overhead)。</p><p>message_bytes_ready</p><p>类似于<strong>message_bytes</strong> ，但只统计准备投递给clients的那些消息．</p><p>message_bytes_unacknowledged</p><p>类似于<strong>message_bytes</strong> ，但只统计那些已经投递给clients但还未应答的消息</p><p>message_bytes_ram</p><p>类似于<strong>message_bytes</strong> ，但只统计那些在RAM中的消息</p><p>message_bytes_persistent</p><p>类似于<strong>message_bytes</strong> ，但只统计那些持久化的消息</p><p>head_message_timestamp</p><p>如果存在，只显示队列中第１个消息的timestamp属性. 消息的时间戳只出现在分页情况下．</p><p>disk_reads</p><p>从队列启动开如，已从磁盘上读取该队列的消息总次数.</p><p>disk_writes</p><p>从队列启动开始，已向磁盘队列写消息总次数.</p><p>consumers</p><p>消费者数目.</p><p>consumer_utilisation</p><p>时间分数(0.0与1.0之间)，队列可立即向消费者投递消息. 它可以小于1.0，如果消费者受限于网络堵塞或预提取数量.</p><p>memory</p><p>与队列相关的Erlang进程消耗的内存字节数,包括栈,堆以及内部结构.</p><p>slave_pids</p><p>如果队列是镜像的，这里给出的是当前slaves的IDs.</p><p>synchronised_slave_pids</p><p>如果队列是镜像的，当前slaves的IDs是master同步的- 即它们可在无消息丢失的情况下，接管master.</p><p>state</p><p>队列状态.正常情况下是’running’, 但如果队列正在同步也可能是”{syncing, MsgCount}”. 处于集群下的节点如果掉线了，队列状态交显示’down’ (大多数<strong>queueinfoitem</strong>s 将不可用).</p><p>如果没有指定<strong>queueinfoitem</strong>s，那么将显示队列名称和队列深度．</p><p>例如:</p><p>rabbitmqctl list_queues -p &#x2F;myvhost messages consumers</p><p>此命令显示了**&#x2F;myvhost**虚拟主机中每个队列的深度和消费者数目.</p><p>list_exchanges [-p _vhost_] [<em>exchangeinfoitem</em> …]</p><p>返回交换器细节.如果没有指定”-p”选项，将返回 <strong>&#x2F;</strong> 虚拟主机的细节.  “-p” 选项可用来覆盖默认虚拟主机.</p><p><strong>exchangeinfoitem</strong> 参数用来表示哪些交换器信息要包含在结果中. 结果集中列的顺序将与参数顺序保持一致. <strong>exchangeinfoitem</strong> 可接受下面的列表中任何值：</p><p>name</p><p>交换器名称.</p><p>type</p><p>交换器类型(如[<strong>direct</strong>, <strong>topic</strong>, <strong>headers</strong>, <strong>fanout</strong>]).</p><p>durable</p><p>当服务器重启时，交换器是否能复活.</p><p>auto_delete</p><p>当不再使用时，交换器是否需要自动删除.</p><p>internal</p><p>交换器是否是内部的，即不能由client直接发布.</p><p>arguments</p><p>交换器参数</p><p>policy</p><p>应用到交换器上的策略名称.</p><p>如果没有指定<strong>exchangeinfoitem</strong>s，那么将会显示交换器类型和类型</p><p>例如:</p><p>rabbitmqctl list_exchanges -p &#x2F;myvhost name type</p><p>此命令会显示**&#x2F;myvhost**中每个交换器的名称和类型.</p><p>list_bindings [-p _vhost_] [<em>bindinginfoitem</em> …]</p><p>返回绑定细节.默认情况下返回的是 <strong>&#x2F;</strong> 虚拟主机上的绑定详情.可使用”-p” 标记来覆盖默认虚拟主机.</p><p><strong>bindinginfoitem</strong> 参数用来表示结果中包含哪些绑定信息. 结果集中列的顺序将匹配参数的顺序.<strong>bindinginfoitem</strong>可接受下面列表的任意值:</p><p>source_name</p><p>绑定中消息来源的名称. C中非ASCII转义字符.</p><p>source_kind</p><p>绑定中消息来源的类别.当前总是exchange. C中非ASCII转义字符.</p><p>destination_name</p><p>绑定中消息目的地名称.C中非ASCII转义字符.</p><p>destination_kind</p><p>绑定中消息目的地的种类. C中非ASCII转义字符.</p><p>routing_key</p><p>绑定的路由键,C中非ASCII转义字符.</p><p>arguments</p><p>绑定参数.</p><p>如果没有指定<strong>bindinginfoitem</strong>s，将会显示所有上述条目．</p><p>例如:</p><p>rabbitmqctl list_bindings -p &#x2F;myvhost exchange_name queue_name</p><p>此命令来显示**&#x2F;myvhost**虚拟主机上绑定的交换器名称和队列名称.</p><p>list_connections [<em>connectioninfoitem</em> …]</p><p>返回TCP&#x2F;IP连接统计.</p><p><strong>connectioninfoitem</strong> 参数用来表示在结果中包含哪些连接信息. 结果集中列的顺序将匹配参数的顺序.               <strong>connectioninfoitem</strong>可接受下面列表的任意值:</p><p>pid</p><p>与连接相关的Erlang进程ID.</p><p>name</p><p>连接的可读名称.</p><p>port</p><p>服务器端口.</p><p>host</p><p>返回反向DNS获取的服务器主机名称，或 IP地址(反向DNS解析失败) 或者未启用．</p><p>peer_port</p><p>Peer 端口.</p><p>peer_host</p><p>　　　返回反向DNS获取的Peer主机名称，或 IP地址(反向DNS解析失败) 或者未启用．</p><p>ssl</p><p>用Boolean来表示连接是否是SSL的.</p><p>ssl_protocol</p><p>SSL 协议(如. tlsv1)</p><p>ssl_key_exchange</p><p>SSL key exchange 算法 (如 rsa)</p><p>ssl_cipher</p><p>SSL cipher 算法 (如aes_256_cbc)</p><p>ssl_hash</p><p>SSL hash 函数 (如 sha)</p><p>peer_cert_subject</p><p>peer的 SSL 安全证书的主体, RFC4514形式．</p><p>peer_cert_issuer</p><p>peer的 SSL安全证书的发行者, RFC4514 形式.</p><p>peer_cert_validity</p><p>peer的SSL安全证书的有效期.</p><p>state</p><p>连接状态(可为[<strong>starting</strong>, <strong>tuning</strong>, <strong>opening</strong>, <strong>running</strong>, <strong>flow</strong>, <strong>blocking</strong>, <strong>blocked</strong>, <strong>closing</strong>, <strong>closed</strong>]其中一个).</p><p>channels</p><p>使用连接的channel数。</p><p>protocol</p><p>使用的AMQP协议版本(当前是**{0,9,1}** 或**{0,8,0}**). 注意，如果client请求的是AMQP 0-9 连接, 我们会视为AMQP 0-9-1.</p><p>auth_mechanism</p><p>使用的SASL认证机制,如<strong>PLAIN</strong>.</p><p>user</p><p>与连接相关的用户名</p><p>vhost</p><p>虚拟主机名称，Ｃ中非ASCII转义字符.</p><p>timeout</p><p>连接超时／协商的心跳间隔,秒为单位.</p><p>frame_max</p><p>最大 frame 大小(字节).</p><p>channel_max</p><p>        此连接上channel的最大数目.</p><p>client_properties</p><p>连接建立期间由client发送的信息属性.</p><p>recv_oct</p><p>Octets已收到.</p><p>recv_cnt</p><p>Packets 已收到.</p><p>send_oct</p><p>Octets 发送.</p><p>send_cnt</p><p>Packets 发送.</p><p>send_pend</p><p>发送队列大小.</p><p>connected_at</p><p>连接建立的日期和时间,当作timestamp.</p><p>如果没有<strong>connectioninfoitem</strong>s， 那么会显示user, peer host, peer port,流量控制和内存块状态的时间</p><p>例如:</p><p>rabbitmqctl list_connections send_pend port</p><p>此命令会显示发送队列的大小以及第个连接的服务器端口．</p><p>list_channels [<em>channelinfoitem</em> …]</p><p>返回所有当前channel上的信息,逻辑容器执行大部分 AMQP命令.这将包含最初AMQP连接的部分，以及不同插件和其它扩展创建的channels.</p><p><strong>channelinfoitem</strong> 参数用来表示在结果集中包含哪些channel信息．结果集中列的顺序将匹配参数的顺序. <strong>channelinfoitem</strong> 可接受下面列表中的任何一个参数：</p><p>pid</p><p>与连接相关的Erlang进程ID.</p><p>connection</p><p>channel所属的连接Erlang进程ID.</p><p>name</p><p>channel的可读名称.</p><p>number</p><p>channel的数目，在一个连接中，它有唯一的标识符．</p><p>user</p><p>与channel相关的用户名称.</p><p>vhost</p><p>channel操作的虚拟主机.</p><p>transactional</p><p>True：如果channel处于事务模式,其它情况为false.</p><p>confirm</p><p>True：如果channel是确认模式，其它情况为false.</p><p>consumer_count</p><p>在channel中接收消息的逻辑AMQP消费者数目．</p><p>messages_unacknowledged</p><p>在channel中消息已投递但还未应答的消息数目．</p><p>messages_uncommitted</p><p>在channel中已收到消息但还没有提交事务的消息个数．</p><p>acks_uncommitted</p><p>确认收到一个还未提交的事务数。</p><p>messages_unconfirmed</p><p>尚未确认已发布消息的数目。在通道不在确认模式下时，这将是0。</p><p>prefetch_count</p><p>新消费者QoS预提取限制, 0表示无上限.</p><p>global_prefetch_count</p><p>整个channel　QoS预提取限制, 0表示无上限.</p><p>如果没有指定<strong>channelinfoitem</strong>s，那么将显示pid, user, consumer_count,messages_unacknowledged．</p><p>例如:</p><p>rabbitmqctl list_channels connection messages_unacknowledged</p><p>此命令会显示每个channel中连接进程和未应答消息的数目.</p><p>list_consumers [-p _vhost_]</p><p>列举消费者, 即订阅队列的消息流. 每行将打印出由制表符分隔的已订阅队列的名称，创建并管理订阅的channel进程的标识,channel中订阅的consumer tag唯一标识符, boolean值表示投递到此消费者的消息是否需要应答,整数值表示表示预提取限制(为０表示无限制), 以及关于此消费者的任何其它参数．</p><p>status</p><p>显示 broker 状态信息，如当前Erlang节点上运行的应用程序, RabbitMQ 和 Erlang 的版本信息, OS 名称, 内存和文件描述符统计信息. (查看<strong>cluster_status</strong> 命令来找出那些节点是集群化的以及正在运行的.)</p><p>例如:</p><p>rabbitmqctl status</p><p>此命令显示了RabbitMQ broker的相关信息.</p><p>environment</p><p>显示每个运行程序环境中每个变量的名称和值.</p><p>report</p><p>为所有服务器状态生成一个服务器状态报告，输出应该重定向到一个文件.</p><p>例如:</p><p>rabbitmqctl report &gt; server_report.txt</p><p>此命令创建了一个服务器报告，可将它附着在支持请求的电子邮件中．</p><p>eval {<em>expr</em>}</p><p>执行任意Erlang表达式.</p><p>例如:</p><p>rabbitmqctl eval ‘node().’</p><p>此命令用于返回rabbitmqctl连接的节点名称</p><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>close_connection {<em>connectionpid</em>} {<em>explanation</em>}</p><p>connectionpid</p><p>要关闭的与连接相关的Erlang进程ID.</p><p>explanation</p><p>解释字符串.</p><p>指示broker关闭与Erlang进程id相关的连接(可通过<a href="http://www.rabbitmq.com/man/rabbitmqctl.1.man.html#list_connections"><strong>list_connections</strong></a> 命令查看), 通过为连接客户端传递解释字符串(作为AMQP连接关闭协议的一部分).</p><p>例如:</p><p>rabbitmqctl close_connection “<a href="mailto:&#114;&#x61;&#98;&#x62;&#x69;&#x74;&#x40;&#x74;&#97;&#110;&#116;&#111;&#x2e;&#52;&#x32;&#x36;&#x32;&#46;&#48;">&#114;&#x61;&#98;&#x62;&#x69;&#x74;&#x40;&#x74;&#97;&#110;&#116;&#111;&#x2e;&#52;&#x32;&#x36;&#x32;&#46;&#48;</a>“ “go away”</p><p>此命令指示RabbitMQ broker关闭与Erlang 进程id<a href="mailto:&#114;&#x61;&#98;&#x62;&#x69;&#x74;&#64;&#x74;&#97;&#110;&#116;&#x6f;&#x2e;&#52;&#x32;&#54;&#50;&#x2e;&#x30;">&#114;&#x61;&#98;&#x62;&#x69;&#x74;&#64;&#x74;&#97;&#110;&#116;&#x6f;&#x2e;&#52;&#x32;&#54;&#50;&#x2e;&#x30;</a>相关联的连接, 同时向客户端传递go away字符串.</p><p>trace_on [-p _vhost_]</p><p>vhost</p><p>要开启追踪的虚拟主机的名称.</p><p>开启追踪.注意，追踪状态不是持久化的; 如果服务器重启，追踪状态将会丢失.</p><p>trace_off [-p _vhost_]</p><p>vhost</p><p>要停止追踪的虚拟主机名称.</p><p>停止追踪.</p><p>set_vm_memory_high_watermark {<em>fraction</em>}</p><p>fraction</p><p>当一个浮点数大于或等于0时，会触发流量控制新内存阈值部分。</p><p>set_vm_memory_high_watermark absolute {<em>memory_limit</em>}</p><p>memory_limit</p><p>流程控制触发的新内存限制, 以字节来表示大于或等于０的整数或以字符串和内存单位来表示(如 512M或1G). 可用的单位是: k, kiB: kibibytes (2^10 bytes) M, MiB: mebibytes (2^20) G, GiB: gibibytes (2^30) kB: kilobytes (10^3) MB: megabytes (10^6) GB: gigabytes (10^9)</p><p>set_disk_free_limit {<em>disk_limit</em>}</p><p>disk_limit</p><p>以整数或字符串单位的可用磁盘下限限制(查看vm_memory_high_watermark), 如 512M or 1G. 一旦可用磁盘空间达到这个限制，就会设置磁盘报警.</p><p>set_disk_free_limit mem_relative {<em>fraction</em>}</p><p>fraction</p><p>相对于整个可用内存的限制，其值为非负浮点数. 当值小于１.０时是很危险的，应该谨慎使用．</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq数据备份与还原</title>
    <link href="/article/1530782b.html"/>
    <url>/article/1530782b.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p><strong>正文</strong></p><h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><p>现在有服务器A和服务器B ，由于业务需要，要求把服务器A上mq的数据迁移到服务器B上，rabbitmq的数据包括元数据（RabbitMQ用户、vhost、队列、交换和绑定）和消息数据，而消息数据存储在单独的消息存储库中。</p><p>A:192.168.2.58</p><p>B:192.168.1.60</p><h2 id="二、元数据备份和还原"><a href="#二、元数据备份和还原" class="headerlink" title="二、元数据备份和还原"></a>二、元数据备份和还原</h2><h3 id="1、操作"><a href="#1、操作" class="headerlink" title="1、操作"></a>1、操作</h3><p>在服务B上搭建rabbitmq服务，注意，主机名最好和A上的MQ保持一致。避免后面的数据存储节点名不一致，导致启动失败</p><p>安装过程详见：</p><h3 id="2、导出数据"><a href="#2、导出数据" class="headerlink" title="2、导出数据"></a>2、导出数据</h3><p>用管理员账号登录到A服务器上的管理后台</p><p><a href="http://192.168.2.58:15672，按如下所示把备份的数据下载到本地">http://192.168.2.58:15672，按如下所示把备份的数据下载到本地</a></p><p><img src="https://img2018.cnblogs.com/blog/1291340/201906/1291340-20190618150136499-1626013564.png"></p><h3 id="3、导入数据"><a href="#3、导入数据" class="headerlink" title="3、导入数据"></a>3、导入数据</h3><p>登录到B服务器上的MQ管理后台</p><p><a href="http://192.168.1.60:15672,进入如下图所示的位置，导入数据，大概10秒钟左右。">http://192.168.1.60:15672,进入如下图所示的位置，导入数据，大概10秒钟左右。</a></p><p><img src="https://img2018.cnblogs.com/blog/1291340/201906/1291340-20190618150535198-1111324964.png"></p><h3 id="4、验证数据"><a href="#4、验证数据" class="headerlink" title="4、验证数据"></a>4、验证数据</h3><p>刷新页面，查看用户、队列、vhost 等信息是否存在</p><p><img src="https://img2018.cnblogs.com/blog/1291340/201906/1291340-20190618150932480-1733657491.png"></p><h2 id="三、消息数据备份和还原"><a href="#三、消息数据备份和还原" class="headerlink" title="三、消息数据备份和还原"></a>三、消息数据备份和还原</h2><h3 id="1、确定数据目录"><a href="#1、确定数据目录" class="headerlink" title="1、确定数据目录"></a>1、确定数据目录</h3><p>登录到A服务器，执行如下命令，确定消息数据存储目：</p><p>[root@rabbitmq-ipr-service-test opt]# rabbitmqctl eval ‘rabbit_mnesia:dir().’<br>“&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;mnesia&#x2F;rabbit@rabbitmq-ipr-service-test”</p><h3 id="2、为避免数据的一致性，需先停掉服务"><a href="#2、为避免数据的一致性，需先停掉服务" class="headerlink" title="2、为避免数据的一致性，需先停掉服务"></a>2、为避免数据的一致性，需先停掉服务</h3><p>service rabbitmq-server stop</p><h3 id="3、备份数据目录"><a href="#3、备份数据目录" class="headerlink" title="3、备份数据目录"></a>3、备份数据目录</h3><p>tar  -zcvf <a href="mailto:&#114;&#97;&#98;&#98;&#x69;&#x74;&#x40;&#x72;&#97;&#x62;&#98;&#105;&#x74;&#109;&#x71;&#x2d;&#x69;&#x70;&#x72;&#45;&#115;&#101;&#114;&#118;&#x69;&#99;&#101;&#45;&#116;&#x65;&#x73;&#116;&#x2e;&#x74;&#97;&#114;&#x2e;&#103;&#122;">&#114;&#97;&#98;&#98;&#x69;&#x74;&#x40;&#x72;&#97;&#x62;&#98;&#105;&#x74;&#109;&#x71;&#x2d;&#x69;&#x70;&#x72;&#45;&#115;&#101;&#114;&#118;&#x69;&#99;&#101;&#45;&#116;&#x65;&#x73;&#116;&#x2e;&#x74;&#97;&#114;&#x2e;&#103;&#122;</a>  rabbit@rabbitmq-ipr-service-test</p><h3 id="4、还原数据"><a href="#4、还原数据" class="headerlink" title="4、还原数据"></a>4、还原数据</h3><p>登录到B服务器上，<strong>先备份原来的数据目录，</strong>上传到备份数据到对应目录，并解压</p><p>tar  -zxvf  <a href="mailto:&#x72;&#97;&#98;&#x62;&#x69;&#x74;&#64;&#x72;&#97;&#x62;&#98;&#105;&#116;&#109;&#x71;&#x2d;&#105;&#112;&#x72;&#x2d;&#115;&#x65;&#x72;&#x76;&#x69;&#x63;&#x65;&#45;&#116;&#x65;&#115;&#116;&#x2e;&#116;&#97;&#114;&#46;&#x67;&#122;">&#x72;&#97;&#98;&#x62;&#x69;&#x74;&#64;&#x72;&#97;&#x62;&#98;&#105;&#116;&#109;&#x71;&#x2d;&#105;&#112;&#x72;&#x2d;&#115;&#x65;&#x72;&#x76;&#x69;&#x63;&#x65;&#45;&#116;&#x65;&#115;&#116;&#x2e;&#116;&#97;&#114;&#46;&#x67;&#122;</a> </p><h3 id="5、修改数据目录权限"><a href="#5、修改数据目录权限" class="headerlink" title="5、修改数据目录权限"></a>5、修改数据目录权限</h3><p>chown  -R rabbitmq:rabbitmq  rabbit@rabbitmq-ipr-service-test</p><h3 id="6、启动B服务器上rabbitmq服务"><a href="#6、启动B服务器上rabbitmq服务" class="headerlink" title="6、启动B服务器上rabbitmq服务"></a>6、启动B服务器上rabbitmq服务</h3><p>service rabbitmq-server satrt</p><h3 id="7、验证消息数据是否还原成功"><a href="#7、验证消息数据是否还原成功" class="headerlink" title="7、验证消息数据是否还原成功"></a>7、验证消息数据是否还原成功</h3><p><img src="https://img2018.cnblogs.com/blog/1291340/201906/1291340-20190618154433737-1219710096.png"></p><h2 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h2><p>内部节点数据库在某些记录中存储节点的名称，如果节点名称发生更改，则必须首先使用以下rabbitmqctl命令更新数据库以便更改：</p><p>rabbitmqctl rename_cluster_node <oldnode> <newnode></p><p>当新节点以备份目录和匹配的节点名称启动时，它会根据需要执行升级步骤并继续引导。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sessionid怎么生成的</title>
    <link href="/article/f66f6b4.html"/>
    <url>/article/f66f6b4.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>是一个会话的key，浏览器第一次访问服务器会在服务器端生成一个session，有一个sessionid和它对应。tomcat生成的sessionid叫做jsessionid。</p><p>session在访问tomcat<strong>服务器</strong>HttpServletRequest的getSession(true)的时候<strong>创建</strong>，tomcat的ManagerBase类提供创建sessionid的方法：<strong>随机数+时间+jvmid</strong>；</p><p>存储在服务器的内存中，tomcat的StandardManager类将session<strong>存储在内存中</strong>，也可以持久化到file，<a href="https://cloud.tencent.com/solution/database?from_column=20065&from=20065">数据库</a>，memcache，redis等。<strong>客户端只保存sessionid到cookie</strong>中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。</p><blockquote><p>那么Session在何时创建呢？当然还是在服务器端程序运行的过程中创建的，不同语言实现的应用程序有不同创建Session的方法，而在Java中是通过调用HttpServletRequest的getSession方法（使用true作为参数）创建的。在创建了Session的同时，服务器会为该Session生成唯一的Session id，而这个Session id在随后的请求中会被用来重新获得已经创建的Session；在Session被创建之后，就可以调用Session相关的方法往Session中增加内容了，而这些内容只会保存在服务器中，发到客户端的只有Session id；当客户端再次发送请求的时候，会将这个Session id带上，服务器接受到请求之后就会依据Session id找到相应的Session，从而再次使用之。</p></blockquote><p><strong>创建</strong>：sessionid第一次产生是在直到某server端程序调用 HttpServletRequest.getSession(true)这样的语句时才被创建。</p><p><strong>删除</strong>：超时；程序调用HttpSession.invalidate()；程序关闭；</p><p><strong>session存放在哪里</strong>：服务器端的内存中。不过session可以通过特殊的方式做持久化管理（memcache，redis）。</p><p><strong>session的id是从哪里来的</strong>，sessionID是如何使用的：当客户端第一次请求session对象时候，服务器会为客户端创建一个session，并将通过特殊算法算出一个session的ID，用来标识该session对象</p><p><strong>session会因为浏览器的关闭而删除吗？</strong></p><p>不会，session只会通过上面提到的方式去关闭。</p><p><strong>下面是tomcat中session的创建：</strong></p><blockquote><p>ManagerBase是所有session管理工具类的基类，它是一个抽象类，所有具体实现session管理功能的类都要继承这个类，该类有一个受保护的方法，该方法就是创建sessionId值的方法： （<strong>tomcat的session的id值生成的机制是一个随机数加时间加上jvm的id值，jvm的id值会根据服务器的硬件信息计算得来，因此不同jvm的id值都是唯一的</strong>）， StandardManager类是tomcat容器里默认的session管理实现类， <strong>它会将session的信息存储到web容器所在服务器的内存里</strong>。 PersistentManagerBase也是继承ManagerBase类，它是所有持久化存储session信息的基类，PersistentManager继承了PersistentManagerBase，但是这个类只是多了一个静态变量和一个getName方法，目前看来意义不大，<strong>对于持久化存储session，tomcat还提供了StoreBase的抽象类，它是所有持久化存储session的基类，另外tomcat还给出了</strong><a href="https://cloud.tencent.com/product/cfs?from_column=20065&from=20065"><strong>文件存储</strong></a><strong>FileStore和</strong><a href="https://cloud.tencent.com/product/cdcs?from_column=20065&from=20065"><strong>数据存储</strong></a><strong>JDBCStore两个实现。</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-2 Java NIO</title>
    <link href="/article/f137bddf.html"/>
    <url>/article/f137bddf.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1. Channel"></a>1. Channel</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">NIO中一个连接就是用一个Channel来表示。从更广泛的层面来说，一个通道可以表示一个底层的文件描述符。例如硬件设备、文件、网络连接等。<span class="hljs-keyword">Java </span>NIO中的通道更加细化，例如。对应不同的网络传输协议类型，再<span class="hljs-keyword">JAVA中都用不同的JAVA </span>NIO Channel实现。<br></code></pre></td></tr></table></figure><h3 id="Channel类型："><a href="#Channel类型：" class="headerlink" title="Channel类型："></a>Channel类型：</h3><pre><code class="hljs">1.FileChannel : 文件通道，用于文件的数据读写，不适合I/O多路复用。2.SocketChannel：套接字通道，用于Socket套接字TCP连接的数据读写3.ServerSocketChannel：服务器嵌套字通道，允许我们监听TCP的连接请求，为每个监听到的请求，创建一个SocketChannel4.DatagramChannel：数据报通道，用于UDP协议的数据读写。</code></pre><h2 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">NIO的<span class="hljs-built_in">Buffer</span>(缓冲区) 本质上是一个内存块，既可以写入数据也可以从中读取数据。Buffer内部有一个byte<span class="hljs-selector-attr">[]</span>数组内存块，作为内存缓冲区。为了记录读写的状态和位置Buffer类提供了一些重要的属性。<span class="hljs-built_in">capacity</span>(容量)、<span class="hljs-attribute">position</span>（读写位置）、limit（读写的限制）、<span class="hljs-selector-tag">mark</span>（标记）<br>Buffer类是一个非线程安全的类<br></code></pre></td></tr></table></figure><h4 id="Buffer类型："><a href="#Buffer类型：" class="headerlink" title="Buffer类型："></a>Buffer类型：</h4><pre><code class="hljs">ByteBufferCharBufferDoubleBufferFloatBufferIntBufferLongBufferShortBufferMappedByteBuffer</code></pre><h2 id="3-Selector"><a href="#3-Selector" class="headerlink" title="3. Selector"></a>3. Selector</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">选择器的使命是完成IO的多路复用。一个通道代表一条连接通路，通过选择器可以同时监控多个通道的IO状况。<br></code></pre></td></tr></table></figure><h4 id="Selector监控的IO事件类型："><a href="#Selector监控的IO事件类型：" class="headerlink" title="Selector监控的IO事件类型："></a>Selector监控的IO事件类型：</h4><pre><code class="hljs">可读：SelectionKey.OP_read可写：SelectionKey.OP_write连接：SelectionKey.OP_connect接收：SelectionKey.OP_ACCEPT</code></pre>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis集群如何保证高可用</title>
    <link href="/article/da141ff0.html"/>
    <url>/article/da141ff0.html</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" />## 1、前言<ol><li><p>Redis是单线程的，可以通过在单机开多个Redis实例，避免CPU多核的浪费，但是单机仍然存在瓶颈。</p></li><li><!-- toc --></li></ol><p> <strong>Redis集群是Redis的分布式解决方案，当一个服务挂了可以快速的切换到另外一个服务</strong>，当遇到单机内存、并发等瓶颈时，常使用此方案。</p><ol start="3"><li><p>集群的部署方式也就是Redis cluster，<strong>采用主从同步读写分离</strong>，类似Mysql的主从同步，<strong>Redis cluster支撑 N 个 Redis master node，每个master node都可以挂载多个 slave node</strong>，这样整个 Redis就可以横向扩容了。</p></li><li><p>如果要支撑更大数据量的缓存，那就横向扩容更多的 master 节点，每个 master 节点就能存放更多的数据了。</p></li><li><p><strong>集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护；从节点只进行主节点数据和状态信息的复制。</strong></p></li></ol><h2 id="2、Redis主从同步"><a href="#2、Redis主从同步" class="headerlink" title="2、Redis主从同步"></a>2、Redis主从同步</h2><h3 id="2-1-、主从同步架构"><a href="#2-1-、主从同步架构" class="headerlink" title="2.1 、主从同步架构"></a>2.1 、主从同步架构</h3><ul><li><p>单机的 redis，能够承载的 QPS 大概就在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发的。</p></li><li><p>因此架构做成**主从(master-slave)架构，一主多从，主负责写，并且将数据复制到其它的 slave 节点，从节点负责读。**</p></li><li><p>所有的读请求全部走从节点。这样可以轻松实现水平扩容，支撑读高并发。</p></li></ul><p><img src="https://s2.51cto.com/images/blog/202109/01/e13b2cffbcae0c2b16b5249192241035.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="【面试系列】Redis集群如何保证高可用？_客户端">Redis主从同步架构</p><h3 id="2-2、数据同步"><a href="#2-2、数据同步" class="headerlink" title="2.2、数据同步"></a>2.2、数据同步</h3><ol><li>启动一台slave 的时候，他会发送<code>psync</code>命令给master ，如果是这个slave第一次连接到master，会触发全量复制</li><li>master就会启动一个线程，生成<strong>RDB</strong>快照，并且把<strong>新的写请求都缓存在内存中</strong>，</li><li><strong>RDB</strong>文件生成后，master会将这个<strong>RDB</strong>发送给slave，</li><li>slave拿到之后写进本地的磁盘，然后加载进内存，然后<strong>master会把内存里面缓存的那些新命名都发给slave</strong>。</li></ol><h3 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h3><ul><li><strong>如果全量复制过程中，master-slave 网络连接断掉，那么 slave 重新连接 master 时，会触发增量复制。</strong></li><li><strong>master 直接从自己的 backlog 中获取部分丢失的数据，发送给 slave node</strong>，默认 backlog就是 1MB。</li><li>master 就是根据 slave 发送的 <code>psync</code> 中的<code>offset</code> 来从 backlog 中获取数据的。</li></ul><p><img src="https://s2.51cto.com/images/blog/202109/01/bc5eec74b9c8d1e2fd09c0b9a6420884.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="【面试系列】Redis集群如何保证高可用？_redis_02">RDB持久化</p><blockquote><p>“</p><p>注意：slave node 如果跟 master node 有网络故障，断开了连接，<strong>会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。</strong></p></blockquote><h2 id="3、哨兵集群"><a href="#3、哨兵集群" class="headerlink" title="3、哨兵集群"></a>3、哨兵集群</h2><h3 id="3-1、功能"><a href="#3-1、功能" class="headerlink" title="3.1、功能"></a>3.1、功能</h3><p>sentinel，中文名是哨兵。哨兵是 redis 集群机构中非常重要的一个组件，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作，主要有以下功能：</p><ul><li><strong>集群监控：负责监控 redis master 和 slave 进程是否正常工作。</strong></li><li><strong>消息通知：如果某个 redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</strong></li><li><strong>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</strong></li><li><strong>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址</strong></li></ul><h3 id="3-2、经典哨兵集群"><a href="#3-2、经典哨兵集群" class="headerlink" title="3.2、经典哨兵集群"></a>3.2、经典哨兵集群</h3><ol><li><strong>哨兵必须用三个实例去保证自己的健壮性，哨兵+主从的部署架构并不能保证数据不丢失，但是可以保证集群的高可用。</strong></li><li>经典的哨兵集群如图所示，M1所在的机器挂了，哨兵还有两个，可以选举一个出来执行故障转移。</li><li>但是如果只有两个实例存在，master宕机了， s1和s2两个哨兵只要有一个认为你宕机了就切换了，并且会选举出一个哨兵去执行故障</li><li>如果M1宕机了，S1没挂那其实是OK的，但是整个机器都挂了呢？哨兵就只剩下实例S2，没有哨兵去允许故障转移了，虽然另外一个机器上还有R1，但是故障转移是不会执行的，无法保证集群高可用。</li></ol><p><img src="https://s2.51cto.com/images/blog/202109/01/931168ce2d79466c95ccbe995eb6c702.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="【面试系列】Redis集群如何保证高可用？_客户端_03">经典哨兵集群</p><h3 id="3-3、slave-gt-master-选举算法"><a href="#3-3、slave-gt-master-选举算法" class="headerlink" title="3.3、slave-&gt;master 选举算法"></a>3.3、slave-&gt;master 选举算法</h3><ol><li>如果一个master被认为宕机了，而且大多数的哨兵都允许主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个 slave来，会考虑 slave 的一些信息：</li></ol><ul><li><strong>跟 master 断开连接的时长</strong></li><li><strong>slave 优先级</strong></li><li><strong>复制 offset</strong></li><li><strong>run id</strong></li></ul><ol start="2"><li><p>如果一个 <strong>slave 跟 master 断开连接的时间已经超过了</strong> <code>down-after-milliseconds</code> 的 10 倍，外加 master 宕机的时长，那么 slave 就被认为不适合选举为 master。</p></li><li><p>接下来会对 slave 进行排序：</p></li></ol><ul><li>按照 slave 优先级进行排序，slave priority 越低，优先级就越高。</li><li>如果 slave priority 相同，那么看 replica offset，哪个 slave 复制了越多的数据，offset 越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个 run id 比较小的那个 slave。</li></ul><h2 id="4、集群分区"><a href="#4、集群分区" class="headerlink" title="4、集群分区"></a>4、集群分区</h2><h3 id="4-1、数据分区"><a href="#4-1、数据分区" class="headerlink" title="4.1、数据分区"></a>4.1、数据分区</h3><p>分布式数据库把整个数据按分区规则映射到多个节点，即把<strong>数据划分到多个节点上，每个节点负责整体数据的一个子集</strong>。比如我们库有600条用户数据，有3个redis节点，将600条分成3份，分别存入到3个redis节点。</p><p><img src="https://s2.51cto.com/images/blog/202109/01/8b3522c958ab999603f5f5a3c6e70fdc.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="【面试系列】Redis集群如何保证高可用？_ip协议_04"></p><h3 id="4-2、分区规则："><a href="#4-2、分区规则：" class="headerlink" title="4.2、分区规则："></a>4.2、分区规则：</h3><ol><li><p>常见的分区规则哈希分区和顺序分区，<strong>redis</strong> <strong>集群使用了哈希分区</strong>，顺序分区暂用不到，不做具体说明；</p></li><li><p><strong>哈希分区的基本思路是：对数据的特征值（如key）进行哈希，然后根据哈希值决定数据落在哪个节点。常见的哈希分区包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。</strong></p></li><li><p>衡量数据分区方法好坏的标准有很多，其中比较重要的两个因素是**(1)数据分布是否均匀(2)增加或删减节点对数据分布的影响。**</p></li><li><p><strong>由于哈希的随机性，哈希分区基本可以保证数据分布均匀；因此在比较哈希分区方案时，重点要看增减节点对数据分布的影响。</strong></p></li></ol><h4 id="1）、节点取余"><a href="#1）、节点取余" class="headerlink" title="1）、节点取余"></a>1）、节点取余</h4><ul><li>哈希取余分区思路非常简单：<strong>计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</strong></li></ul><h4 id="2）、一致性哈希"><a href="#2）、一致性哈希" class="headerlink" title="2）、一致性哈希"></a>2）、一致性哈希</h4><ul><li>一致性哈希算法将整个哈希值空间<strong>组织成一个虚拟的圆环，如下图所示，范围为0-2^32-1</strong>；</li><li>对于每个数据，<strong>根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。</strong></li></ul><p><img src="https://s2.51cto.com/images/blog/202109/01/b411bf2a9fa7e9e12fbf63ed42cfb8bf.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="【面试系列】Redis集群如何保证高可用？_一致性哈希_05">一致性哈希</p><ul><li><p>与哈希取余分区相比，<strong>一致性哈希分区将增减节点的影响限制在相邻节点</strong>。以上图为例，如果在node1和node2之间增加node5，则只有node2中的一部分数据会迁移到node5；如果去掉node2，则原node2中的数据只会迁移到node4中，只有node4会受影响。</p></li><li><p>一致性哈希分区的主要问题在于，**当节点数量较少时，增加或删减节点，对单个节点的影响可能很大，造成数据的严重不平衡。**还是以上图为例，如果去掉node2，node4中的数据由总数据的1&#x2F;4左右变为1&#x2F;2左右，与其他节点相比负载过高。</p></li></ul><h4 id="3）、虚拟槽分区"><a href="#3）、虚拟槽分区" class="headerlink" title="3）、虚拟槽分区"></a>3）、虚拟槽分区</h4><ul><li><p>该方案在一致性哈希分区的基础上，引入了虚拟节点的概念。Redis集群使用的便是该方案，其中的虚拟节点称为槽（slot）。</p></li><li><p>槽是介于数据和实际节点之间的虚拟概念；每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。<strong>引入槽以后，数据的映射关系由数据hash-&gt;实际节点，变成了数据hash-&gt;槽-&gt;实际节点。</strong></p></li><li><p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位。槽解耦了数据和实际节点之间的关系，增加或删除节点对系统的影响很小</strong>。</p></li><li><p>仍以上图为例，系统中有4个实际节点，假设为其分配16个槽(0-15)；槽0-3位于node1，4-7位于node2，以此类推。如果此时删除node2，只需要将槽4-7重新分配即可，例如槽4-5分配给node1，槽6分配给node3，槽7分配给node4；可以看出删除node2后，数据在其他节点的分布仍然较为均衡。</p></li><li><p>槽的数量一般远小于2^32，远大于实际节点的数量；在<strong>Redis集群中，槽的数量为16384，</strong></p></li><li><p><strong>所有的键根据哈希函数<code>Hash()=(CRC16[key]&amp;16383)</code>映射到0－16383槽内，共16384个槽位，每个节点维护部分槽及槽所映射的键值数据</strong></p></li></ul><p>下面这张图很好的总结了Redis集群将数据映射到实际节点的过程：</p><p><img src="https://s2.51cto.com/images/blog/202109/01/e78ab259c387751e6b82b6eeae6fec12.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=/format,webp/resize,m_fixed,w_1184" alt="【面试系列】Redis集群如何保证高可用？_客户端_06">数据映射到实际节点</p><p>（1）Redis对数据的特征值（一般是key）计算哈希值，使用<strong>CRC16</strong>算法</p><p>（2）<strong>根据哈希值，计算数据属于哪个槽。</strong></p><p><strong>（3）根据槽与节点的映射关系，计算数据属于哪个节点。</strong></p><blockquote><p>“</p><p><strong>redis用虚拟槽分区好处：解耦数据与节点关系，节点自身维护槽映射关系，分布式存储</strong></p></blockquote><h2 id="5、节点通信机制"><a href="#5、节点通信机制" class="headerlink" title="5、节点通信机制"></a>5、节点通信机制</h2><p>集群要作为一个整体工作，离不开节点之间的通信</p><h3 id="5-1、两个端口"><a href="#5-1、两个端口" class="headerlink" title="5.1、两个端口"></a>5.1、两个端口</h3><p>在哨兵系统中，节点分为数据节点和哨兵节点：前者存储数据，后者实现额外的控制功能。在集群中，没有数据节点与非数据节点之分：所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点，都提供了两个TCP端口：</p><ul><li><p>普通端口：即我们在前面指定的端口(7000等)。普通端口主要用于为客户端提供服务（与单机节点类似）；但在节点间数据迁移时也会使用。</p></li><li><p>集群端口：端口号是普通端口+10000（10000是固定值，无法改变），如7000节点的集群端口为17000。集群端口只用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信；不要使用客户端连接集群接口。为了保证集群可以正常工作，在配置防火墙时，要同时开启普通端口和集群端口。</p></li></ul><h3 id="5-2、Gossip协议"><a href="#5-2、Gossip协议" class="headerlink" title="5.2、Gossip协议"></a>5.2、Gossip协议</h3><p>节点间通信，按照通信协议可以分为几种类型：单对单、广播、Gossip协议等。重点是广播和Gossip的对比。</p><ul><li><p>广播是指向集群内所有节点发送消息；优点是集群的收敛速度快(集群收敛是指集群内所有节点获得的集群信息是一致的)，缺点是每条消息都要发送给所有节点，CPU、带宽等消耗较大。</p></li><li><p>**Gossip协议的特点是：在节点数量有限的网络中，每个节点都“随机”的与部分节点通信（并不是真正的随机，而是根据特定的规则选择通信的节点），经过一番杂乱无章的通信，每个节点的状态很快会达到一致。**Gossip协议的优点有负载(比广播)低、去中心化、容错性高(因为通信有冗余)等；缺点主要是集群的收敛速度慢。</p></li></ul><h3 id="5-3、消息类型"><a href="#5-3、消息类型" class="headerlink" title="5.3、消息类型"></a>5.3、消息类型</h3><ol><li><p>集群中的节点采用固定频率（每秒10次）的定时任务进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使集群收敛。</p></li><li><p>节点间发送的消息主要分为5种：meet消息、ping消息、pong消息、fail消息、publish消息。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的。</p></li></ol><ul><li><p><strong>MEET消息</strong>：在节点握手阶段，当节点收到客户端的CLUSTER MEET命令时，会向新加入的节点发送MEET消息，请求新节点加入到当前集群；新节点收到MEET消息后会回复一个PONG消息。</p></li><li><p><strong>PING消息</strong>：集群里每个节点每秒钟会选择部分节点发送PING消息，接收者收到消息后会回复一个PONG消息。PING消息的内容是自身节点和部分其他节点的状态信息；作用是彼此交换信息，以及检测节点是否在线。** **PING消息使用Gossip协议发送，**接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找5个节点，在其中选择最久没有通信的1个节点(2)扫描节点列表，选择最近一次收到PONG消息时间大于cluster_node_timeout&#x2F;2的所有节点，防止这些节点长时间未更新。</p></li><li><p><strong>PONG消息</strong>：PONG消息封装了自身状态数据。可以分为两种：第一种是在接到MEET&#x2F;PING消息后回复的PONG消息；第二种是指节点向集群广播PONG消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播PONG消息。</p></li><li><p><strong>FAIL消息</strong>：当一个主节点判断另一个主节点进入FAIL状态时，会向集群广播这一FAIL消息；接收节点会将这一FAIL消息保存起来，便于后续的判断。</p></li><li><p><strong>PUBLISH消息</strong>：节点收到PUBLISH命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该PUBLISH命令。</p></li></ul><h2 id="6、其他"><a href="#6、其他" class="headerlink" title="6、其他"></a>6、其他</h2><h3 id="6-1、架构细节"><a href="#6-1、架构细节" class="headerlink" title="6.1、架构细节"></a>6.1、架构细节</h3><ol><li>所有的 redis 节点彼此互联 (PING-PONG 机制)，<strong>内部使用二进制协议优化传输速度和带宽。</strong></li><li>节点的 fail 是通过集群中超过半数的节点检测失效或者某个节点主从全挂时才生效。</li><li><strong>客户端与 redis 节点直连</strong>，不需要中间 proxy 层。<strong>客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</strong></li><li>redis-cluster 把<strong>所有的物理节点映射到 [0-16383]slot</strong> 上。</li></ol><h3 id="6-2、集群容错"><a href="#6-2、集群容错" class="headerlink" title="6.2、集群容错"></a>6.2、集群容错</h3><ol><li>为了当部分节点失效时，cluster 仍能保持可用，<strong>Redis 集群采用每个节点拥有 1（主服务自身）到 N 个副本的主从模型。类似于 master&#x2F;slave。</strong></li><li>但是 <strong>redis cluster 却不是强一致性的，因为 cluster 内部 master 和 slave 之间是通过异步复制做数据同步的</strong>，复制过程中可能 master 挂了，这就导致部分数据没有完全同步至 slave 上，不过这种可能性还是很小的。</li><li>集群选举过程是集群中所有 master 参与，<strong>如果半数以上 master 节点与当前 master 节点通信超时，则集群认为当前 master 节点挂掉</strong></li><li>当集群不可用时, 所有对集群的操作做都将失败。以下是会导致集群不可用的其中两种情况：<ol><li><strong>集群任意 master 挂掉，并且当前 master 没有 slave，集群不可用</strong></li><li><strong>集群超过半数以上 master 挂掉，无论是否有 slave，集群不可用</strong></li></ol></li></ol><h3 id="6-3、集群扩展"><a href="#6-3、集群扩展" class="headerlink" title="6.3、集群扩展"></a>6.3、集群扩展</h3><blockquote><p>“</p><p><strong>以往的一致性哈希方案，如果我们移除或者新增节点时，虽然说不会导致全局 key 的 rehash，但是也会影响到部分 key 的失效</strong>。Redis Cluster 在可用性和可扩展性上比较重视，<strong>如果集群新增一个节点，在给该节点分配槽时，这些槽所属的源节点和该节点会进行一次 key 的迁移，并且迁移过程中不阻塞集群服务。如果移除一个节点，同理，我们需要将待移除的节点的 key 迁移到另一个节点上。</strong></p></blockquote><p>那集群是如何做到 key 迁移不阻塞集群服务的呢？</p><p>key 迁移过程中，涉及到 CLUSTER SETSLOT slot8 <strong>MIGRATING node 命令</strong>和 CLUSTER SETSLOT slot8 <strong>IMPORTING node 命令</strong>，前者用于将给定节点 node 中的槽 slot8 迁移出节点，而后者用于将给定槽 slot8 导入到节点 node ：</p><ol><li><p><strong>如果一个槽被设置为 MIGRATING 状态时，原本持有该槽的节点会继续接受关于这个槽的命令请求，但只有当键存在于该节点时，节点才会处理这个请求。如果命令所使用的键不存在于该节点，那么节点将向客户端返回一个 ASK 转向（redirection）错误，告知客户端，要将命令请求发送到槽的迁移目标节点</strong>。</p></li><li><p><strong>如果一个槽被设置为 IMPORTING 状态时，节点仅在接收到 ASKING 命令之后，才会接受关于这个槽的命令请求。如果客户端向节点发送该槽的数据请求，命令为非 ASKING 时，那么节点会使用 MOVED 转向错误将命令请求转向至真正负责处理这个槽的节点。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CommandLineRunner和ApplicationRunner</title>
    <link href="/article/5d49a0d1.html"/>
    <url>/article/5d49a0d1.html</url>
    
    <content type="html"><![CDATA[<h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><!-- toc --><p>在Spring Boot应用程序中，CommandLineRunner和ApplicationRunner是两个重要的接口，它们允许我们在应用程序启动后执行一些初始化任务。本文将介绍CommandLineRunner和ApplicationRunner的区别，并提供代码示例和使用场景，让我们更好地理解和使用这两个接口。  </p><h3 id="CommandLineRunner和ApplicationRunner的用法"><a href="#CommandLineRunner和ApplicationRunner的用法" class="headerlink" title="CommandLineRunner和ApplicationRunner的用法"></a>CommandLineRunner和ApplicationRunner的用法</h3><ol><li>CommandLineRunner接口:<ul><li>方法签名: <code>void run(String... args)</code></li><li>参数类型: 字符串数组，表示应用程序启动时传递的命令行参数</li><li>执行时机: 在Spring上下文准备好之后，但在调用ApplicationRunner之前执行。</li></ul></li><li>ApplicationRunner接口:<ul><li>方法签名: <code>void run(ApplicationArguments args)</code></li><li>参数类型: ApplicationArguments对象，提供对应用程序启动参数的更高级别访问</li><li>执行时机: 在CommandLineRunner之后执行。</li></ul></li></ol><p>这两个接口的目的是允许开发人员在应用程序启动完成后执行一些自定义的任务，例如加载<a href="https://so.csdn.net/so/search?q=%E5%88%9D%E5%A7%8B%E5%8C%96&spm=1001.2101.3001.7020">初始化</a>数据、执行数据迁移、启动后台任务等，它们都实现了<code>org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean</code>注解，这意味着只有在没有其他类型的<a href="https://so.csdn.net/so/search?q=Bean%E5%AE%9A%E4%B9%89&spm=1001.2101.3001.7020">Bean定义</a>的情况下，才会自动配置它们。</p><p><strong>我们可以通过以下两种方式使用<code>CommandLineRunner</code>和<code>ApplicationRunner</code>：</strong></p><ol><li><p>通过实现接口并将其作为Spring Bean注册：</p><ul><li>创建一个类并实现<code>CommandLineRunner</code>或<code>ApplicationRunner</code>接口</li><li>实现接口的<code>run</code>方法，在该方法中编写您的自定义逻辑</li><li>将实现类标记为<code>@Component</code>或使用其他适当的注解进行注解，以便使其成为Spring Bean</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> org.springframework.boot.ApplicationArguments;<br><span class="hljs-keyword">import</span> org.springframework.boot.ApplicationRunner;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 在这里编写您的自定义逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过使用<code>SpringApplication</code>的<code>run</code>方法参数进行注册：</p><ul><li>在<code>SpringApplication.run</code>方法中，将实现了<code>CommandLineRunner</code>或<code>ApplicationRunner</code>接口的实例作为参数传递给<code>run</code>方法。</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.CommandLineRunner;<br><span class="hljs-keyword">import</span> org.springframework.boot.ApplicationRunner;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YourApplication</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span>, <span class="hljs-title">ApplicationRunner</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(YourApplication.class, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 在这里编写您的自定义逻辑</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 在这里编写您的自定义逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>无论我们选择哪种方式，一旦应用程序启动完成，<code>run</code>方法将被调用，并且我们可以在其中编写我们的自定义逻辑。可以根据我们的需求选择使用<code>CommandLineRunner</code>或<code>ApplicationRunner</code>接口。</p><h3 id="CommandLineRunner和ApplicationRunner的区别"><a href="#CommandLineRunner和ApplicationRunner的区别" class="headerlink" title="CommandLineRunner和ApplicationRunner的区别"></a>CommandLineRunner和ApplicationRunner的区别</h3><h4 id="参数不同"><a href="#参数不同" class="headerlink" title="参数不同"></a>参数不同</h4><p>从上面的代码示例中，我们可以看到CommandLineRunner和ApplicationRunner的一个主要的不同就是它们的run方法的参数类型不同。CommandLineRunner的run方法接收一个String数组，它是直接从命令行传入的参数，比如<code>java -jar myapp.jar arg1 arg2</code>，那么arg1和arg2就会被传入到run方法中。而ApplicationRunner的run方法接收一个ApplicationArguments对象，它不仅包含了命令行传入的参数，还包含了其他的应用程序参数，比如<code>--spring.profiles.active=dev</code>，这些参数可以通过ApplicationArguments的方法来获取，比如<code>args.getOptionNames()</code>，<code>args.getNonOptionArgs()</code>等。</p><h4 id="执行顺序不同"><a href="#执行顺序不同" class="headerlink" title="执行顺序不同"></a>执行顺序不同</h4><p>另外一个不同就是CommandLineRunner和ApplicationRunner的执行顺序不同。如果我们在同一个应用程序中同时定义了多个CommandLineRunner和ApplicationRunner，那么它们的执行顺序是怎样的呢？答案是，首先执行所有的CommandLineRunner，然后执行所有的ApplicationRunner，而且它们都是按照优先级的顺序执行的，优先级越高，越先执行。我们可以通过@Order注解来指定它们的优先级，值越小，优先级越高，比如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 优先级为1的CommandLineRunner</span><br><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@Order</span>(<span class="hljs-number">1</span>)<br>public class FirstCommandLineRunner implements CommandLineRunner &#123;<br>    <span class="hljs-comment">// 省略run方法</span><br>&#125;<br><br><span class="hljs-comment">// 优先级为2的CommandLineRunner</span><br><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@Order</span>(<span class="hljs-number">2</span>)<br>public class SecondCommandLineRunner implements CommandLineRunner &#123;<br>    <span class="hljs-comment">// 省略run方法</span><br>&#125;<br><br><span class="hljs-comment">// 优先级为1的ApplicationRunner</span><br><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@Order</span>(<span class="hljs-number">1</span>)<br>public class FirstApplicationRunner implements ApplicationRunner &#123;<br>    <span class="hljs-comment">// 省略run方法</span><br>&#125;<br><br><span class="hljs-comment">// 优先级为2的ApplicationRunner</span><br><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@Order</span>(<span class="hljs-number">2</span>)<br>public class SecondApplicationRunner implements ApplicationRunner &#123;<br>    <span class="hljs-comment">// 省略run方法</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了两个CommandLineRunner和两个ApplicationRunner，并且分别指定了它们的优先级。那么它们的执行顺序是：</p><ul><li>FirstCommandLineRunner</li><li>SecondCommandLineRunner</li><li>FirstApplicationRunner</li><li>SecondApplicationRunner</li></ul><h3 id="CommandLineRunner和ApplicationRunner的使用场景"><a href="#CommandLineRunner和ApplicationRunner的使用场景" class="headerlink" title="CommandLineRunner和ApplicationRunner的使用场景"></a>CommandLineRunner和ApplicationRunner的使用场景</h3><p>那么，我们什么时候应该使用CommandLineRunner和ApplicationRunner呢？一般来说，它们都可以用来在Spring容器启动后执行一些初始化的任务，比如加载配置，初始化数据，运行测试等。但是，根据它们的不同，我们可以根据具体的需求来选择合适的接口。下面是一些可能的使用场景：</p><ul><li>如果我们需要在Spring容器启动后执行一些简单的任务，而且不需要获取任何的应用程序参数，那么我们可以使用CommandLineRunner，它的用法比较简单，只需要实现一个接口，然后写好run方法即可。</li><li>如果我们需要在Spring容器启动后执行一些复杂的任务，而且需要获取一些应用程序参数，比如Spring的配置参数，那么我们可以使用ApplicationRunner，它的用法比较灵活，可以通过ApplicationArguments对象来获取各种参数，然后根据参数来执行不同的逻辑。</li><li>如果我们需要在Spring容器启动后执行一些和命令行相关的任务，比如解析命令行参数，执行一些命令，那么我们可以使用CommandLineRunner，它可以直接获取命令行传入的参数，然后根据参数来执行不同的命令。</li><li>如果我们需要在Spring容器启动后执行一些和应用程序相关的任务，比如启动其他的组件，调用其他的服务，那么我们可以使用ApplicationRunner，它可以获取应用程序的上下文，然后根据上下文来执行不同的任务。</li></ul><h4 id="实操—获取SpringBoot启动后容器里面所有的Bean"><a href="#实操—获取SpringBoot启动后容器里面所有的Bean" class="headerlink" title="实操—获取SpringBoot启动后容器里面所有的Bean"></a>实操—获取SpringBoot启动后容器里面所有的Bean</h4><p>Spring Boot 在内部加载了大量的 bean，以最小的配置运行我们的应用程序。 我们想要找出所有这些 <strong>SpringBoot 加载的 Bean</strong> 及其类类型信息，就可以使用上面说的方法</p><p><strong>使用<code>ApplicationContext</code>获取所有已加载的 bean</strong></p><p>1）使用<code>ApplicationContext.getBeanDefinitionNames()</code>查找所有已加载 bean 的名称</p><p>2）使用<code>ApplicationContext.getBean(beanName)</code>获取包含其运行时类型信息的 bean。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@SpringBootApplication</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootWebApplication</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> <span class="hljs-title">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">SpringApplicationBuilder</span> configure(<span class="hljs-type">SpringApplicationBuilder</span> application) &#123;<br><span class="hljs-keyword">return</span> application.sources(<span class="hljs-type">SpringBootWebApplication</span>.<span class="hljs-keyword">class</span>);<br>&#125;<br><br>public static void main(<span class="hljs-type">String</span>[] args) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br><span class="hljs-type">SpringApplication</span>.run(<span class="hljs-type">SpringBootWebApplication</span>.<span class="hljs-keyword">class</span>, args);<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ApplicationContext</span> appContext;<br><br><span class="hljs-meta">@Override</span><br>    public void run(<span class="hljs-type">String</span>... args) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> <br>&#123;<br>        <span class="hljs-type">String</span>[] beans = appContext.getBeanDefinitionNames();<br>        <span class="hljs-type">Arrays</span>.sort(beans);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> bean : beans) <br>        &#123;<br>            <span class="hljs-type">System</span>.out.println(bean + <span class="hljs-string">&quot; of Type :: &quot;</span> + appContext.getBean(bean).getClass());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出信息如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">....<br>basicErrorController of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.BasicErrorController</span><br>beanNameHandlerMapping of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.handler</span><span class="hljs-selector-class">.BeanNameUrlHandlerMapping</span><br>beanNameViewResolver of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.BeanNameViewResolver</span><br>characterEncodingFilter of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.filter</span><span class="hljs-selector-class">.OrderedCharacterEncodingFilter</span><br>conventionErrorViewResolver of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.DefaultErrorViewResolver</span><br>defaultServletHandlerMapping of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.annotation</span>.WebMvcConfigurationSupport<span class="hljs-variable">$EmptyHandlerMapping</span><br>defaultViewResolver of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.view</span><span class="hljs-selector-class">.InternalResourceViewResolver</span><br>dispatcherServlet of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.DispatcherServlet</span><br>dispatcherServletRegistration of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.ServletRegistrationBean</span><br>duplicateServerPropertiesDetector of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span>.ServerPropertiesAutoConfiguration<span class="hljs-variable">$DuplicateServerPropertiesDetector</span><br>embeddedServletContainerCustomizerBeanPostProcessor of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.embedded</span><span class="hljs-selector-class">.EmbeddedServletContainerCustomizerBeanPostProcessor</span><br>error of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span>.ErrorMvcAutoConfiguration<span class="hljs-variable">$SpelView</span><br>errorAttributes of Type :: class org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.DefaultErrorAttributes</span><br><br>...<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty-1 IO网络模型</title>
    <link href="/article/cc431be0.html"/>
    <url>/article/cc431be0.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Linux</span> 内核会将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个<span class="hljs-variable">file</span> <span class="hljs-variable">descriptor</span> （<span class="hljs-variable">fd</span><span class="hljs-operator">,</span> 文件描述符）。二队一个<span class="hljs-variable">socket</span>的读写也会有相应的描述符，成为<span class="hljs-variable">socketfd</span>，描述符就是一个数字，它指向内核中的一个机构提（文件路径，数据区等一些属性）。<br>根据<span class="hljs-variable">UNIX</span>网络编程对<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型的分类，<span class="hljs-variable">UNIX</span>提供了<span class="hljs-number">5</span>种<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型<br></code></pre></td></tr></table></figure><h2 id="主体内容"><a href="#主体内容" class="headerlink" title="主体内容"></a>主体内容</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span>同步阻塞<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型（<span class="hljs-variable">BIO</span>）：<br>传统的<span class="hljs-variable">BIO</span>模型， 通常由一个独立的<span class="hljs-variable">Acceptor</span>线程负责监听客户端的链接，塔基收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完之后，通过输出流返回应答给客户端，线程销毁。<br>该模型最大的问题就是当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数成<span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">1</span>的正比关系。可能会导致线程耗尽。<br><br><span class="hljs-number">2.</span>同步非阻塞<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型<span class="hljs-punctuation">(</span><span class="hljs-variable">NIO</span><span class="hljs-punctuation">)</span><br>此处的<span class="hljs-variable">NIO</span>并非<span class="hljs-variable">java</span>的<span class="hljs-variable">nio</span>框架，<span class="hljs-variable">socket</span>链接默认是阻塞模式，可以通过设置将<span class="hljs-variable">socket</span>变成为非阻塞的模式。<br>这种模式下，当用户线程发起<span class="hljs-variable">IO</span>操作时，内核缓冲区没有数据的情况下，系统调用会立即返回<span class="hljs-variable">EWOULDBLOCK</span>失败，用户线程需要一直轮训发起<span class="hljs-variable">IO</span>操作，当有数据时，用户线程进行<span class="hljs-variable">IO</span>调用此时会进入阻塞状态。<br><br><span class="hljs-number">3.</span><span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>多路复用<br>通过<span class="hljs-variable">select</span><span class="hljs-operator">/</span><span class="hljs-variable">epoll</span>系统调用，一个进程<span class="hljs-punctuation">(</span><span class="hljs-variable">Selector</span><span class="hljs-punctuation">)</span>可以监视多个文件描述符（<span class="hljs-variable">channel</span>）（<span class="hljs-variable">fd</span>）<span class="hljs-operator">,</span>一旦某个描述符就绪，内核能够将就绪的状态返回给应用系统（<span class="hljs-variable">SelectionKey</span>）。用户线程根据就绪状态发起<span class="hljs-variable">IO</span>调用。<br><span class="hljs-number">4.</span>信号驱动<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型（未理解）<br>信号驱动的 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 模型是一种异步 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 模型，它允许应用程序在等待 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作完成时继续执行其他任务。在这种模型中，当应用程序发起一个 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作时，它并不会一直等待操作完成。相反，它会注册一个信号处理程序，该处理程序在 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作完成时被调用。这意味着，当 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作完成时，内核会发送一个信号告知应用程序，应用程序可以在信号处理程序中获取 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作的结果。信号驱动的 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 模型适用于大量的 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作，因为它可以同时处理多个 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 操作，而不必等待一个操作完成后才开始下一个操作。<br><span class="hljs-number">5.</span>异步<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模型（未理解）<br>应用程序通过异步调用发起 <span class="hljs-variable">IO</span> 操作，并在操作完成时通过回调函数得到结果。无需额外创建信号处理函数或线程<span class="hljs-operator">/</span>进程，因此可以大大降低系统的资源消耗和复杂度，并且在高并发场景下可以更加有效地利用系统资源保证程序的性能和可伸缩性。<br><br>从<span class="hljs-variable">IO</span>执行的过程中看，信号驱动的 <span class="hljs-variable">IO</span> 模型只有前半部分实现了异步，而异步<span class="hljs-variable">IO</span>模型则在整个<span class="hljs-variable">IO</span>操作过程中都是异步的。所以，相对于信号驱动的 <span class="hljs-variable">IO</span> 模型，异步 <span class="hljs-variable">IO</span> 模型在高并发场景下优势较大，可以更好地适应高并发、高负载的应用程序需求。<br></code></pre></td></tr></table></figure><h2 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-number">1.</span> <span class="hljs-variable">JAVA</span> <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>演进历史<br>（<span class="hljs-number">1</span>）<span class="hljs-variable">jdk1</span><span class="hljs-number">.4</span>之前 采用<span class="hljs-variable">BIO</span>模式<br>（<span class="hljs-number">2</span>）<span class="hljs-variable">jdk1</span><span class="hljs-number">.4</span>     发布基于<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>多路复用的<span class="hljs-variable">NIO</span><br>（<span class="hljs-number">3</span>）<span class="hljs-variable">jdk1</span><span class="hljs-number">.7</span>     发布<span class="hljs-variable">NIO2</span><span class="hljs-number">.0</span>，支持<span class="hljs-variable">AIO</span>（异步<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>操作）<span class="hljs-operator">,</span><span class="hljs-variable">Netty</span>并没有使用<span class="hljs-variable">AIO</span><br><span class="hljs-number">2.</span> 用户线程和系统内核的交互<br>用户程序不直接和内核交互，而是通过缓冲区来进行交互，流程如下：<br>（<span class="hljs-number">1</span>）等待数据从网络上到达网卡，当所等待的数据到达时，他被复制到内核中的某个缓冲区。这个工作由操作系统自动完成。<br>（<span class="hljs-number">2</span>）就是把内核缓冲区的数据复制到进程缓冲区。<span class="hljs-variable">JAVA</span> 举例<br><br>客户端请求：<span class="hljs-variable">Linux</span>通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。<br>获取请求数据：<span class="hljs-variable">JAVA</span>服务器通过<span class="hljs-variable">read</span>系统调用，从<span class="hljs-variable">linux</span>内核缓冲区读取数据，再送入<span class="hljs-variable">JAVA</span>进程缓冲区。<br>服务端业务处理：<span class="hljs-variable">JAVA</span>服务器在自己的用户空间中处理客户端的请求。<br>服务端返回数据：<span class="hljs-variable">JAVA</span>服务器完成处理后，构建好的响应数据，讲这些数据通过<span class="hljs-variable">write</span>操作用户缓冲区写入内核缓冲区，<br>发送给客户端：<span class="hljs-variable">LInux</span>内核通过网络<span class="hljs-variable">IO</span><span class="hljs-operator">,</span>将内核缓冲区中的数据写入网卡，网卡通过底层网络协议，将数据发送给客户端。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多线程</title>
    <link href="/article/5729df21.html"/>
    <url>/article/5729df21.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">在Java中，线程的状态包括以下几种，以及对应的状态码：<br><br>1. <span class="hljs-strong">**NEW（新建）**</span>：线程被创建，但尚未启动。状态码：1<br><span class="hljs-code">    </span><br>2. <span class="hljs-strong">**RUNNABLE（可运行）**</span>：线程正在Java虚拟机中执行，可能正在等待CPU时间片。状态码：2<br><span class="hljs-code">    </span><br>3. <span class="hljs-strong">**BLOCKED（阻塞）**</span>：线程正在等待获取一个锁，以便进入同步块/方法。状态码：3<br><span class="hljs-code">    </span><br>4. <span class="hljs-strong">**WAITING（等待）**</span>：线程等待另一个线程执行特定操作（无超时）。状态码：4<br><span class="hljs-code">    </span><br>5. <span class="hljs-strong">**TIMED_WAITING（超时等待）**</span>：线程等待另一个线程执行特定操作（有超时）。状态码：5<br><span class="hljs-code">    </span><br>6. <span class="hljs-strong">**TERMINATED（终止）**</span>：线程已完成执行或因异常退出。状态码：6<br><span class="hljs-code">    </span><br><br>这些状态码是在Java线程状态枚举类<span class="hljs-code">`java.lang.Thread.State`</span>中定义的。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>消息队列-名词解释</title>
    <link href="/article/c78c5ef.html"/>
    <url>/article/c78c5ef.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>点对点：1:1<br>发布订阅：1:n</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">AMQ:</span><br><span class="hljs-number">1</span>:<span class="hljs-number">1</span> 发布消息到queue<br><span class="hljs-number">1</span>:n 发布消息到topic<br><span class="hljs-symbol">RABBIT:</span>（<span class="hljs-keyword">PUSH</span>）<br>（队列中的消息，消费者轮训消费，不是都消费）<br><span class="hljs-number">1</span>:<span class="hljs-number">1</span> exchange只绑定一个队列，队列中只有一个消费者<br><span class="hljs-number">1</span>:n exchange绑定多个队列<br>KAFKA（PULL）<br><span class="hljs-number">1</span>:<span class="hljs-number">1</span> 发布到topic，消费者组只有一个消费者拉取<br><span class="hljs-number">1</span>:n 发布到topic,多个消费者组中的都可以消费相同消息，每一个分区只能被一个消费组中的一个消费者所消费。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列、</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>守护线程</title>
    <link href="/article/6137330d.html"/>
    <url>/article/6137330d.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>在这篇简短的文章中，我们将讲解下 Java 中的守护线程，看看它们可以做什么。我们还将解释守护线程和用户线程之间的区别。</p><h2 id="守护线程和用户线程的区别"><a href="#守护线程和用户线程的区别" class="headerlink" title="守护线程和用户线程的区别"></a>守护线程和用户线程的区别</h2><p><a href="https://www.twle.cn/l/yufei/java/java-basic-index.html">Java</a> 提供了两种类型的线程：<strong>守护线程</strong> 和 <strong>用户线程</strong></p><ul><li><strong>用户线程</strong> 是高优先级线程。JVM 会在终止之前等待任何用户线程完成其任务。</li><li><strong>用户线程</strong> 是低优先级线程。其唯一作用是为用户线程提供服务。</li></ul><p>由于守护线程的作用是为用户线程提供服务，并且仅在用户线程运行时才需要，因此一旦所有用户线程完成执行，JVM 就会终止。也就是说 <strong>守护线程不会阻止 JVM 退出</strong>。</p><p>这也是为什么通常存在于守护线程中的无限循环不会导致问题，因为任何代码（包括 finally 块 ）都不会在所有用户线程完成执行后执行。</p><p>这也是为什么我们并不推荐 <strong>在守护线程中执行 I&#x2F;O 任务</strong> 。因为可能导致无法正确关闭资源。</p><p>但是，守护线程并不是 100% 不能阻止 JVM 退出的。守护线程中设计不良的代码可能会阻止 JVM 退出。例如，在正在运行的守护线程上调用<code>Thread.join()</code> 可以阻止应用程序的关闭。</p><h2 id="守护线程能用来做什么？"><a href="#守护线程能用来做什么？" class="headerlink" title="守护线程能用来做什么？"></a>守护线程能用来做什么？</h2><p>常见的做法，就是将守护线程用于后台支持任务，比如垃圾回收、释放未使用对象的内存、从缓存中删除不需要的条目。</p><p>咦，按照这个解释，那么大多数 JVM 线程都是守护线程。</p><h2 id="如何创建守护线程-？"><a href="#如何创建守护线程-？" class="headerlink" title="如何创建守护线程 ？"></a>如何创建守护线程 ？</h2><p>守护线程也是一个线程，因此它的创建和启动其实和普通线程没什么区别？</p><p>要将普通线程设置为守护线程，方法很简单，只需要调用 <code>Thread.setDaemon()</code> 方法即可。</p><p>例如下面这段代码，假设我们继承 <code>Thread</code> 类创建了一个新类 <code>NewThread</code> 。那么我们就可以创建这个类的实例并设置为守护线程</p><p>NewThread daemonThread = new NewThread();<br>daemonThread.setDaemon(true);<br>daemonThread.start();</p><p>在 Java 语言中，线程的状态是自动继承的。任何线程都会继承创建它的线程的守护程序状态。怎么理解呢？</p><ol><li>如果一个线程是普通线程（ 用户线程） ，那么它创建的子线程默认也是普通线程（ 用户线程 ）。</li><li>如果一个线程是守护线程，那么它创建的子线程默认也是守护线程。</li></ol><p>因此，我们可以推演出： 由于主线程是用户线程，因此在 <code>main()</code> 方法内创建的任何线程默认为用户线程。</p><p>需要注意的是调用 <code>setDaemon()</code> 方法的时机，该方法只能在创建 Thread 对象并且在启动线程前调用。在线程运行时尝试调用 <code>setDaemon()</code> 将抛出 IllegalThreadStateException 异常。</p><p>@Test(expected = IllegalThreadStateException.class)<br>public void whenSetDaemonWhileRunning_thenIllegalThreadStateException() {<br>    NewThread daemonThread = new NewThread();<br>    daemonThread.start();<br>    daemonThread.setDaemon(true);<br>}</p><h2 id="如何检查一个线程是守护线程还是用户线程？"><a href="#如何检查一个线程是守护线程还是用户线程？" class="headerlink" title="如何检查一个线程是守护线程还是用户线程？"></a>如何检查一个线程是守护线程还是用户线程？</h2><p>检查一个线程是否是守护线程，可以简单地调用方法 <code>isDaemon()</code> ，如下代码所示</p><p>@Test<br>public void whenCallIsDaemon_thenCorrect() {<br>    NewThread daemonThread = new NewThread();<br>    NewThread userThread = new NewThread();<br>    daemonThread.setDaemon(true);<br>    daemonThread.start();<br>    userThread.start();</p><pre><code class="hljs">assertTrue(daemonThread.isDaemon());assertFalse(userThread.isDaemon());</code></pre><p>}</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>守护线程的概念是不是很简单？</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>彻底搞懂Log4J、Log4J2、LogBack，SLF4J</title>
    <link href="/article/bb8feff0.html"/>
    <url>/article/bb8feff0.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><blockquote><p>最近系统被扫出来还在使用老旧的log4j，需要升级到最新的log4j。但是在升级的发现，Java相关的日志处理库有log4j, log4j2,slf4j和logback，初一看确实有点头大，那么区别是啥呢？之前也大概知道一些，查找了大量相关资料，这里好好总结一下，相信你读完就会熟练掌握</p></blockquote><h3 id="Log4J、Log4J2和LogBack的历史故事"><a href="#Log4J、Log4J2和LogBack的历史故事" class="headerlink" title="Log4J、Log4J2和LogBack的历史故事"></a>Log4J、Log4J2和LogBack的历史故事</h3><p>使用过Log4J和LogBack的同学肯定能发现，这两个框架的设计理念极为相似，使用方法也如出一辙。其实这个两个框架的作者都是一个人，Ceki Gülcü，俄罗斯程序员。</p><p>Log4J 最初是基于Java开发的日志框架，发展一段时间后，作者Ceki Gülcü将Log4j捐献给了Apache软件基金会，使之成为了Apache日志服务的一个子项目。 又由于Log4J出色的表现，后续又被孵化出了支持C, C++, C#, Perl, Python, Ruby等语言的子框架。</p><p>然而，伟大的程序员好像都比较有个性。Ceki Gülcü由于不满Apache对Log4J的管理，决定不再参加Log4J的开发维护。“出走”后的Ceki Gülcü另起炉灶，开发出了LogBack这个框架（SLF4J是和LogBack一起开发出来的）。LogBack改进了很多Log4J的缺点，在性能上有了很大的提升，同时使用方式几乎和Log4J一样，许多用户开始慢慢开始使用LogBack。</p><p>由于受到LogBack的冲击，Log4J开始式微。终于，2015年9月，Apache软件基金业宣布，Log4j不在维护，建议所有相关项目升级到Log4j2。Log4J2是Apache开发的一个新的日志框架，改进了很多Log4J的缺点，同时也借鉴了LogBack，号称在性能上也是完胜LogBack。性能这块后面我会仔细分析。</p><h3 id="那slf4j和这些有什么关系？"><a href="#那slf4j和这些有什么关系？" class="headerlink" title="那slf4j和这些有什么关系？"></a>那slf4j和这些有什么关系？</h3><p>SLF4J的全称是Simple Logging Facade for Java，slf4j是<strong>门面模式</strong>的典型应用，因此在讲slf4j前，需要简单介绍下门面模式。</p><h3 id="看看门面模式再说"><a href="#看看门面模式再说" class="headerlink" title="看看门面模式再说"></a>看看门面模式再说</h3><p>下面是门面模式的一个典型调用过程，<strong>其核心为外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用。</strong> 下图中客户端不需要直接调用几个子系统，只需要与统一的门面进行通信即可。</p><p><img src="https://pic4.zhimg.com/80/v2-d85852b61e7828e9a42ce18516ea263f_720w.webp"></p><p>mJDusF</p><p>门面模式的核心为Facade即门面对象，核心为几个点：</p><ul><li>知道所有子角色的功能和责任。</li><li>将客户端发来的请求委派到子系统中，没有实际业务逻辑。</li><li>不参与子系统内业务逻辑的实现。</li></ul><h3 id="为什么要使用slf4j-？"><a href="#为什么要使用slf4j-？" class="headerlink" title="为什么要使用slf4j ？"></a>为什么要使用slf4j ？</h3><p>回答这个问题之前，我们先看看如果需要用上面几个日志框架来打印日志，一般怎么做，具体代码如下：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 使用log4j，需要log4j.jar<br>import org.apache.log4j.Logger<span class="hljs-comment">;</span><br>Logger logger_log4j <span class="hljs-operator">=</span> Logger.getLogger(Test.class)<span class="hljs-comment">;</span><br>logger_log4j.info(<span class="hljs-string">&quot;Hello World!&quot;</span>)<span class="hljs-comment">;</span><br><br>// 使用log4j2，需要log4j-api.jar、log4j-core.jar<br>import org.apache.logging.log4j.LogManager<span class="hljs-comment">;</span><br>import org.apache.logging.log4j.Logger<span class="hljs-comment">;</span><br>Logger logger_log4j2 <span class="hljs-operator">=</span> LogManager.getLogger(Test.class)<span class="hljs-comment">;</span><br>logger_log4j2.info(<span class="hljs-string">&quot;Hello World!&quot;</span>)<span class="hljs-comment">;</span><br><br>// logback，需要logback-classic.jar、logback-core.jar<br>import ch.qos.logback.classic.Logger<span class="hljs-comment">;</span><br>import ch.qos.logback.classic.LoggerContext<span class="hljs-comment">;</span><br>Logger logger_logback <span class="hljs-operator">=</span> new LoggerContext().getLogger(Test.class)<span class="hljs-comment">;</span><br>logger_logback.info(<span class="hljs-string">&quot;Hello World!&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>从上面不难看出，使用不同的日志框架，就要引入不同的jar包，使用不同的代码获取Logger。如果项目升级需要更换不同的框架，那么就需要修改所有的地方来获取新的Logger，这将会产生巨大的工作量。</p><p>基于此，<strong>我们需要一种接口来将不同的日志框架的使用统一起来，这也是为什么要使用slf4j的原因。</strong></p><p><strong>SLF4J，即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。按照官方的说法，SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</strong></p><blockquote><p>注意：类似的日志门面还有Jakarta Common logging（JCL），主要区别在于，SLF4J是一个比较新的日志框架，它更加灵活，性能更好，支持更多的日志实现，而且JCL基于classLoader在运行时动态加载日志框架，可能会产生很多意想不到的安全问题，关于这个问题可以参考讨论<a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/3222895/what-is-the-issue-with-the-runtime-discovery-algorithm-of-apache-commons-logging">https://stackoverflow.com/questions/3222895/what-is-the-issue-with-the-runtime-discovery-algorithm-of-apache-commons-logging</a></p></blockquote><p>通过上面的介绍，我们可以知道JCL和SLF4J都是日志门面（Facade），而Log4J、Log4J2和LogBack都是子系统角色（SunSystem），也就是具体的日志实现框架。他们的关系如下，JUL是JDK本身提供的一种实现。</p><p>![](data:image&#x2F;svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='1276' height='486'></svg>)</p><p>aMexDT</p><p>使用日志门面引入日志组件的最大优势是：<strong>将系统和具体的日志实现框架解耦合。</strong></p><h3 id="slf4j怎么和日志框架结合使用？"><a href="#slf4j怎么和日志框架结合使用？" class="headerlink" title="slf4j怎么和日志框架结合使用？"></a>slf4j怎么和日志框架结合使用？</h3><p>使用slf4j后，当我们在打印日志时，就可以使用下面的方式：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import org.slf4j.Logger<span class="hljs-comment">;</span><br>import org.slf4j.LoggerFactory<span class="hljs-comment">;</span><br>Logger logger <span class="hljs-operator">=</span> LoggerFactory.getLogger(Test.class)<span class="hljs-comment">;</span><br>logger.info(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br></code></pre></td></tr></table></figure><p>这又引入了另外一个问题，slf4j如何决定使用哪个框架日志呢，并且引入哪些jar包呢？官方为我们准备了下面的组合依赖结构图：</p><p>![](data:image&#x2F;svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='3106' height='1730'></svg>)</p><p>hBZadd</p><p>总结来说，就是一下几种：</p><ul><li><strong>slf4j + logback</strong>： slf4j-api.jar + logback-classic.jar + logback-core.jar</li><li><strong>slf4j + log4j</strong>： slf4j-api.jar + slf4j-log412.jar + log4j.jar</li><li><strong>slf4j + jul</strong>： slf4j-api.jar + slf4j-jdk14.jar</li><li><strong>也可以只用slf4j无日志实现</strong>：slf4j-api.jar + slf4j-nop.jar</li></ul><p>注意到这里没有log4j2依赖jar的关系，和log4j2配合需要导入log4j2的log4j-api.jar、log4j-core.jar和桥接包log4j-slf4j-impl.jar。</p><blockquote><p>所谓的桥接包，就是实现StaticLoggerBinder类，用来连接slf4j和日志框架。因为log4j和log4j2刚开始没有StaticLoggerBinder这个类，为了不改变程序结构，只能重新写一个新的jar来实现StaticLoggerBinder。而logback出现slf4j之后，于是在logback本身的jar中实现了StaticLoggerBinder，所以就不需要桥接包。</p></blockquote><h3 id="现在为什么推荐Log4j2？"><a href="#现在为什么推荐Log4j2？" class="headerlink" title="现在为什么推荐Log4j2？"></a>现在为什么推荐Log4j2？</h3><p>Apache Log4j 2 是 Log4j(1) 的升级版，比它的祖先 Log4j 1.x和logback 有了很大的改进。除了内部设计的调整外，主要有以下几点的大升级：</p><ul><li>更简化的配置</li><li>更强大的参数格式化</li><li>最夸张的异步性能</li></ul><p>Log4j2 中，分为 API(log4j-api）和实现 (log4j-core) 两个模块。API 和 slf4j 是一个类型，属于日志抽象 &#x2F; 门面，而实现部分，才是 Log4j 2 的核心。 <em>org.apache.logging.log4j » log4j-api</em> org.apache.logging.log4j » log4j-core</p><p>log4j2 在目前 JAVA 中的日志框架里，异步日志的性能是最高的，具体可以看下面的对比图：</p><p>![](data:image&#x2F;svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='1472' height='780'></svg>)</p><p>qjzLPK</p><p>log4j2采用了字符串复用等手段来实现零GC模式运行，另外提供了MemoryMappedFileAppender实现了极高的IO性能，而且API相比slf4j，有更丰富的参数格式化功能。</p><h3 id="怎么使用Log4j2？"><a href="#怎么使用Log4j2？" class="headerlink" title="怎么使用Log4j2？"></a>怎么使用Log4j2？</h3><p>说了半天，那怎么去使用Log4j2呢，这部分我仔细介绍一下。</p><h3 id="常规使用步骤"><a href="#常规使用步骤" class="headerlink" title="常规使用步骤"></a>常规使用步骤</h3><p>下面以Maven配置为例进行介绍。</p><ol><li>首先需要加入log4j的依赖，<strong>注意2.17.1以下的版本会有远程代码执行的安全漏洞，具体参考Apache官方文档（<a href="https://link.zhihu.com/?target=https://logging.apache.org/log4j/2.x/security.html">https://logging.apache.org/log4j/2.x/security.html</a>）。推荐使用最新的版本。</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.17.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>配置好log4j2.xml配置文件，并放到项目的classpath里面，一般会放到resources目录里面。下面是一个参考的配置，当然也可以使用properties文件和yaml文件来进行配置。</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> [%t] %-5level %logger</span></span></span><span class="hljs-template-variable">&#123;36&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> - %msg%n&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.malaoshi&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><ol><li>在程序中打印log。使用下面的方式来打印log即可。</li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs smali">import org.apache.logging.log4j.<span class="hljs-class">LogManager;</span><br>import org.apache.logging.log4j.<span class="hljs-class">Logger;</span><br><span class="hljs-keyword"></span><br><span class="hljs-keyword">public</span> class HelloWorld &#123;<br><br>   <span class="hljs-keyword"> private</span><span class="hljs-keyword"> static</span><span class="hljs-keyword"> final</span> Logger logger = LogManager.getLogger(HelloWorld.class);<br><br>   <span class="hljs-keyword"> public</span><span class="hljs-keyword"> static</span> void main(String[] args) &#123;<br><br>        logger.debug(<span class="hljs-string">&quot;Hello from Log4j 2&quot;</span>);<br><br>        // in old days, we need to<span class="hljs-built_in"> check </span>the log level to increase performance<br>        /*if (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, getNumber());<br>        &#125;*/<br><br>        // with Java 8, we can do this, no need to<span class="hljs-built_in"> check </span>the log level<br>        logger.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, () -&gt; getNumber());<br><br>    &#125;<br><br>   <span class="hljs-keyword"> static</span><span class="hljs-built_in"> int </span>getNumber() &#123;<br>       <span class="hljs-built_in"> return </span>5;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">19</span>:<span class="hljs-number">12</span>:<span class="hljs-number">25.337</span> <span class="hljs-selector-attr">[main]</span> DEBUG com<span class="hljs-selector-class">.malaoshi</span><span class="hljs-selector-class">.HelloWorld</span> - Hello from Log4j <span class="hljs-number">2</span><br><span class="hljs-number">19</span>:<span class="hljs-number">12</span>:<span class="hljs-number">25.340</span> <span class="hljs-selector-attr">[main]</span> DEBUG com<span class="hljs-selector-class">.malaoshi</span><span class="hljs-selector-class">.HelloWorld</span> - <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h3><p>首先给大家看一个比较全面的配置文件，可能看起来比较头大，不急我后面会一点点仔细分析。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="language-xml"> <span class="hljs-comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;WARN&quot;</span> <span class="hljs-attr">monitorInterval</span>=<span class="hljs-string">&quot;30&quot;</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss:SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">] [%p] - %l - %m%n&quot;</span>/&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">console</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;log&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;log/test.log&quot;</span> <span class="hljs-attr">append</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> %-5level %class</span></span></span><span class="hljs-template-variable">&#123;36&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> %L %M - %msg%xEx%n&quot;</span>/&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sys:user.home&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/logs/info.log&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                      <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sys:user.home&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/logs/$$</span></span></span><span class="hljs-template-variable">&#123;date:yyyy-MM&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/info-%d</span></span></span><span class="hljs-template-variable">&#123;yyyy-MM-dd&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">-%i.log&quot;</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span>        </span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss:SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">] [%p] - %l - %m%n&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">                 <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="language-xml">                 <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sys:user.home&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/logs/warn.log&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                      <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sys:user.home&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/logs/$$</span></span></span><span class="hljs-template-variable">&#123;date:yyyy-MM&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/warn-%d</span></span></span><span class="hljs-template-variable">&#123;yyyy-MM-dd&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">-%i.log&quot;</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;warn&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss:SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">] [%p] - %l - %m%n&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">                 <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="language-xml">                 <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了20 --&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">DefaultRolloverStrategy</span> <span class="hljs-attr">max</span>=<span class="hljs-string">&quot;20&quot;</span>/&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sys:user.home&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/logs/error.log&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                      <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;sys:user.home&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/logs/$$</span></span></span><span class="hljs-template-variable">&#123;date:yyyy-MM&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/error-%d</span></span></span><span class="hljs-template-variable">&#123;yyyy-MM-dd&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">-%i.log&quot;</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">ThresholdFilter</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">onMatch</span>=<span class="hljs-string">&quot;ACCEPT&quot;</span> <span class="hljs-attr">onMismatch</span>=<span class="hljs-string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;[%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss:SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">] [%p] - %l - %m%n&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">                 <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="language-xml">                 <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;100 MB&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;all&quot;</span>&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileWarn&quot;</span>/&gt;</span></span><br><span class="language-xml">             <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;RollingFileError&quot;</span>/&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span></span><br><span class="language-xml">     <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span></span><br><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>下面为大家仔细解析这个配置文件，</p><p><strong>1. 根节点</strong></p><blockquote><p>Configuration有两个属性:status和monitorinterval,有两个子节点:Appenders和Loggers(表明可以定义多个Appender和Logger)。</p></blockquote><ul><li>status用来指定log4j本身的打印日志的级别.</li><li>monitorinterval用于指定log4j自动重新配置的监测间隔时间，单位是s,最小是5s.</li></ul><p><strong>2. Appenders节点</strong></p><blockquote><p>Appenders节点，常见的子节点有：Console、RollingFile、File。</p></blockquote><p><strong>Console节点</strong>用来定义输出到控制台的Appender。</p><ul><li>name：指定Appender的名字。</li><li>target：SYSTEM_OUT 或 SYSTEM_ERR，一般只设置默认：SYSTEM_OUT。</li><li>PatternLayout：输出格式，不设置默认为:%m%n。</li></ul><p><strong>File节点</strong>用来定义输出到指定位置的文件的Appender。</p><ul><li>name：指定Appender的名字。</li><li>fileName：指定输出日志的目的文件带全路径的文件名。</li><li>PatternLayout：输出格式，不设置默认为:%m%n。</li></ul><p><strong>RollingFile节点</strong>用来定义超过指定大小自动删除旧的创建新的的Appender。</p><ul><li><p>name：指定Appender的名字。</p></li><li><p>fileName：指定输出日志的目的文件带全路径的文件名。</p></li><li><p>PatternLayout：输出格式，不设置默认为:%m%n。</p></li><li><p>filePattern：指定新建日志文件的名称格式。</p></li><li><p>Policies是指定滚动日志的策略，就是什么时候进行新建日志文件输出日志。<br>TimeBasedTriggeringPolicy：Policies子节点，基于时间的滚动策略，interval属性用来指定多久滚动一次，默认是1 hour。modulate&#x3D;true用来调整时间：比如现在是早上3am，interval是4，那么第一次滚动是在4am，接着是8am，12am…而不是7am。 SizeBasedTriggeringPolicy：Policies子节点，基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小。  </p></li><li><p>DefaultRolloverStrategy：用来指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的(通过max属性)。</p></li></ul><p><strong>3. Loggers</strong></p><p>Loggers节点，常见子节点有：Root和Logger。</p><p><strong>Root节点</strong>用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</p><ul><li>level：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。</li><li>AppenderRef：Root的子节点，用来指定该日志输出到哪个Appender。</li></ul><p><strong>Logger节点</strong>用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。</p><ul><li>level：日志输出级别，共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。</li><li>name：用来指定该Logger所适用的类或者类所在的包全路径,继承自Root节点。</li><li>AppenderRef：Logger的子节点，用来指定该日志输出到哪个Appender，如果没有指定，就会默认继承自Root.如果指定了，那么会在指定的这个Appender和Root的Appender中都会输出，此时我们可以设置Logger的additivity&#x3D;”false”只在自定义的Appender中进行输出。</li></ul><p><strong>4. 日志Level</strong></p><p>共有8个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。</p><ul><li>All:最低等级的，用于打开所有日志记录。</li><li>Trace:是追踪，就是程序推进以下，你就可以写个trace输出，所以trace应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出。</li><li>Debug:指出细粒度信息事件对调试应用程序是非常有帮助的。</li><li>Info:消息在粗粒度级别上突出强调应用程序的运行过程。</li><li>Warn:输出警告及warn以下级别的日志。</li><li>Error:输出错误信息日志。</li><li>Fatal:输出每个严重的错误事件将会导致应用程序的退出的日志。</li><li>OFF:最高等级的，用于关闭所有日志记录。</li></ul><p>程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。</p><h3 id="参考范例"><a href="#参考范例" class="headerlink" title="参考范例"></a>参考范例</h3><p>这部分给大家提供几个常用的配置，直接放到项目里面改一下包名就可以用。</p><p><strong>1. 输出日志到Console</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> [%t] %-5level %logger</span></span></span><span class="hljs-template-variable">&#123;36&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> - %msg%n&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- avoid duplicated logs with additivity=false --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.mkyong&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>2. 输出日志到文件</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> [%t] %-5level %logger</span></span></span><span class="hljs-template-variable">&#123;36&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> - %msg%n&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">File</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LogToFile&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;logs/app.log&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d %p %c</span><span class="hljs-template-variable">&#123;1.&#125;</span><span class="language-xml"> [%t] %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.malaoshi&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToFile&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.springframework.boot&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToFile&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>3. 输出到文件并滚动生成新的日志文件</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d</span></span></span><span class="hljs-template-variable">&#123;HH:mm:ss.SSS&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> [%t] %-5level %logger</span></span></span><span class="hljs-template-variable">&#123;36&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string"> - %msg%n&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">RollingFile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LogToRollingFile&quot;</span> <span class="hljs-attr">fileName</span>=<span class="hljs-string">&quot;logs/app.log&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">                    <span class="hljs-attr">filePattern</span>=<span class="hljs-string">&quot;logs/$$</span></span></span><span class="hljs-template-variable">&#123;date:yyyy-MM&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/app-%d</span></span></span><span class="hljs-template-variable">&#123;MM-dd-yyyy&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">-%i.log.gz&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d %p %c</span><span class="hljs-template-variable">&#123;1.&#125;</span><span class="language-xml"> [%t] %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">PatternLayout</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">TimeBasedTriggeringPolicy</span> /&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">SizeBasedTriggeringPolicy</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;10 MB&quot;</span>/&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;/<span class="hljs-name">Policies</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">RollingFile</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Appenders</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-comment">&lt;!-- avoid duplicated logs with additivity=false --&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.malaoshi&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;debug&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToRollingFile&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Logger</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;LogToConsole&quot;</span>/&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">Root</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Loggers</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">Configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>以上就是所有的内容，看完下来就会搞清楚各种log框架的关系，以及如何在项目中使用这些log框架。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>log4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AMQP和JMS的区别</title>
    <link href="/article/59afdada.html"/>
    <url>/article/59afdada.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p><strong>1. 高级消息队列协议:</strong></p><p>它是一种用于应用程序之间通信的协议。它是一种轻量级协议，支持应用程序进行数据传输。该协议具有可扩展性和模块化的特点。</p><p><strong>2. Java消息服务(JMS):</strong></p><p>它是一种支持网络中计算机通信的应用程序接口(API)。它是一个功能强大的API，用于接收通信过程中生成的消息。</p><p>AMQP和JMS的区别:</p><table><thead><tr><th>比较基础</th><th>AMQP</th><th>JMS</th></tr></thead><tbody><tr><td>缩写</td><td>高级消息队列协议(Advanced Message Queuing Protocol)。</td><td>Java消息服务(<a href="https://geek-docs.com/java/java-top-tutorials/1001100_java_index.html" title="Java 教程">Java</a> Message Service)。</td></tr><tr><td>开发商</td><td>它由摩根大通开发。</td><td>它是由太阳微系统公司开发的。</td></tr><tr><td>工作方式</td><td>所有兼容AMQP的客户端都可以相互通信。</td><td>应用程序应该使用JMS API进行通信。</td></tr><tr><td>消息模型使用</td><td>它使用Direct, Fanout, Topic和header。</td><td>它使用发布&#x2F;订阅和P2P(点对点)。</td></tr><tr><td>抽象</td><td>amqp是一种协议。</td><td>JMS是一个标准API。</td></tr><tr><td>数据类型</td><td>amqp使用的数据类型只使用并支持二进制数据类型。</td><td>JMS支持五种数据类型，分别为MapMessage、ObjectMessage、Text message、StreamMessage和BytesMessage。</td></tr><tr><td>安全</td><td>SASL (Simple Authentication and Security Layer)支持安全。</td><td>没有提供安全性，它依赖于JMS提供程序。</td></tr><tr><td>数据流</td><td>由生产者发送消息，然后将消息排队。</td><td>它由生产者管理，并直接发送到主题。</td></tr><tr><td>技术灵活性</td><td>它在许多技术上都是灵活的。</td><td>它不是专门为Java开发的技术灵活性。</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>activemq</tag>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq名词解释</title>
    <link href="/article/7ee41741.html"/>
    <url>/article/7ee41741.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li>Broker:     可以理解为每个服务节点负责接受消息，传递消息</li><li>Vhost:       rabbitmq用来实现多租户的一种方式，一个broker下可以有多个vhost，每个vhost相当于一个虚拟的服务节点</li><li>Exchange:   接受生产者发送的消息，并根据Binding规则将消息路由给服务器中的队列。ExchangeType决定了Exchange路由消息的行为。<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">RabbitMQ 常用的 Exchange <span class="hljs-keyword">Type</span> <span class="hljs-type">有 </span>fanout、direct、topic、headers 这四种（AMQP规范里还提到两种 Exchange <span class="hljs-keyword">Type</span>，分别为 system 与自定义，这里不予以描述<br></code></pre></td></tr></table></figure></li><li>Queue: 负责存储消息，一个Exchange可以绑定多个Queue</li><li>RoutingKey:     生产者通过RoutingKey将Queue和Exchange绑定在一起</li><li>BingdingKey:    根据Bingdingkey和ExchangeType 组合规则匹配RoutingKey，将符合规则的消息转发到队列中。</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
      <tag>excalidraw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>replicaof  和 slaveof区别</title>
    <link href="/article/939d7320.html"/>
    <url>/article/939d7320.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><h3 id="SLAVEOF-命令"><a href="#SLAVEOF-命令" class="headerlink" title="SLAVEOF 命令"></a>SLAVEOF 命令</h3><ul><li><code>SLAVEOF</code> 是早期版本的 Redis 中使用的命令，用于设置当前数据库服务器为另一个服务器的从属服务器。</li><li>通过执行 <code>SLAVEOF host port</code> 命令，可以将当前服务器设置为指定地址和端口上服务器的从属服务器。</li><li>如果想要取消从属状态，可以使用 <code>SLAVEOF NO ONE</code> 命令。</li></ul><h3 id="REPLICAOF-命令"><a href="#REPLICAOF-命令" class="headerlink" title="REPLICAOF 命令"></a>REPLICAOF 命令</h3><ul><li><code>REPLICAOF</code> 命令在 Redis 5.0 版本中引入，作为 <code>SLAVEOF</code> 命令的一个别名，用于强调 Redis 的复制功能更倾向于数据的高可用性和分布式系统的一部分，而不仅仅是主从复制的简单关系。</li><li><code>REPLICAOF</code> 命令的用法与 <code>SLAVEOF</code> 完全相同。使用 <code>REPLICAOF host port</code> 可以设置从属关系，使用 <code>REPLICAOF NO ONE</code> 可以取消从属关系。</li><li>引入 <code>REPLICAOF</code> 的目的主要是为了更准确地描述 Redis 在复制和分布式系统中的角色，避免“主从”这种可能具有敏感含义的术语。</li></ul><h3 id="区别和选择"><a href="#区别和选择" class="headerlink" title="区别和选择"></a>区别和选择</h3><ul><li>功能上，<code>REPLICAOF</code> 和 <code>SLAVEOF</code> 之间没有差异，两者都可以用来设置 Redis 的复制功能。</li><li>从命名上讲，<code>REPLICAOF</code> 更能反映 Redis 在分布式系统中的角色，而 <code>SLAVEOF</code> 则更多地体现了传统的主从复制关系。</li><li>对于新项目或者使用 Redis 5.0 及以上版本的用户，推荐使用 <code>REPLICAOF</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>try-with-resources使用指南</title>
    <link href="/article/9148af35.html"/>
    <url>/article/9148af35.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>Java 7 中引入的对资源 <em>try-with-resources</em> 的支持允许我们声明要在 <em>try</em> 块中使用的资源，并保证资源将在该块执行后关闭。</p><p>声明的资源需要实现_自动关闭接口_。</p><h2 id="2-使用-资源Try代码块"><a href="#2-使用-资源Try代码块" class="headerlink" title="2. 使用_资源Try代码块_"></a>2. 使用_资源Try代码块_</h2><p>简而言之，要自动关闭，必须在 <em>try</em> 中声明和初始化资源：</p><p>try (PrintWriter writer &#x3D; new PrintWriter(new File(“test.txt”))) {<br>    writer.println(“Hello World”);<br>}</p><h2 id="3-用-资源的try-替换-try-finally"><a href="#3-用-资源的try-替换-try-finally" class="headerlink" title="3. 用_资源的try_替换_try-_finally"></a>3. 用_资源的try_替换_try-_finally</h2><p>使用新的“try_资源_”功能的简单而明显的方法是替换传统的_冗长的“try-catch-finally_”块。</p><p>让我们比较以下代码示例。</p><p>第一个是典型的try-_catch-finally_块：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>Scanner scanner &#x3D; null;<br>try {<br>    scanner = new Scanner(new File(“test.txt”));<br>    while (scanner.hasNext()) {<br>        System.out.println(scanner.nextLine());<br>    }<br>} catch (FileNotFoundException e) {<br>    e.printStackTrace();<br>} finally {<br>    if (scanner !&#x3D; null) {<br>        scanner.close();<br>    }<br>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这是使用_资源try_的新的超级简洁解决方案：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>try (Scanner scanner &#x3D; new Scanner(new File(“test.txt”))) {<br>    while (scanner.hasNext()) {<br>        System.out.println(scanner.nextLine());<br>    }<br>} catch (FileNotFoundException fnfe) {<br>    fnfe.printStackTrace();<br>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>下面是进一步探索_扫描程序_类的位置。</p><h2 id="4-使用-多个资源t-ry-with-resources-块"><a href="#4-使用-多个资源t-ry-with-resources-块" class="headerlink" title="4. 使用_多个资源t_ry-with-resources 块"></a>4. <em>使用_多个资源t_ry-with-resources</em> 块</h2><p>我们可以在 <em>try-with-resources</em> 块中声明多个资源，方法是用分号分隔它们：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>try (Scanner scanner &#x3D; new Scanner(new File(“testRead.txt”));<br>    PrintWriter writer = new PrintWriter(new File(“testWrite.txt”))) {<br>    while (scanner.hasNext()) {<br>    writer.print(scanner.nextLine());<br>    }<br>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="5-具有自动关闭功能的-自定义资源"><a href="#5-具有自动关闭功能的-自定义资源" class="headerlink" title="5. _具有自动关闭功能的_自定义资源"></a>5. _具有自动关闭功能的_自定义资源</h2><p>若要构造将由 <em>try-with-resources</em> 块正确处理的自定义资源，该类应实现 Closeable 或 <em>AutoCloseable</em> 接口并重写 <em>close</em> 方法：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>public class MyResource implements AutoCloseable {<br>    @Override<br>    public void close() throws Exception {<br>        System.out.println(“Closed MyResource”);<br>    }<br>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="6-资源关闭顺序"><a href="#6-资源关闭顺序" class="headerlink" title="6. 资源关闭顺序"></a>6. 资源关闭顺序</h2><p>首先定义&#x2F;获取的资源将最后关闭。让我们看一下此行为的示例：</p><p>资源 1：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>public class AutoCloseableResourcesFirst implements AutoCloseable {</p><pre><code class="hljs">public AutoCloseableResourcesFirst() &#123;    System.out.println(&quot;Constructor -&gt; AutoCloseableResources\_First&quot;);&#125;public void doSomething() &#123;    System.out.println(&quot;Something -&gt; AutoCloseableResources\_First&quot;);&#125;@Overridepublic void close() throws Exception &#123;    System.out.println(&quot;Closed AutoCloseableResources\_First&quot;);&#125;</code></pre><p>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>资源 2：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>public class AutoCloseableResourcesSecond implements AutoCloseable {</p><pre><code class="hljs">public AutoCloseableResourcesSecond() &#123;    System.out.println(&quot;Constructor -&gt; AutoCloseableResources\_Second&quot;);&#125;public void doSomething() &#123;    System.out.println(&quot;Something -&gt; AutoCloseableResources\_Second&quot;);&#125;@Overridepublic void close() throws Exception &#123;    System.out.println(&quot;Closed AutoCloseableResources\_Second&quot;);&#125;</code></pre><p>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>使用：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>private void orderOfClosingResources() throws Exception {<br>    try (AutoCloseableResourcesFirst af &#x3D; new AutoCloseableResourcesFirst();<br>        AutoCloseableResourcesSecond as = new AutoCloseableResourcesSecond()) {</p><pre><code class="hljs">    af.doSomething();    as.doSomething();&#125;</code></pre><p>}</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>输出：</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>Constructor -&gt; AutoCloseableResources_First<br>Constructor -&gt; AutoCloseableResources_Second<br>Something-&gt; AutoCloseableResources_First<br>Something-&gt; AutoCloseableResources_Second<br>Closed AutoCloseableResources_Second<br>Closed AutoCloseableResources_First</p><p><a href="javascript:void(0);" title="复制代码"><img src="//assets.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><h2 id="7-catch-和-finally"><a href="#7-catch-和-finally" class="headerlink" title="7.catch__和_finally_"></a>7.<em>catch__和_finally</em>_</h2><p>_try资源_块仍然可以具有_catch_和_finally_块，其工作方式与传统的_try_块相同。</p><h2 id="8-Java-9-–-有效的finally变量"><a href="#8-Java-9-–-有效的finally变量" class="headerlink" title="8. Java 9 – 有效的finally变量"></a>8. Java 9 – 有效的finally变量</h2><p>在Java 9之前，我们只能在_try-with-resources_块中使用新变量：</p><p>try (Scanner scanner &#x3D; new Scanner(new File(“testRead.txt”));<br>    PrintWriter writer = new PrintWriter(new File(“testWrite.txt”))) {<br>    &#x2F;&#x2F; omitted<br>}</p><p>如上所示，这在声明多个资源时尤其冗长。从 Java 9 开始，作为 <a href="https://openjdk.java.net/jeps/213">JEP 213</a> 的一部分，我们现在可以在_资源try_块中使用finally甚至有效的_finally_变量：</p><p>final Scanner scanner &#x3D; new Scanner(new File(“testRead.txt”));<br>PrintWriter writer = new PrintWriter(new File(“testWrite.txt”))<br>try (scanner;writer) {<br>    &#x2F;&#x2F; omitted<br>}</p><p>简而言之，如果变量在第一次赋值后没有更改，即使它没有明确标记为 final，它实际上是 _final_。</p><p>如上所示，<em>scanner</em> 变量被显式声明为 _final_，因此我们可以将其与 <em>try-with-resources</em> 块一起使用。尽管_编写器_变量不是_显式 final_，但它在第一次赋值后不会更改。因此，我们也可以使用_编写器_变量。</p><h2 id="9-结论"><a href="#9-结论" class="headerlink" title="9. 结论"></a>9. 结论</h2><p>在本文中，我们讨论了如何使用 try-with-resources 以及如何用 try-with-resources 替换 _try_、_catch_，_finally_。</p><p>我们还研究了使用 <em>AutoCloseable</em> 构建自定义资源以及资源的关闭顺序。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>@ControllerAdvice 的介绍及三种用法(转载)</title>
    <link href="/article/ce91021a.html"/>
    <url>/article/ce91021a.html</url>
    
    <content type="html"><![CDATA[<h1 id="ControllerAdvice-的介绍及三种用法-转载"><a href="#ControllerAdvice-的介绍及三种用法-转载" class="headerlink" title="@ControllerAdvice 的介绍及三种用法(转载)"></a>@ControllerAdvice 的介绍及三种用法(转载)</h1><!-- toc --><h2 id="浅析-ControllerAdvice"><a href="#浅析-ControllerAdvice" class="headerlink" title="浅析@ControllerAdvice"></a>浅析@<a href="https://so.csdn.net/so/search?q=ControllerAdvice&spm=1001.2101.3001.7020">ControllerAdvice</a></h2><blockquote><p>首先，ControllerAdvice本质上是一个Component，因此也会被当成组件扫描，一视同仁，扫扫扫。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/c0c5578f8dc645b9ac88025f56cd5f5f.png" alt="在这里插入图片描述"></p><p>然后，我们来看一下此类的注释：</p><ul><li><p>这个类是为那些声明了（@<a href="https://so.csdn.net/so/search?q=ExceptionHandler&spm=1001.2101.3001.7020">ExceptionHandler</a>、@InitBinder 或 @ModelAttribute注解修饰的）方法的类而提供的专业化的@Component , 以供多个 Controller类所共享。</p></li><li><p>说白了，就是aop思想的一种实现，你告诉我需要拦截规则，我帮你把他们拦下来，具体你想做更细致的拦截筛选和拦截之后的处理，你自己通过@ExceptionHandler、@InitBinder 或 @<a href="https://so.csdn.net/so/search?q=ModelAttribute&spm=1001.2101.3001.7020">ModelAttribute</a>这三个注解以及被其注解的方法来自定义。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/94d060b22a424217aa6497c462193315.png" alt="在这里插入图片描述"></p><p><strong>初定义拦截规则：</strong></p><p>ControllerAdvice 提供了多种指定Advice规则的定义方式，默认什么都不写，则是Advice所有Controller，当然你也可以通过下列的方式指定规则：</p><ol><li>比如对于 String[] value() default {} , 写成@ControllerAdvice(“org.my.pkg”) 或者 @ControllerAdvice(basePackages&#x3D;“org.my.pkg”), 则匹配org.my.pkg包及其子包下的所有Controller</li><li>当然也可以用数组的形式指定，如：@ControllerAdvice(basePackages&#x3D;{“org.my.pkg”, “org.my.other.pkg”})</li><li>也可以通过指定注解来匹配，比如我自定了一个 @CustomAnnotation 注解，我想匹配所有被这个注解修饰的 Controller, 可以这么写：@ControllerAdvice（annotations&#x3D;{CustomAnnotation.class})</li></ol><p>还有很多用法，这里就不全部罗列了。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Target</span>(ElementType.TYPE)<br><span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-keyword">@Documented</span><br><span class="hljs-keyword">@Component</span><br>public <span class="hljs-keyword">@interface</span> ControllerAdvice &#123;<br><br><span class="hljs-keyword">@AliasFor</span>(<span class="hljs-string">&quot;basePackages&quot;</span>)<br>String[] value() default &#123;&#125;;<br><br><span class="hljs-keyword">@AliasFor</span>(<span class="hljs-string">&quot;value&quot;</span>)<br>String[] basePackages() default &#123;&#125;;<br><br>Class&lt;?&gt;<span class="hljs-selector-attr">[]</span> <span class="hljs-built_in">basePackageClasses</span>() default &#123;&#125;;<br><br>Class&lt;?&gt;<span class="hljs-selector-attr">[]</span> <span class="hljs-built_in">assignableTypes</span>() default &#123;&#125;;<br><br>Class&lt;? extends Annotation&gt;<span class="hljs-selector-attr">[]</span> <span class="hljs-built_in">annotations</span>() default &#123;&#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-处理全局异常"><a href="#1-处理全局异常" class="headerlink" title="1.处理全局异常"></a>1.处理全局异常</h3><blockquote><p>@ControllerAdvice 配合 <code>@ExceptionHandler</code> 实现全局异常处理</p></blockquote><p><strong>用于在特定的处理器类、方法中处理异常的注解</strong></p><p><img src="https://img-blog.csdnimg.cn/a09b3552dda24d3e9fb1287ac4a99472.png" alt="在这里插入图片描述"></p><ul><li><p>接收<code>Throwable</code>类作为参数，我们知道Throwable是所有异常的父类，所以说，可以自行<strong>指定</strong>所有异常</p></li><li><p>比如在方法上加：<code>@ExceptionHandler(IllegalArgumentException.class)</code>，则表明此方法处理<code>IllegalArgumentException</code> 类型的异常，如果参数为空，将默认为方法参数列表中列出的<strong>任何</strong>异常（方法抛出什么异常都接得住）。</p></li></ul><p>下面的例子：处理所有<code>IllegalArgumentException</code>异常，域中加入错误信息errorMessage 并返回错误页面error</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler(IllegalArgumentException.class)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">handleException</span><span class="hljs-params">(IllegalArgumentException e)</span>&#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">modelAndView</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>        modelAndView.addObject(<span class="hljs-string">&quot;errorMessage&quot;</span>, <span class="hljs-string">&quot;参数不符合规范!&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-预设全局数据"><a href="#2-预设全局数据" class="headerlink" title="2.预设全局数据"></a>2.预设全局数据</h3><p><code>@ControllerAdvice</code> 配合 <code>@ModelAttribute</code> 预设全局数据</p><p>我们先来看看 <code>ModelAttribute</code>注解类的源码</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Annotation that binds a method parameter or method return value</span><br><span class="hljs-comment"> * to a named model attribute, exposed to a web view. Supported</span><br><span class="hljs-comment"> * for controller classes with &#123;@link RequestMapping @RequestMapping&#125;</span><br><span class="hljs-comment"> * methods.</span><br><span class="hljs-comment"> * 此注解用于绑定一个方法参数或者返回值到一个被命名的model属性中，暴露给web视图。支持在</span><br><span class="hljs-comment"> * 在Controller类中注有@RequestMapping的方法使用（这里有点拗口，不过结合下面的使用介绍</span><br><span class="hljs-comment"> * 你就会明白的)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@Target</span>(&#123;ElementType.PARAMETER, ElementType.METHOD&#125;)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Documented</span><br>public <span class="hljs-variable">@interface</span> ModelAttribute &#123;<br><br><span class="hljs-variable">@AliasFor</span>(<span class="hljs-string">&quot;name&quot;</span>)<br>String <span class="hljs-built_in">value</span>() default <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-variable">@AliasFor</span>(<span class="hljs-string">&quot;value&quot;</span>)<br>String <span class="hljs-built_in">name</span>() default <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-selector-tag">boolean</span> <span class="hljs-selector-tag">binding</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">true</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><blockquote><p>实际上这个注解的作用就是，允许你往 <code>Model</code> 中注入全局属性（可以供所有Controller中注有<code>@Request Mapping</code>的方法使用），<code>value</code> 和 <code>name</code> 用于指定属性的 key ，<code>binding</code> 表示是否绑定，默认为 true。</p></blockquote><p>具体使用方法如下：</p><p><strong>全局参数绑定</strong></p><ul><li>方式一：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGlobalHandler</span> &#123;<br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">presetParam</span>(<span class="hljs-params">Model model</span>)&#123;<br>        model.<span class="hljs-title function_">addAttribute</span>(<span class="hljs-string">&quot;globalAttr&quot;</span>,<span class="hljs-string">&quot;this is a global attribute&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>这种方式比较灵活，需要什么自己加就行了，加多少属性自己控制</p></blockquote><ul><li>方式二：</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@ControllerAdvice<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGlobalHandler</span> &#123;<br><br>    @ModelAttribute()<br>    public <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; presetParam()&#123;<br>        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt;();<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">map</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式对于加单个属性比较方便。默认会把返回值（如上面的map）作为属性的value，而对于key有两种指定方式：</p><ol><li>当 <code>@ModelAttribute()</code> 不传任何参数的时候，默认会把返回值的字符串值作为key，如上例的 key 则是 ”map”（值得注意的是，不支持字符串的返回值作为key）。</li><li>当 <code>@ModelAttribute(&quot;myMap&quot;)</code> 传参数的时候，则以参数值作为key，这里 key 则是 ”myMap“。</li></ol><p><strong>全局参数使用</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdviceController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;methodOne&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">methodOne</span>(<span class="hljs-params">Model model</span>)&#123; <br>        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; modelMap = model.<span class="hljs-title function_">asMap</span>();<br>        <span class="hljs-keyword">return</span> (<span class="hljs-title class_">String</span>)modelMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;globalAttr&quot;</span>);<br>    &#125;<br><br>  <br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;methodTwo&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">methodTwo</span>(<span class="hljs-params"><span class="hljs-meta">@ModelAttribute</span>(<span class="hljs-string">&quot;globalAttr&quot;</span>) <span class="hljs-built_in">String</span> globalAttr</span>)&#123;<br>        <span class="hljs-keyword">return</span> globalAttr;<br>    &#125;<br><br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;methodThree&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">methodThree</span>(<span class="hljs-params">ModelMap modelMap</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-title class_">String</span>) modelMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;globalAttr&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>这三种方式大同小异，其实都是都是从Model 中存储属性的 Map里取数据。</p><h3 id="3-请求参数预处理"><a href="#3-请求参数预处理" class="headerlink" title="3.请求参数预处理"></a>3.请求参数预处理</h3><blockquote><p><code>@ControllerAdvice</code> 配合 <code>@InitBinder</code> 实现对请求参数的预处理</p></blockquote><p>再次之前我们先来了解一下@IniiBinder，先看一下源码，我会提取一些重要的注释进行浅析</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Annotation that identifies methods which initialize the</span><br><span class="hljs-comment"> * &#123;@link org.springframework.web.bind.WebDataBinder&#125; which</span><br><span class="hljs-comment"> * will be used for populating command and form object arguments</span><br><span class="hljs-comment"> * of annotated handler methods.</span><br><span class="hljs-comment"> * 粗略翻译：此注解用于标记那些 (初始化[用于组装命令和表单对象参数的]WebDataBinder)的方法。</span><br><span class="hljs-comment"> * 原谅我的英语水平，翻译起来太拗口了，从句太多就用‘()、[]’分割一下便于阅读</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Init-binder methods must not have a return value; they are usually</span><br><span class="hljs-comment"> * declared as &#123;@code void&#125;.</span><br><span class="hljs-comment"> * 粗略翻译：初始化绑定的方法禁止有返回值，他们通常声明为 &#x27;void&#x27;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Typical arguments are &#123;@link org.springframework.web.bind.WebDataBinder&#125;</span><br><span class="hljs-comment"> * in combination with &#123;@link org.springframework.web.context.request.WebRequest&#125;</span><br><span class="hljs-comment"> * or &#123;@link java.util.Locale&#125;, allowing to register context-specific editors.</span><br><span class="hljs-comment"> * 粗略翻译：典型的参数是`WebDataBinder`，结合`WebRequest`或`Locale`使用，允许注册特定于上下文的编辑器。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 总结如下：</span><br><span class="hljs-comment"> *  1. @InitBinder 标识的方法的参数通常是 WebDataBinder。</span><br><span class="hljs-comment"> *  2. @InitBinder 标识的方法,可以对 WebDataBinder 进行初始化。WebDataBinder 是 DataBinder 的一个子类,用于完成由表单字段到 JavaBean 属性的绑定。</span><br><span class="hljs-comment"> *  3. @InitBinder 标识的方法不能有返回值,必须声明为void。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">@Target</span>(&#123;ElementType.METHOD&#125;)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br><span class="hljs-variable">@Documented</span><br>public <span class="hljs-variable">@interface</span> InitBinder &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The names of command/form attributes and/or request parameters</span><br><span class="hljs-comment"> * that this init-binder method is supposed to apply to.</span><br><span class="hljs-comment"> * &lt;p&gt;Default is to apply to all command/form attributes and all request parameters</span><br><span class="hljs-comment"> * processed by the annotated handler class. Specifying model attribute names or</span><br><span class="hljs-comment"> * request parameter names here restricts the init-binder method to those specific</span><br><span class="hljs-comment"> * attributes/parameters, with different init-binder methods typically applying to</span><br><span class="hljs-comment"> * different groups of attributes or parameters.</span><br><span class="hljs-comment"> * 粗略翻译：此init-binder方法应该应用于的命令/表单属性和/或请求参数的名称。默认是应用于所有命   * 令/表单属性和所有由带注释的处理类处理的请求参数。这里指定模型属性名或请求参数名将init-binder * 方法限制为那些特定的属性/参数，不同的init-binder方法通常应用于不同的属性或参数组。</span><br><span class="hljs-comment"> * 我至己都理解不太理解这说的是啥呀，我们还是看例子吧</span><br><span class="hljs-comment"> */</span><br><span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">value</span>() <span class="hljs-selector-tag">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们来看看具体用途，其实这些用途在 Controller里也可以定义，但是作用范围就只限当前Controller，因此下面的例子我们将结合 ControllerAdvice 作全局处理。</p><ul><li>参数处理</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyGlobalHandler</span> &#123;<br><br>    <span class="hljs-meta">@InitBinder</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processParam</span>(<span class="hljs-params">WebDataBinder dataBinder</span>)&#123;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 创建一个字符串微调编辑器</span><br><span class="hljs-comment">         * 参数&#123;boolean emptyAsNull&#125;: 是否把空字符串(&quot;&quot;)视为 null</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-title class_">StringTrimmerEditor</span> trimmerEditor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringTrimmerEditor</span>(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 注册自定义编辑器</span><br><span class="hljs-comment">         * 接受两个参数&#123;Class&lt;?&gt; requiredType, PropertyEditor propertyEditor&#125;</span><br><span class="hljs-comment">         * requiredType：所需处理的类型</span><br><span class="hljs-comment">         * propertyEditor：属性编辑器，StringTrimmerEditor就是 propertyEditor的一个子类</span><br><span class="hljs-comment">         */</span><br>        dataBinder.<span class="hljs-title function_">registerCustomEditor</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property">class</span>, trimmerEditor);<br>        <br>        <span class="hljs-comment">//同上，这里就不再一步一步讲解了</span><br>        binder.<span class="hljs-title function_">registerCustomEditor</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-property">class</span>,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomDateEditor</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>), <span class="hljs-literal">false</span>));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这样之后呢，就可以实现全局的实现对 Controller 中RequestMapping标识的方法中的所有 String 和Date类型的参数都会被作相应的处理。</p><blockquote><p>Controller:</p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs livescript">@RestController<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderTestController</span> &#123;<br><br>    @GetMapping(<span class="hljs-string">&quot;processParam&quot;</span>)<br>    public <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; test(<span class="hljs-built_in">String</span> str, <span class="hljs-built_in">Date</span> date) throws Exception &#123;<br>        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt;();<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;str&quot;</span>, str);<br>        <span class="hljs-keyword">map</span>.put(<span class="hljs-string">&quot;data&quot;</span>, date);<br>        <span class="hljs-keyword">return</span>  <span class="hljs-keyword">map</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>测试结果：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8197da8981a9408a8b398264b2f00683.png" alt="在这里插入图片描述"></p><p>我们可以看出，str 和 date 这两个参数在进入 Controller 的test的方法之前已经被处理了，str 被去掉了两边的空格(%20 在Http url 中是空格的意思)，String类型的 1997-1-10被转换成了Date类型。</p><ul><li>参数绑定</li></ul><p>参数绑定可以解决特定问题，那么我们先来看看我们面临的问题</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">// omitted getters and setters.</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Double</span> price;<br>    <span class="hljs-comment">// omitted getters and setters.</span><br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinderTestController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;bindParam&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> void test(Person person, Book book) throws Exception &#123;<br>        System.<span class="hljs-keyword">out</span>.println(person);<br>        System.<span class="hljs-keyword">out</span>.println(book);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们会发现 Person类和 Book 类都有 name属性，那么这个时候就会出先问题，它可没有那么只能区分哪个name是哪个类的。因此 @InitBinder就派上用场了：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGlobalHandler</span> </span>&#123;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @InitBinder(&quot;person&quot;) 对应找到@RequstMapping标识的方法参数中</span><br><span class="hljs-comment">     * 找参数名为person的参数。</span><br><span class="hljs-comment">     * 在进行参数绑定的时候，以‘p.’开头的都绑定到名为person的参数中。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@InitBinder</span>(<span class="hljs-string">&quot;person&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BindPerson</span><span class="hljs-params">(WebDataBinder dataBinder)</span></span>&#123;<br>        dataBinder.setFieldDefaultPrefix(<span class="hljs-string">&quot;p.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@InitBinder</span>(<span class="hljs-string">&quot;book&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BindBook</span><span class="hljs-params">(WebDataBinder dataBinder)</span></span>&#123;<br>        dataBinder.setFieldDefaultPrefix(<span class="hljs-string">&quot;b.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，传入的同名信息就能对应绑定到相应的实体类中：</p><p>p.name -&gt; Person.name b.name -&gt; Book.name</p><p>还有一点注意的是如果 @InitBinder(“value”) 中的 value 值和 Controller 中 @RequestMapping() 标识的方法的参数名不匹配，则就会产生绑定失败的后果,如：</p><p>@InitBinder(“p”)、@InitBinder(“b”)</p><p>public void test(Person person, Book book)</p><p>上述情况就会出现绑定失败，有两种解决办法</p><p>第一种：统一名称，要么全叫p，要么全叫person，只要相同就行。</p><p>第二种：方法参数加 @ModelAttribute，有点类似@RequestParam</p><p>@InitBinder(“p”)、@InitBinder(“b”)</p><p>public void test(@ModelAttribute(“p”) Person person, @ModelAttribute(“b”) Book book)</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring中的spring.factories文件用法(Spring如何加载第三方Bean)</title>
    <link href="/article/3a6476bb.html"/>
    <url>/article/3a6476bb.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h1 id="Spring中的spring-factories文件用法-Spring如何加载第三方Bean"><a href="#Spring中的spring-factories文件用法-Spring如何加载第三方Bean" class="headerlink" title="Spring中的spring.factories文件用法(Spring如何加载第三方Bean)"></a>Spring中的spring.factories文件用法(Spring如何加载第三方Bean)</h1><h2 id="Spring的spring-factories文件用法"><a href="#Spring的spring-factories文件用法" class="headerlink" title="Spring的spring.factories文件用法"></a>Spring的spring.factories文件用法</h2><p>在springBoot中，它自动扫描包的时候，只会扫描自己模块下的类。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果我们不想被Spring容器管理的Bean的路径下不再SpringBoot的包扫描路径下，怎么办呢？如何加载别的第三方Bean呢？</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>首先我们创建一个工程，另外创建一个与启动类不在一个级别的目录。</p><p><strong>第一种方法就是使用在启动类上加上@Import注解。</strong></p><p>@Import(value &#x3D; {Test.class})</p><p><strong>第二种方法就是创建spring.factories文件</strong></p><p>现在我们将其改造一下，采用spring.factories的方式去加载Test类，在resources目录下新建一个META-INF的目录，然后再新建一个spring.factories文件，文件内容为：</p><p>下面第二条就是我们自己的类的路径。</p><p>org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;&#x2F;<br>com.huawei.it.config.Test</p><p>然后在springBoot中的启动类中将@Import注释掉，启动一下，在控制台上就会发现，我们自己的配置类已经加载到Spring容器中去了，所以Spring可以加载一个工程下的任意一下工程类了。</p><p>应用</p><p>下面就是我在Nacos源码中看到的，可以看到spring.factories文件中内容，与我们自己类加载到Spring容器中是一样的道理。</p><p><img src="http://static.codebaoku.com/pics/97/6e/976efb625c23672b1b419bda66f5a3d8.jpg"></p><h2 id="SpringBoot的扩展机制之Spring-Factories"><a href="#SpringBoot的扩展机制之Spring-Factories" class="headerlink" title="SpringBoot的扩展机制之Spring Factories"></a>SpringBoot的扩展机制之Spring Factories</h2><p>写在前面：Spring Boot中有一种非常解耦的扩展机制：Spring Factories。这种扩展机制实际上是仿照Java中的SPI扩展机制来实现的。</p><h3 id="什么是-SPI机制"><a href="#什么是-SPI机制" class="headerlink" title="什么是 SPI机制"></a>什么是 SPI机制</h3><p>SPI的全名为Service Provider Interface.大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档里有比较详细的介绍。</p><p>简单的总结下java SPI机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。</p><p>java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p><h3 id="Spring-Boot中的SPI机制"><a href="#Spring-Boot中的SPI机制" class="headerlink" title="Spring Boot中的SPI机制"></a>Spring Boot中的SPI机制</h3><p>在Spring中也有一种类似与Java SPI的加载机制。它在META-INF&#x2F;spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。</p><p>这种自定义的SPI机制是Spring Boot Starter实现的基础。</p><p><img src="http://static.codebaoku.com/pics/a9/ec/a9ec44cb943700b06a9262946e9dea16.png" alt="这里写图片描述"></p><h3 id="Spring-Factories实现原理是什么"><a href="#Spring-Factories实现原理是什么" class="headerlink" title="Spring Factories实现原理是什么"></a>Spring Factories实现原理是什么</h3><p>spring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF&#x2F;spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法：</p><p><strong>loadFactories</strong> 根据接口类获取其实现类的实例，这个方法返回的是对象列表。</p><p><strong>loadFactoryNames</strong> 根据接口获取其接口类的名称，这个方法返回的是类名的列表。</p><p>上面的两个方法的关键都是从指定的ClassLoader中获取<strong>spring.factories</strong>文件，并解析得到类名列表，具体代码如下↓</p><p>public static List<String> loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) {<br>  String factoryClassName &#x3D; factoryClass.getName();<br>  try {<br>      Enumeration<URL> urls &#x3D; (classLoader !&#x3D; null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :<br>              ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));<br>      List<String> result &#x3D; new ArrayList<String>();<br>      while (urls.hasMoreElements()) {<br>          URL url &#x3D; urls.nextElement();<br>          Properties properties &#x3D; PropertiesLoaderUtils.loadProperties(new UrlResource(url));<br>          String factoryClassNames &#x3D; properties.getProperty(factoryClassName);<br>          result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));<br>      }<br>      return result;<br>  }<br>  catch (IOException ex) {<br>      throw new IllegalArgumentException(“Unable to load [“ + factoryClass.getName() +<br>              “] factories from location [“ + FACTORIES_RESOURCE_LOCATION + “]“, ex);<br>  }<br>}</p><p>从代码中我们可以知道，在这个方法中会遍历整个ClassLoader中所有jar包下的spring.factories文件。也就是说我们可以在自己的jar中配置spring.factories文件，不会影响到其它地方的配置，也不会被别人的配置覆盖。</p><p>spring.factories的是通过Properties解析得到的，所以我们在写文件中的内容都是安装下面这种方式配置的：</p><blockquote><p>com.xxx.interface&#x3D;com.xxx.classname</p></blockquote><p>如果一个接口希望配置多个实现类，可以使用’,’进行分割。</p><h3 id="Spring-Factories在Spring-Boot中的应用"><a href="#Spring-Factories在Spring-Boot中的应用" class="headerlink" title="Spring Factories在Spring Boot中的应用"></a>Spring Factories在Spring Boot中的应用</h3><p>在Spring Boot的很多包中都能够找到spring.factories文件，接下来我们以spring-boot包为例进行介绍</p><p><img src="http://static.codebaoku.com/pics/50/b7/50b74d796aece01582e75f41f6f16a75.jpg"></p><p>在日常工作中，我们可能需要实现一些SDK或者Spring Boot Starter给被人使用时， 我们就可以使用Factories机制。Factories机制可以让SDK或者Starter的使用只需要很少或者不需要进行配置，只需要在服务中引入我们的jar包即可。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>全国电信光猫抓包获取超级密码教程亲测可用</title>
    <link href="/article/fbe35e53.html"/>
    <url>/article/fbe35e53.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>全国电信光猫抓包获取超级密码教程亲测可用<br><a href="https://www.xgiu.com/content/uploadfile/202203/41d51647948525.jpg"><img src="//www.xgiu.com/content/uploadfile/202203/41d51647948525.jpg" alt="627334_d19de945_6340_2334_241@1440x647.jpg" title="点击查看原图"></a>  </p><p>最近看了个其他论坛的帖子，用黄鸟抓包可以破解出电信光猫超级密码，我试了，真的可以，前提是光猫必须和小翼管家app绑定，<br><a href="https://www.xgiu.com/content/uploadfile/202203/0e7e1647948692.jpg"><img src="//www.xgiu.com/content/uploadfile/202203/0e7e1647948692.jpg" alt="21799_2020450img_20220314_202014.jpg" title="点击查看原图"></a><br>1. 下载小翼管家并通过WiFi或其他绑定你的光猫。<br>2. 下载抓包软件如HttpCanary，打开点左上角在目标应用中选择小翼管家，返回主界面右下角开始抓包。<br>3.打开小翼管家，依次点击：网络-网关设置-指示灯(开启或关闭都可以)。<br>4.回到抓包软件停止抓包，然后长按带有如图中字符的，弹出来的对话框选编辑重发。<br><a href="https://www.xgiu.com/content/uploadfile/202203/acf61647948525.jpg"><img src="//www.xgiu.com/content/uploadfile/202203/acf61647948525.jpg" alt="627334_3243c942_6340_8637_181@1438x1228.png.m.jpg" title="点击查看原图"></a>  </p><p><a href="https://www.xgiu.com/content/uploadfile/202203/166a1647948525.jpg"><img src="//www.xgiu.com/content/uploadfile/202203/166a1647948525.jpg" alt="627334_13b7f42d_6340_8626_752@1418x1284.jpeg.m.jpg" title="点击查看原图"></a>  </p><p>选择在线编辑，删除原来的粘贴内容：  </p><ol><li>{ “Params”: [], “MethodName”: “GetTAPasswd”, “RPCMethod”: “CallMethod”, “ObjectPath”: “&#x2F;com&#x2F;ctc&#x2F;igd1&#x2F;Telecom&#x2F;System”, “InterfaceName”: “com.ctc.igd1.SysCmd”, “ServiceName”: “com.ctc.igd1” }</li></ol><p>然后右上角保存，再右上角发送，之后会有下图<br><a href="https://www.xgiu.com/content/uploadfile/202203/412a1647948525.jpg"><img src="//www.xgiu.com/content/uploadfile/202203/412a1647948525.jpg" alt="627334_5f6ebe17_6340_8631_703@1438x1230.png.m.jpg" title="点击查看原图"></a>  </p><p>单击打开，响应-预览  </p><p><a href="https://www.xgiu.com/content/uploadfile/202203/8ed71647948525.jpg"><img src="//www.xgiu.com/content/uploadfile/202203/8ed71647948525.jpg" alt="627334_c39db45c_6340_864_411@1440x3120.jpeg.m.jpg" title="点击查看原图"></a><br>红线部分就是超级密码。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光猫</tag>
      
      <tag>组播</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>activemq 集群消息接受不到</title>
    <link href="/article/cf510801.html"/>
    <url>/article/cf510801.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>公司有一套公共的Activemq环境供业务系统使用，由于信创，新搭建了一套6节点（三主三从）集群环境，业务系统接入时反应消息接受不到。</p><p>通过查看activemq日志发现有大量连接报错，去排查文件发现activemq.xml的brokerName 配置重复。</p><p>配置文件修改后重启，发现错误消失，自测时正常生产和消费消息。但业务系统反馈依然有消息消费不到。</p><p>通过对比新老环境的配置文件没有发现异常问题，测试连接老集群时发现只有主节点能接受消息，和访问控制台端口，从节点升为主之后才能访问。但是新集群的所有节点都能接受消息和访问，所以还是怀疑配置文件问题。对了一天也没发现。</p><p>第二天通过对比新老集群activemq的启动日志发现，老集群的从节点启动日志要少于新机器，通过对比发现</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Database</span> /ope/activemq/data/kahadb/<span class="hljs-keyword">lock</span> <span class="hljs-keyword">is</span> locked <span class="hljs-keyword">by</span> another <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>新集群的从节点没有这条日志直接去连接其他主节点服务器了<br>忽然想到，集群是基于kahadb共享存储实现的集群，应该是用的同一份存储，因为是部署在容器云上的，对比发现，主和从的挂载目录不一样。修改一致后集群正常。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>activemq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何播放组播源</title>
    <link href="/article/8bf2eb81.html"/>
    <url>/article/8bf2eb81.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>1.管理员登录光猫后台<br><a href="https://zhuanlan.zhihu.com/p/621493289?utm_id=0&amp;wd=&amp;eqid=84726864000020470000000564800ebd">https://zhuanlan.zhihu.com/p/621493289?utm_id=0&amp;wd=&amp;eqid=84726864000020470000000564800ebd</a><br>2.将IPTV和LAN端口用vlan绑定在一起<br><a href="https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=8271973&amp;highlight=%E6%B5%8E%E5%8D%97%E8%81%94%E9%80%9A">https://www.right.com.cn/forum/forum.php?mod=viewthread&amp;tid=8271973&amp;highlight=%E6%B5%8E%E5%8D%97%E8%81%94%E9%80%9A</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>光猫</tag>
      
      <tag>组播</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端埋点实现方式</title>
    <link href="/article/92939f72.html"/>
    <url>/article/92939f72.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="1-为什么使用前端埋点？"><a href="#1-为什么使用前端埋点？" class="headerlink" title="1.为什么使用前端埋点？"></a>1.为什么使用前端埋点？</h2><p>主要是为了收集产品数据，它的目的是上报相关行为数据，相关人员以数据为依据来分析产品在用户端的使用情况，根据分析出来的结果辅助产品优化、迭代、以及新需求的开发。</p><h2 id="2-目前项目埋点方面存在的痛点？"><a href="#2-目前项目埋点方面存在的痛点？" class="headerlink" title="2.目前项目埋点方面存在的痛点？"></a>2.目前项目埋点方面存在的痛点？</h2><p>1.逻辑复用问题：特别是曝光相关的点需要在业务代码里面做额外的处理，所以逻辑复用很困难，对现有代码的侵入也很严重；</p><p>2.埋点在多个项目中分散存在，维护会比较麻烦。</p><h2 id="3-前端埋点方案"><a href="#3-前端埋点方案" class="headerlink" title="3.前端埋点方案"></a>3.前端埋点方案</h2><p>目前主要有 3 种方案：</p><p>1.手动代码埋点：用户触发某个动作后手动上报数据 优点：是最准确的，可以满足很多定制化的需求。 缺点：埋点逻辑与业务代码耦合到一起，不利于代码维护和复用。</p><p>2.可视化埋点：通过可视化工具配置采集节点，指定自己想要监测的元素和属性。核心是查找 dom 然后绑定事件，业界比较有名的是 Mixpanel、GrowingIO、神策 优点：可以做到按需配置，又不会像全埋点那样产生大量的无用数据。 缺点：比较难加载一些运行时参数；页面结构发生变化的时候，可能就需要进行部分重新配置。</p><p>3.无埋点：也叫“全埋点”，前端自动采集全部事件并上报埋点数据，在后端数据计算时过滤出有用数据 优点：收集用户的所有端上行为，很全面。 缺点：无效的数据很多、上报数据量大。</p><h2 id="4-埋点方式"><a href="#4-埋点方式" class="headerlink" title="4.埋点方式"></a>4.埋点方式</h2><p>按照获取数据的方式一般分为三类：</p><p>页面埋点：统计用户进入或离开页面的各种维度信息，如页面浏览次数（PV）、浏览页面人数（UV）、页面停留时间、浏览器信息等。</p><p>点击埋点：统计用户在应用内的每一次点击事件，如报价列表的浏览次数、再次询价的次数等。</p><p>曝光埋点：统计具体区域是否被用户浏览到，如活动的引流入口的显示、投放广告的显示等</p><h2 id="5-埋点方案"><a href="#5-埋点方案" class="headerlink" title="5.埋点方案"></a>5.埋点方案</h2><p>目前我们项目中埋点需求主要有，点击埋点（dom点击）、页面埋点（主要是pv）。再根据我们目前选用的vue技术栈，所以考虑了以下两种实现方式：组件方式或者指令方式</p><p>点击埋点开始的是想提供一个组件，包裹需要进行点击埋点的 dom 元素，也有可能是组件，然后给子元素绑定点击事件，当用户触发事件时进行埋点相关处理。</p><p>但是这样就必须绑定点击事件到 dom 上，但是又不想在文档结构中引入额外的 dom 元素，因为这会增加 dom 结构层级，层级会变得更复杂。</p><p>所以最终采用了自定义指令的方式。</p><h2 id="6-项目埋点实现"><a href="#6-项目埋点实现" class="headerlink" title="6. 项目埋点实现"></a>6. 项目埋点实现</h2><p>使用策略模式分别处理埋点需求：</p><p>vbnet</p><p>复制代码</p><p><code>/**  * @description: 埋点方式：点击埋点、页面PV  * @param &#123;key&#125; 埋点key值  * @return &#123;el&#125; 点击埋点被绑定的元素  */ const handler = &#123;   click (key, el) &#123;     el.addEventListener(&#39;click&#39;, () =&gt; &#123;       appPointBatchInsert(key)     &#125;)   &#125;,   pv (key) &#123;     appPointBatchInsert(key)   &#125; &#125;</code></p><p>自定义埋点指令</p><p>typescript</p><p>复制代码</p><p><code>const Point = &#123;&#125; Point.install = Vue =&gt; &#123;   Vue.directive(&#39;point&#39;, &#123;     inserted (el, binding) &#123;       const data = binding.value       if (data) &#123;         const &#123; key, type &#125; = data         handler[type](key, el)       &#125; else &#123;         throw new Error(&#39;请补充正确的埋点参数&#39;)       &#125;     &#125;   &#125;, false) &#125; export default Point</code></p><p>使用示例</p><p>main.js</p><p>复制代码</p><p><code>import point from &#39;@/utils/directive/point.js&#39; Vue.use(point)</code></p><p>xml</p><p>复制代码</p><p><code>&lt;!-- 点击埋点 --&gt; &lt;el-button v-point=&quot;&#123;key: &#39;additionalInquiryClickKey&#39;, type: &#39;click&#39;&#125;&quot;&gt;追加&lt;/el-button&gt; &lt;!-- 页面pv埋点: section为页面根元素 --&gt; &lt;section class=&quot;additional-inquiry&quot; v-point=&quot;&#123;key: &#39;additionalInquiryKey&#39;, type: &#39;pv&#39;&#125;&quot;&gt; ...</code></p><h2 id="7、之后拓展方向"><a href="#7、之后拓展方向" class="headerlink" title="7、之后拓展方向"></a>7、之后拓展方向</h2><p>曝光埋点（可能产品需求方向？？） 思路：当指令第一绑定在元素上时监听目标元素，当指令从元素上解绑时停止监听目标元素。</p><p>javascript</p><p>复制代码</p><p><code>const options = &#123;     root: null, //默认浏览器视窗     threshold: 1 //元素完全出现在浏览器视窗内才执行callback函数。 &#125; const callback =(entries, observer) =&gt; &#123;   entries.forEach(entry =&gt; &#123;&#125;) &#125; const observer = new IntersectionObserver(callback, options) const addListenner = (ele, binding) =&gt; &#123;  observer.observe(ele) &#125; const removeListener = (ele) =&gt; &#123;   observer.unobserve(ele) &#125; //自定义曝光指令 Vue.directive(&#39;point&#39;, &#123;   bind: addListenner,   unbind: removeListener &#125;)</code></p><p>注意，我们需要创建一个list将已经上报过的埋点信息记录下来，防止重复曝光。</p><p>scss</p><p>复制代码</p><p><code>let pointList = []; //记录已经上报过的埋点信息 const addListenner = (ele, binding) =&gt; &#123;  if(pointList.indexOf(binding.value) !== -1) return  observer.observe(ele) &#125;</code></p><p>我们将要上报的信息绑定在目标元素的 ‘point-data’ 属性中，当目标元素出现在视窗内时，并停留 5 秒以上(或者规定记录秒数时)时，上报埋点信息。</p><p>javascript</p><p>复制代码</p><p><code>let timer = &#123;&#125; //增加定时器对象 const callback = entries =&gt; &#123;   entries.forEach(entry =&gt; &#123;     let pointData = null     try &#123;       pointData = JSON.parse(entry.target.getAttribute(&#39;point-data&#39;))     &#125; catch (e) &#123;       pointData = null       console.error(&#39;埋点数据格式异常&#39;, e)     &#125;     //没有埋点数据取消上报     if (!pointData) &#123;       observer.unobserve(entry.target)       return     &#125;     if (entry.isIntersecting) &#123;       timer[pointData.id] = setTimeout(function() &#123;         //上报埋点信息         sendUtm(pointData).then(res =&gt; &#123;           if (res.success) &#123;             //上报成功后取消监听             observer.unobserve(entry.target)             visuallyList.push(pointData.id)             timer[pointData.id] = null           &#125;         &#125;)       &#125;, 5000)   &#125; else &#123;     if (timer[pointData.id]) &#123;       clearTimeout(timer[pointData.id])       timer[pointData.id] = null     &#125;   &#125;   &#125;) &#125;</code></p><p>在代码中可以直接使用指令实现曝光埋点了：</p><p>ruby</p><p>复制代码</p><p><code>&lt;div v-point=&quot;pointData.id&quot; :point-data=&quot;JSON.stringify(pointData)&quot;&gt;&lt;/div&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven依赖知识点</title>
    <link href="/article/9957a42b.html"/>
    <url>/article/9957a42b.html</url>
    
    <content type="html"><![CDATA[<h1 id="Maven依赖管理项目构建工具"><a href="#Maven依赖管理项目构建工具" class="headerlink" title="Maven依赖管理项目构建工具"></a>Maven依赖管理项目构建工具</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>[TOC]</p><h2 id="一、Maven简介"><a href="#一、Maven简介" class="headerlink" title="一、Maven简介"></a>一、Maven简介</h2><h3 id="1、为什么学习Maven"><a href="#1、为什么学习Maven" class="headerlink" title="1、为什么学习Maven"></a>1、为什么学习Maven</h3><h4 id="1-1、Maven是一个依赖管理工具"><a href="#1-1、Maven是一个依赖管理工具" class="headerlink" title="1.1、Maven是一个依赖管理工具"></a>1.1、Maven是一个依赖管理工具</h4><p>①jar 包的规模</p><p>随着我们使用越来越多的框架，或者框架封装程度越来越高，项目中使用的jar包也越来越多。项目中，一个模块里面用到上百个jar包是非常正常的。</p><p>比如下面的例子，我们只用到 SpringBoot、SpringCloud 框架中的三个功能：</p><ul><li><p>Nacos 服务注册发现</p></li><li><p>Web 框架环境</p></li><li><p>视图模板技术 Thymeleaf</p></li></ul><p>最终却导入了 106 个 jar 包：</p><blockquote><p>org.springframework.security:spring-security-rsa:jar:1.0.9.RELEASE:compile</p></blockquote><blockquote><p>com.netflix.ribbon: ribbon:jar:2.3.0:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter-thymeleaf:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>commons-configuration:commons-configuration:jar:1.8:compile</p></blockquote><blockquote><p>org.apache.logging.log4j:log4j-api:jar:2.13.3:compile</p></blockquote><blockquote><p>org.springframework:spring-beans:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-starter-netflix-ribbon:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.apache.tomcat.embed:tomcat-embed-websocket:jar:9.0.39:compile</p></blockquote><blockquote><p>com.alibaba.cloud:spring-cloud-alibaba-commons:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.bouncycastle:bcprov-jdk15on:jar:1.64:compile</p></blockquote><blockquote><p>org.springframework.security:spring-security-crypto:jar:5.3.5.RELEASE:compile</p></blockquote><blockquote><p>org.apache.httpcomponents:httpasyncclient:jar:4.1.4:compile</p></blockquote><blockquote><p>com.google.j2objc:j2objc-annotations:jar:1.3:compile</p></blockquote><blockquote><p>com.fasterxml.jackson.core:jackson-databind:jar:2.11.3:compile</p></blockquote><blockquote><p>io.reactivex:rxjava:jar:1.3.8:compile</p></blockquote><blockquote><p>ch.qos.logback:logback-classic:jar:1.2.3:compile</p></blockquote><blockquote><p>org.springframework:spring-web:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>io.reactivex:rxnetty-servo:jar:0.4.9:runtime</p></blockquote><blockquote><p>org.springframework:spring-core:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>io.github.openfeign.form:feign-form-spring:jar:3.8.0:compile</p></blockquote><blockquote><p>io.github.openfeign.form:feign-form:jar:3.8.0:compile</p></blockquote><blockquote><p>com.netflix.ribbon:ribbon-loadbalancer:jar:2.3.0:compile</p></blockquote><blockquote><p>org.apache.httpcomponents:httpcore:jar:4.4.13:compile</p></blockquote><blockquote><p>org.thymeleaf.extras:thymeleaf-extras-java8time:jar:3.0.4.RELEASE:compile</p></blockquote><blockquote><p>org.slf4j:jul-to-slf4j:jar:1.7.30:compile</p></blockquote><blockquote><p>com.atguigu.demo:demo09-base-entity:jar:1.0-SNAPSHOT:compile</p></blockquote><blockquote><p>org.yaml:snakeyaml:jar:1.26:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter-logging:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>io.reactivex:rxnetty-contexts:jar:0.4.9:runtime</p></blockquote><blockquote><p>org.apache.httpcomponents:httpclient:jar:4.5.13:compile</p></blockquote><blockquote><p>io.github.openfeign:feign-core:jar:10.10.1:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter-aop:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>org.hdrhistogram:HdrHistogram:jar:2.1.9:compile</p></blockquote><blockquote><p>org.springframework:spring-context:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>commons-lang:commons-lang:jar:2.6:compile</p></blockquote><blockquote><p>io.prometheus:simpleclient:jar:0.5.0:compile</p></blockquote><blockquote><p>ch.qos.logback:logback-core:jar:1.2.3:compile</p></blockquote><blockquote><p>org.springframework:spring-webmvc:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>com.sun.jersey:jersey-core:jar:1.19.1:runtime</p></blockquote><blockquote><p>javax.ws.rs:jsr311-api:jar:1.1.1:runtime</p></blockquote><blockquote><p>javax.inject:javax.inject:jar:1:runtime</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-openfeign-core:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>com.netflix.ribbon:ribbon-core:jar:2.3.0:compile</p></blockquote><blockquote><p>com.netflix.hystrix:hystrix-core:jar:1.5.18:compile</p></blockquote><blockquote><p>com.netflix.ribbon:ribbon-transport:jar:2.3.0:runtime</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter-json:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-starter-openfeign:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.11.3:compile</p></blockquote><blockquote><p>com.sun.jersey.contribs:jersey-apache-client4:jar:1.19.1:runtime</p></blockquote><blockquote><p>io.github.openfeign:feign-hystrix:jar:10.10.1:compile</p></blockquote><blockquote><p>io.github.openfeign:feign-slf4j:jar:10.10.1:compile</p></blockquote><blockquote><p>com.alibaba.nacos:nacos-client:jar:1.4.2:compile</p></blockquote><blockquote><p>org.apache.httpcomponents:httpcore-nio:jar:4.4.13:compile</p></blockquote><blockquote><p>com.sun.jersey:jersey-client:jar:1.19.1:runtime</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-context:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.glassfish:jakarta.el:jar:3.0.3:compile</p></blockquote><blockquote><p>org.apache.logging.log4j:log4j-to-slf4j:jar:2.13.3:compile</p></blockquote><blockquote><p>com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.11.3:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-commons:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.aspectj:aspectjweaver:jar:1.9.6:compile</p></blockquote><blockquote><p>com.alibaba.cloud:spring-cloud-starter-alibaba-nacos-discovery:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>com.google.guava:listenablefuture:jar:9999.0-empty-to-avoid-conflict-with-guava:compile</p></blockquote><blockquote><p>com.alibaba.spring:spring-context-support:jar:1.0.10:compile</p></blockquote><blockquote><p>jakarta.annotation:jakarta.annotation-api:jar:1.3.5:compile</p></blockquote><blockquote><p>org.bouncycastle:bcpkix-jdk15on:jar:1.64:compile</p></blockquote><blockquote><p>com.netflix.netflix-commons:netflix-commons-util:jar:0.3.0:runtime</p></blockquote><blockquote><p>com.fasterxml.jackson.core:jackson-annotations:jar:2.11.3:compile</p></blockquote><blockquote><p>com.google.guava:guava:jar:29.0-jre:compile</p></blockquote><blockquote><p>com.google.guava:failureaccess:jar:1.0.1:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.11.3:compile</p></blockquote><blockquote><p>com.atguigu.demo:demo08-base-api:jar:1.0-SNAPSHOT:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-starter-netflix-archaius:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-autoconfigure:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>org.slf4j:slf4j-api:jar:1.7.30:compile</p></blockquote><blockquote><p>commons-io:commons-io:jar:2.7:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-starter:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.apache.tomcat.embed:tomcat-embed-core:jar:9.0.39:compile</p></blockquote><blockquote><p>io.reactivex:rxnetty:jar:0.4.9:runtime</p></blockquote><blockquote><p>com.fasterxml.jackson.core:jackson-core:jar:2.11.3:compile</p></blockquote><blockquote><p>com.google.code.findbugs:jsr305:jar:3.0.2:compile</p></blockquote><blockquote><p>com.netflix.archaius:archaius-core:jar:0.7.6:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter-web:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>commons-codec:commons-codec:jar:1.14:compile</p></blockquote><blockquote><p>com.netflix.servo:servo-core:jar:0.12.21:runtime</p></blockquote><blockquote><p>com.google.errorprone:error_prone_annotations:jar:2.3.4:compile</p></blockquote><blockquote><p>org.attoparser:attoparser:jar:2.0.5.RELEASE:compile</p></blockquote><blockquote><p>com.atguigu.demo:demo10-base-util:jar:1.0-SNAPSHOT:compile</p></blockquote><blockquote><p>org.checkerframework:checker-qual:jar:2.11.1:compile</p></blockquote><blockquote><p>org.thymeleaf:thymeleaf-spring5:jar:3.0.11.RELEASE:compile</p></blockquote><blockquote><p>commons-fileupload:commons-fileupload:jar:1.4:compile</p></blockquote><blockquote><p>com.netflix.ribbon:ribbon-httpclient:jar:2.3.0:compile</p></blockquote><blockquote><p>com.netflix.netflix-commons:netflix-statistics:jar:0.1.1:runtime</p></blockquote><blockquote><p>org.unbescape:unbescape:jar:1.1.6.RELEASE:compile</p></blockquote><blockquote><p>org.springframework:spring-jcl:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>com.alibaba.nacos:nacos-common:jar:1.4.2:compile</p></blockquote><blockquote><p>commons-collections:commons-collections:jar:3.2.2:runtime</p></blockquote><blockquote><p>javax.persistence:persistence-api:jar:1.0:compile</p></blockquote><blockquote><p>com.alibaba.nacos:nacos-api:jar:1.4.2:compile</p></blockquote><blockquote><p>org.thymeleaf:thymeleaf:jar:3.0.11.RELEASE:compile</p></blockquote><blockquote><p>org.springframework:spring-aop:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.boot:spring-boot-starter-tomcat:jar:2.3.6.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-netflix-ribbon:jar:2.2.6.RELEASE:compile</p></blockquote><blockquote><p>org.springframework:spring-expression:jar:5.2.11.RELEASE:compile</p></blockquote><blockquote><p>org.springframework.cloud:spring-cloud-netflix-archaius:jar:2.2.6.RELEASE:compile</p></blockquote><p>而如果使用 Maven 来引入这些 jar 包只需要配置三个『<strong>依赖</strong>』：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!-- Nacos 服务注册发现启动器 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br><span class="hljs-comment">&lt;!-- web启动器依赖 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br><span class="hljs-comment">&lt;!-- 视图模板技术 thymeleaf --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>②jar包的来源问题</p><ul><li><p>这个jar包所属技术的官网。官网通常是英文界面，网站的结构又不尽相同，甚至找到下载链接还发现需要通过特殊的工具下载。</p></li><li><p>第三方网站提供下载。问题是不规范，在使用过程中会出现各种问题。</p></li></ul><p>  - jar包的名称</p><p>  - jar包的版本</p><p>  - jar包内的具体细节</p><ul><li>而使用 Maven 后，依赖对应的 jar 包能够<strong>自动下载</strong>，方便、快捷又规范。</li></ul><p>③jar包的导入问题</p><p>在web工程中，jar包必须存放在指定位置：</p><p><img src="/image/image-20231021101825708.png" alt="image-20231021101825708"></p><p>在使用Maven之后，通过配置依赖(jar包)的坐标，查找本地仓库中相应jar包，若本地仓库没有，则统一从镜像网站或中央仓库中下载：</p><p><img src="/image/image-20231021102831531.png" alt="image-20231021102831531"></p><p>④jar包之间的依赖</p><p>框架中使用的 jar 包，不仅数量庞大，而且彼此之间存在错综复杂的依赖关系。依赖关系的复杂程度，已经上升到了完全不能靠人力手动解决的程度。另外，jar 包之间有可能产生冲突。进一步增加了我们在 jar 包使用过程中的难度。</p><p>下面是前面例子中 jar 包之间的依赖关系：</p><p><img src="/image/img006.ab4f2e31.png" alt="images"></p><p>而实际上 jar 包之间的依赖关系是普遍存在的，如果要由程序员手动梳理无疑会增加极高的学习成本，而这些工作又对实现业务功能毫无帮助。</p><p>而使用 Maven 则几乎不需要管理这些关系，极个别的地方调整一下即可，极大的减轻了我们的工作量。</p><h4 id="1-2、Maven是一个构建工具"><a href="#1-2、Maven是一个构建工具" class="headerlink" title="1.2、Maven是一个构建工具"></a>1.2、Maven是一个构建工具</h4><p>①你没有注意过的构建</p><p>你可以不使用 Maven，但是构建必须要做。当我们使用 IDEA 进行开发时，构建是 IDEA 替我们做的。</p><p><img src="/image/image-20231021103758624.png" alt="image-20231021103758624"></p><p>②脱离 IDE 环境仍需构建</p><p><img src="/image/image.png" alt="img"></p><h4 id="1-3、结论"><a href="#1-3、结论" class="headerlink" title="1.3、结论"></a>1.3、结论</h4><ul><li><p><strong>管理规模庞大的 jar 包，需要专门工具。</strong></p></li><li><p><strong>脱离 IDE 环境执行构建操作，需要专门工具。</strong></p></li></ul><h3 id="2-Maven介绍"><a href="#2-Maven介绍" class="headerlink" title="2. Maven介绍"></a>2. Maven介绍</h3><p><a href="https://maven.apache.org/what-is-maven.html">https://maven.apache.org/what-is-maven.html</a></p><p>Maven 是一款为 Java 项目管理构建、依赖管理的工具（软件），使用 Maven 可以自动化构建、测试、打包和发布项目，大大提高了开发效率和质量。</p><p>Maven就是一个软件，掌握安装、配置、以及基本功能 <strong>（项目构建、依赖管理）</strong> 的理解和使用即可！</p><ol><li><strong>依赖管理：</strong></li></ol><p>   Maven 可以管理项目的依赖，包括自动下载所需依赖库、自动下载依赖需要的依赖并且保证版本没有冲突、依赖版本管理等。通过 Maven，我们可以方便地维护项目所依赖的外部库，避免版本冲突和转换错误等，而我们仅仅需要编写配置即可。</p><ol start="2"><li><strong>构建管理：</strong></li></ol><p>   项目构建是指将源代码、配置文件、资源文件等转化为能够运行或部署的应用程序或库的过程</p><p>   Maven 可以管理项目的编译、测试、打包、部署等构建过程。通过实现标准的构建生命周期，Maven 可以确保每一个构建过程都遵循同样的规则和最佳实践。同时，Maven 的插件机制也使得开发者可以对构建过程进行扩展和定制。主动触发构建，只需要简单的命令操作即可。</p><p>   <img src="/image/image_OSOE45UACw.png"></p><p><strong>场景1：</strong> 例如我们项目需要第三方依赖如：Druid连接池、MySQL数据库驱动和Jackson JSON等处理。那么我们可以将想要的依赖项的信息编写到Maven工程的配置文件，Maven就会自动下载并复制这些依赖项到项目中，无需自己导入jar包，管理jar!</p><p><strong>场景2：</strong> 项目完成开发，我们想要打成war部署到服务器中，使用maven的构建命令可以快速打包！节省大量时间！</p><h3 id="3-Maven软件工作原理模型图（了解）"><a href="#3-Maven软件工作原理模型图（了解）" class="headerlink" title="3. Maven软件工作原理模型图（了解）"></a>3. Maven软件工作原理模型图（了解）</h3><p><img src="/image/image_6AVFQbaXLj.png"></p><h2 id="二、Maven安装和配置"><a href="#二、Maven安装和配置" class="headerlink" title="二、Maven安装和配置"></a>二、Maven安装和配置</h2><h3 id="1-Maven安装"><a href="#1-Maven安装" class="headerlink" title="1. Maven安装"></a>1. Maven安装</h3><p><a href="https://maven.apache.org/docs/history.html">https://maven.apache.org/docs/history.html</a></p><p>各个工具选用版本：</p><p>| 工具  | 版本   |</p><p>| —– | —— |</p><p>| Maven | 3.8.8  |</p><p>| JDK   | 17     |</p><p>| IDEA  | 2022.2 |</p><p><strong>安装条件：</strong> maven需要本机安装java环境、必需包含java_home环境变量！</p><p><strong>软件安装：</strong> 右键解压即可（绿色免安装）</p><p><strong>软件结构：</strong></p><p><img src="/image/image-20231021110800113.png" alt="image-20231021110800113"></p><p><strong>bin</strong>：含有Maven的运行脚本</p><p>boot：含有plexus-classworlds类加载器框架</p><p><strong>conf</strong>：含有Maven的核心配置文件</p><p>lib：含有Maven运行时所需要的Java类库</p><p>LICENSE、NOTICE、README.txt：针对Maven版本，第三方软件等简要介绍</p><h3 id="2-Maven环境配置"><a href="#2-Maven环境配置" class="headerlink" title="2. Maven环境配置"></a>2. Maven环境配置</h3><ol><li> 配置MAVEN_HOME</li></ol><p>    <img src="/image/image-20231021110938230.png" alt="image-20231021110938230"></p><ol start="2"><li> 配置Path</li></ol><p>    <img src="/image/image_xNL5Fg_ucf.png"></p><ol start="3"><li> 命令测试（cmd窗口）</li></ol><p>    <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>    mvn -v<br><br>    <span class="hljs-comment"># 输出版本信息即可，如果错误，请仔细检查环境变量即可！</span><br><br></code></pre></td></tr></table></figure></p><h3 id="3-Maven功能配置"><a href="#3-Maven功能配置" class="headerlink" title="3. Maven功能配置"></a>3. Maven功能配置</h3><blockquote><p>我们需要需改<strong>maven&#x2F;conf&#x2F;settings.xml</strong>配置文件，来修改maven的一些默认配置。我们主要休要修改的有三个配置：</p></blockquote><blockquote></blockquote><blockquote><p>1.依赖本地缓存位置（本地仓库位置）</p></blockquote><blockquote></blockquote><blockquote><p>2.maven下载镜像</p></blockquote><blockquote></blockquote><blockquote><p>3.maven选用编译项目的jdk版本</p></blockquote><ol><li> 配置本地仓库地址</li></ol><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>      <span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       | The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       |</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       | Default: $&#123;user.home&#125;/.m2/repository</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      &lt;localRepository&gt;/path/to/local/repo&lt;/localRepository&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      --&gt;</span><br><br>     <span class="hljs-comment">&lt;!-- conf/settings.xml 55行 --&gt;</span><br><br>     <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\maven-repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><ol start="2"><li> 配置国内阿里镜像</li></ol><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    <span class="hljs-comment">&lt;!--在mirrors节点(标签)下添加中央仓库镜像 160行附近--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><ol start="3"><li> 配置jdk17版本项目构建</li></ol><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    <span class="hljs-comment">&lt;!--在profiles节点(标签)下添加jdk编译版本 268行附近--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-17<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><h3 id="4-IDEA配置本地Maven软件"><a href="#4-IDEA配置本地Maven软件" class="headerlink" title="4. IDEA配置本地Maven软件"></a>4. IDEA配置本地Maven软件</h3><blockquote><p>我们需要将配置好的maven软件，配置到idea开发工具中即可！ 注意：idea工具默认自带maven配置软件，但是因为没有修改配置，建议替换成本地配置好的maven！</p></blockquote><p>选择本地maven软件</p><p><img src="/image/image-20231021112046512.png" alt="image-20231021112046512"></p><p><strong>注意</strong>：</p><p>1、如果本地仓库地址不变化，只有一个原因，就是maven&#x2F;conf&#x2F;settings.xml配置文件编写错误！仔细检查即可！</p><p>2、一定保证User settings file对应之前修改的settings.xml的路径，若 不一致，选中Override复选框，手动选择配置文件</p><h2 id="三、基于IDEA创建Maven工程"><a href="#三、基于IDEA创建Maven工程" class="headerlink" title="三、基于IDEA创建Maven工程"></a>三、基于IDEA创建Maven工程</h2><h3 id="1-概念梳理Maven工程的GAVP"><a href="#1-概念梳理Maven工程的GAVP" class="headerlink" title="1. 概念梳理Maven工程的GAVP"></a>1. 概念梳理Maven工程的GAVP</h3><p>Maven工程相对之前的项目，多出一组gavp属性，gav需要我们在创建项目的时候指定，p有默认值，我们先行了解下这组属性的含义：</p><p>Maven 中的 GAVP 是指 GroupId、ArtifactId、Version、Packaging 等四个属性的缩写，其中前三个是必要的，而 Packaging 属性为可选项。这四个属性主要为每个项目在maven仓库中做一个标识，类似人的姓-名！有了具体标识，方便后期项目之间相互引用依赖等！</p><p>GAV遵循一下规则：</p><p>​   1） <strong>GroupID 格式</strong>：com.{公司&#x2F;BU }.业务线.[子业务线]，最多 4 级。</p><p>​       说明：{公司&#x2F;BU} 例如：alibaba&#x2F;taobao&#x2F;tmall&#x2F;aliexpress 等 BU 一级；子业务线可选。</p><p>​       正例：com.taobao.tddl 或 com.alibaba.sourcing.multilang</p><p>​   2） <strong>ArtifactID 格式</strong>：产品线名-模块名。语义不重复不遗漏，先到仓库中心去查证一下。</p><p>​       正例：tc-client &#x2F; uic-api &#x2F; tair-tool &#x2F; bookstore</p><p>​   3） <strong>Version版本号格式推荐</strong>：主版本号.次版本号.修订号</p><p>​       1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。</p><p>​       2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。</p><p>​       3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。</p><p>​       例如： 初始→1.0.0  修改bug → 1.0.1  功能调整 → 1.1.1等</p><p><strong>Packaging定义规则：</strong></p><p>​   指示将项目打包为什么类型的文件，idea根据packaging值，识别maven项目类型！</p><p>​   packaging 属性为 jar（默认值），代表普通的Java工程，打包以后是.jar结尾的文件。</p><p>​   packaging 属性为 war，代表Java的web工程，打包以后.war结尾的文件。</p><p>​   packaging 属性为 pom，代表不会打包，用来做继承的父工程。</p><h3 id="2-Idea构建Maven-Java-SE工程"><a href="#2-Idea构建Maven-Java-SE工程" class="headerlink" title="2. Idea构建Maven Java SE工程"></a>2. Idea构建Maven Java SE工程</h3><p>注意：此处省略了version，直接给了一个默认值：<strong>1.0-SNAPSHOT</strong></p><p>自己后期可以在项目中随意修改！</p><p><img src="/image/image-20231021143559114.png" alt="image-20231021143559114"></p><p>创建工程之后，若第一次使用maven，或者使用的是新的<strong>本地仓库</strong>，idea右下角会出现以下进度条，表示maven正在下载相关插件，等待下载完毕，进度条消失即可</p><p><img src="/image/image-20231021145024505.png" alt="image-20231021145024505"></p><p>验证maven工程是否创建成功，当创建完毕maven工程之后，idea中会自动打开Maven视图，如下图：</p><p><img src="/image/image-20231021145713433.png" alt="image-20231021145713433"></p><h3 id="3-Idea构建Maven-Java-Web工程"><a href="#3-Idea构建Maven-Java-Web工程" class="headerlink" title="3. Idea构建Maven Java Web工程"></a>3. Idea构建Maven Java Web工程</h3><ol><li> 手动创建</li></ol><p>    1. 创建一个maven的javase工程</p><p>       <img src="/image/image-20231021150134082.png" alt="image-20231021150134082"></p><p>    2. 修改pom.xml文件打包方式</p><p>       修改位置：项目下&#x2F;pom.xml</p><p>       <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven_web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>       <span class="hljs-comment">&lt;!-- 新增一列打包方式packaging --&gt;</span><br><br>       <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><p>    3. 设置<strong>web资源路径</strong>和<strong>web.xml路径</strong></p><p>       点击File–&gt;Project Structure</p><p>       <img src="/image/image-20231021151040531.png" alt="image-20231021151040531"></p><p>       <img src="/image/image-20231021151627161.png" alt="image-20231021151627161"></p><p>       <img src="/image/image-20231021151753318.png" alt="image-20231021151753318"></p><p>    4. 刷新和校验</p><p>       <img src="/image/image-20231021152310802.png" alt="image-20231021152310802"></p><p>       <img src="/image/image-20231021151921943.png" alt="image-20231021151921943"></p><ol start="2"><li> 插件创建</li></ol><p>    1.  安装插件JBLJavaToWeb</p><p>        file &#x2F; settings &#x2F; plugins &#x2F; marketplace</p><p>        <img src="/image/image_cHUU_rABB6.png"></p><p>    2.  创建一个javasemaven工程</p><p>    3.  右键、使用插件快速补全web项目</p><p>        <img src="/image/image_ZAPkM7VLgJ.png"></p><h3 id="4-Maven工程项目结构说明"><a href="#4-Maven工程项目结构说明" class="headerlink" title="4. Maven工程项目结构说明"></a>4. Maven工程项目结构说明</h3><p>Maven 是一个强大的构建工具，它提供一种标准化的项目结构，可以帮助开发者更容易地管理项目的依赖、构建、测试和发布等任务。以下是 Maven Web 程序的文件结构及每个文件的作用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>|-- pom.xml                               # Maven 项目管理文件<br><br>|-- src<br><br>    |-- main                              # 项目主要代码<br><br>    |   |-- java                          # Java 源代码目录<br><br>    |   |   `-- com/example/myapp         # 开发者代码主目录<br><br>    |   |       |-- controller            # 存放 Controller 层代码的目录<br><br>    |   |       |-- service               # 存放 Service 层代码的目录<br><br>    |   |       |-- dao                   # 存放 DAO 层代码的目录<br><br>    |   |       `-- model                 # 存放数据模型的目录<br><br>    |   |-- resources                     # 资源目录，存放配置文件、静态资源等<br><br>    |   |   |-- log4j.properties          # 日志配置文件<br><br>    |   |   |-- spring-mybatis.xml        # Spring Mybatis 配置文件<br><br>    |   |   `-- static                    # 存放静态资源的目录<br><br>    |   |       |-- css                   # 存放 CSS 文件的目录<br><br>    |   |       |-- js                    # 存放 JavaScript 文件的目录<br><br>    |   |       `-- images                # 存放图片资源的目录<br><br>    |   `-- webapp                        # 存放 WEB 相关配置和资源<br><br>    |       |-- WEB-INF                   # 存放 WEB 应用配置文件<br><br>    |       |   |-- web.xml               # Web 应用的部署描述文件<br><br>    |       |   `-- classes               # 存放编译后的 class 文件<br><br>    |       `-- index.html                # Web 应用入口页面<br><br>    `-- test                              # 项目测试代码<br><br>        |-- java                          # 单元测试目录<br><br>        `-- resources                     # 测试资源目录<br><br></code></pre></td></tr></table></figure><ul><li><p>  pom.xml：Maven 项目管理文件，用于描述项目的依赖和构建配置等信息。</p></li><li><p>  src&#x2F;main&#x2F;java：存放项目的 Java 源代码。</p></li><li><p>  src&#x2F;main&#x2F;resources：存放项目的资源文件，如配置文件、静态资源等。</p></li><li><p>  src&#x2F;main&#x2F;webapp&#x2F;WEB-INF：存放 Web 应用的配置文件。</p></li><li><p>  src&#x2F;main&#x2F;webapp&#x2F;index.jsp：Web 应用的入口页面。</p></li><li><p>  src&#x2F;test&#x2F;java：存放项目的测试代码。</p></li><li><p>  src&#x2F;test&#x2F;resources：存放测试相关的资源文件，如测试配置文件等。</p></li></ul><h2 id="四、基于IDEA进行Maven工程构建"><a href="#四、基于IDEA进行Maven工程构建" class="headerlink" title="四、基于IDEA进行Maven工程构建"></a>四、基于IDEA进行Maven工程构建</h2><h3 id="1-构建概念和构建过程"><a href="#1-构建概念和构建过程" class="headerlink" title="1. 构建概念和构建过程"></a>1. 构建概念和构建过程</h3><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。</p><p>项目构建是软件开发过程中至关重要的一部分，它能够大大提高软件开发效率，使得开发人员能够更加专注于应用程序的开发和维护，而不必关心应用程序的构建细节。</p><p>同时，项目构建还能够将多个开发人员的代码汇合到一起，并能够自动化项目的构建和部署，大大降低了项目的出错风险和提高开发效率。常见的构建工具包括 Maven、Gradle、Ant 等。</p><p><img src="/image/image_REm5kk7DnX.png"></p><h3 id="2-命令方式项目构建"><a href="#2-命令方式项目构建" class="headerlink" title="2. 命令方式项目构建"></a>2. 命令方式项目构建</h3><p>| 命令        | 描述                        |</p><p>| ———– | ————————— |</p><p>| mvn compile | 编译项目，生成target文件    |</p><p>| mvn package | 打包项目，生成jar或war文件  |</p><p>| mvn clean   | 清理编译或打包后的项目结构  |</p><p>| mvn install | 打包后上传到maven本地仓库   |</p><p>| mvn deploy  | 只打包，上传到maven私服仓库 |</p><p>| mvn site    | 生成站点                    |</p><p>| mvn test    | 执行测试源码                |</p><p>war包打包插件和jdk版本不匹配：pom.xml 添加以下代码即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>命令触发练习：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>mvn 命令 命令<br><br>  <br><br><span class="hljs-comment">#清理</span><br><br>mvn clean<br><br><span class="hljs-comment">#清理，并重新打包</span><br><br>mvn clean package<br><br><span class="hljs-comment">#执行测试代码</span><br><br>mvn <span class="hljs-built_in">test</span><br><br></code></pre></td></tr></table></figure><h3 id="3-可视化方式项目构建"><a href="#3-可视化方式项目构建" class="headerlink" title="3. 可视化方式项目构建"></a>3. 可视化方式项目构建</h3><p><img src="/image/image-20231021153444864.png" alt="image-20231021153444864"></p><p>注意：打包（package）和安装（install）的区别是什么</p><p>打包是将工程打成jar或war文件，保存在target目录下</p><p>安装是将当前工程所生成的jar或war文件，安装到本地仓库，会按照坐标保存到指定位置</p><h3 id="4-构建插件、命令、生命周期命令之间关系"><a href="#4-构建插件、命令、生命周期命令之间关系" class="headerlink" title="4. 构建插件、命令、生命周期命令之间关系"></a>4. 构建插件、命令、生命周期命令之间关系</h3><ul><li>  <strong>构建生命周期</strong></li></ul><p>    我们发现一个情况！当我们执行package命令也会自动执行compile命令！</p><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    [INFO] --------------------------------[ jar ]---------------------------------<br><br>    [INFO]<br><br>    [INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ mybatis-base-curd ---<br><br>    [INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ mybatis-base-curd ---<br><br>    [INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ mybatis-base-curd ---<br><br>    [INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ mybatis-base-curd ---<br><br>    [INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ mybatis-base-curd ---<br><br>    [INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ mybatis-base-curd ---<br><br>    [INFO] Building jar: D:\javaprojects\backend-engineering\part03-mybatis\mybatis-base-curd\target\mybatis-base-curd-1.0-SNAPSHOT.jar<br><br>    [INFO] ------------------------------------------------------------------------<br><br>    [INFO] BUILD SUCCESS<br><br>    [INFO] ------------------------------------------------------------------------<br><br>    [INFO] Total time:  5.013 s<br><br>    [INFO] Finished at: 2023-06-05T10:03:47+08:00<br><br>    [INFO] ------------------------------------------------------------------------<br><br></code></pre></td></tr></table></figure></p><p>    这种行为就是因为构建生命周期产生的！构建生命周期可以理解成是一组固定构建命令的有序集合，触发周期后的命令，会自动触发周期前的命令！！！</p><p>    <strong>构建周期作用：会简化构建过程</strong></p><p>    例如：项目打包   mvn clean package即可。&amp;#x20;</p><p>    主要两个构建生命周期：</p><p>    -   清理周期：主要是对项目编译生成文件进行清理</p><p>        包含命令：clean&amp;#x20;</p><ul><li>  默认周期：定义了真正构件时所需要执行的所有步骤，它是生命周期中最核心的部分</li></ul><p>        包含命令：compile -  test - package - install - deploy</p><ul><li>  <strong>插件、命令、周期三者关系（了解）</strong></li></ul><p>    周期→包含若干命令→包含若干插件</p><p>    使用周期命令构建，简化构建过程！</p><p>    最终进行构建的是插件！</p><h2 id="五、基于IDEA-进行Maven依赖管理"><a href="#五、基于IDEA-进行Maven依赖管理" class="headerlink" title="五、基于IDEA 进行Maven依赖管理"></a>五、基于IDEA 进行Maven依赖管理</h2><h3 id="1-依赖管理概念"><a href="#1-依赖管理概念" class="headerlink" title="1. 依赖管理概念"></a>1. 依赖管理概念</h3><p>Maven 依赖管理是 Maven 软件中最重要的功能之一。Maven 的依赖管理能够帮助开发人员自动解决软件包依赖问题，使得开发人员能够轻松地将其他开发人员开发的模块或第三方框架集成到自己的应用程序或模块中，避免出现版本冲突和依赖缺失等问题。</p><p>我们通过定义 POM 文件，Maven 能够自动解析项目的依赖关系，并通过 Maven <strong>仓库自动</strong>下载和管理依赖，从而避免了手动下载和管理依赖的繁琐工作和可能引发的版本冲突问题。</p><p>总之，Maven 的依赖管理是 Maven 软件的一个核心功能之一，使得软件包依赖的管理和使用更加智能和方便，简化了开发过程中的工作，并提高了软件质量和可维护性。</p><h3 id="2-Maven工程核心信息配置和解读（GAVP）"><a href="#2-Maven工程核心信息配置和解读（GAVP）" class="headerlink" title="2. Maven工程核心信息配置和解读（GAVP）"></a>2. Maven工程核心信息配置和解读（GAVP）</h3><p>位置：pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!-- 模型版本 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.companyname.project-group<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>project<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 版本号 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>  <br><br><span class="hljs-comment">&lt;!--打包方式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    默认：jar</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    jar指的是普通的java项目打包方式！ 项目打成jar包！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    war指的是web项目打包方式！项目打成war包！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    pom不会讲项目打包！这个项目作为父工程，被其他工程聚合或者继承！后面会讲解两个概念</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar/pom/war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="3-Maven工程依赖管理配置"><a href="#3-Maven工程依赖管理配置" class="headerlink" title="3. Maven工程依赖管理配置"></a>3. Maven工程依赖管理配置</h3><p>位置：pom.xml</p><p>依赖管理和依赖添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   通过编写依赖jar包的gav必要属性，引入第三方依赖！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   scope属性是可选的，可以指定依赖生效范围！</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   依赖信息查询方式：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      1. maven仓库信息官网 https://mvnrepository.com/</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      2. mavensearch插件搜索</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 引入具体的依赖包 --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 依赖范围 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>依赖版本统一提取和维护</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!--声明版本--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--命名随便,内部制定版本号即可！--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 也可以通过 maven规定的固定的key，配置maven的参数！如下配置编码格式！--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--引用properties声明版本 --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><font color="#ff0000"><font color="#ff0000">### 4. 依赖范围</font></font></p><p>通过设置坐标的依赖范围(scope)，可以设置 对应jar包的作用范围：编译环境、测试环境、运行环境</p><p>| 依赖范围     | 描述                                                         |</p><p>| ———— | ———————————————————— |</p><p>| <strong>compile</strong>  | 编译依赖范围，scope 元素的缺省值。使用此依赖范围的 Maven 依赖，对于三种 classpath 均有效，即该 Maven 依赖在上述三种 classpath 均会被引入。例如，log4j 在编译、测试、运行过程都是必须的。 |</p><p>| <strong>test</strong>     | 测试依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath 有效。例如，Junit 依赖只有在测试阶段才需要。 |</p><p>| <strong>provided</strong> | 已提供依赖范围。使用此依赖范围的 Maven 依赖，只对编译 classpath 和测试 classpath 有效。例如，servlet-api 依赖对于编译、测试阶段而言是需要的，但是运行阶段，由于外部容器已经提供，故不需要 Maven 重复引入该依赖。 |</p><p>| runtime      | 运行时依赖范围。使用此依赖范围的 Maven 依赖，只对测试 classpath、运行 classpath 有效。例如，JDBC 驱动实现依赖，其在编译时只需 JDK 提供的 JDBC 接口即可，只有测试、运行阶段才需要实现了 JDBC 接口的驱动。 |</p><p>| system       | 系统依赖范围，其效果与 provided 的依赖范围一致。其用于添加非 Maven 仓库的本地依赖，通过依赖元素 dependency 中的 systemPath 元素指定本地依赖的路径。鉴于使用其会导致项目的可移植性降低，一般不推荐使用。 |</p><p>| import       | 导入依赖范围，该依赖范围只能与 dependencyManagement 元素配合使用，其功能是将目标 pom.xml 文件中 dependencyManagement 的配置导入合并到当前 pom.xml 的 dependencyManagement 中。 |</p><h3 id="5-Maven工程依赖下载失败错误解决（重点）"><a href="#5-Maven工程依赖下载失败错误解决（重点）" class="headerlink" title="5. Maven工程依赖下载失败错误解决（重点）"></a>5. Maven工程依赖下载失败错误解决（重点）</h3><p>在使用 Maven 构建项目时，可能会发生依赖项下载错误的情况，主要原因有以下几种：</p><ol><li><p> 下载依赖时出现网络故障或仓库服务器宕机等原因，导致无法连接至 Maven 仓库，从而无法下载依赖。</p></li><li><p> 依赖项的版本号或配置文件中的版本号错误，或者依赖项没有正确定义，导致 Maven 下载的依赖项与实际需要的不一致，从而引发错误。</p></li><li><p> 本地 Maven 仓库或缓存被污染或损坏，导致 Maven 无法正确地使用现有的依赖项。</p></li></ol><p>解决方案：</p><ol><li><p> 检查网络连接和 Maven 仓库服务器状态。</p></li><li><p> 确保依赖项的版本号与项目对应的版本号匹配，并检查 POM 文件中的依赖项是否正确。</p></li><li><p> 清除本地 Maven 仓库缓存（lastUpdated 文件），因为只要存在lastupdated缓存文件，刷新也不会重新下载。本地仓库中，根据依赖的gav属性依次向下查找文件夹，最终删除内部的文件，刷新重新下载即可！</p></li></ol><p>    例如： pom.xml依赖</p><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><p>    文件：</p><p>    <img src="/image/image_m3iQtBLARz.png"></p><ol start="4"><li>或者可以将清除<strong>lastUpdated文件</strong>的操作写在一个脚本文件中，手动创建文件”clearLastUpdated.bat”，名字任意，但是后缀必须是bat，将以下内容复制到文件中</li></ol><p>   <figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs bat"><br>   <span class="hljs-built_in">cls</span><br><br>   @<span class="hljs-built_in">ECHO</span> OFF<br><br>   <span class="hljs-built_in">SET</span> CLEAR_PATH=D:<br><br>   <span class="hljs-built_in">SET</span> CLEAR_DIR=D:\maven-repository(本地仓库路径)<br><br>   <span class="hljs-built_in">color</span> <span class="hljs-number">0</span>a<br><br>   <span class="hljs-built_in">TITLE</span> ClearLastUpdated <span class="hljs-keyword">For</span> Windows<br><br>   <span class="hljs-keyword">GOTO</span> MENU<br><br>   :MENU<br><br>   <span class="hljs-built_in">CLS</span><br><br>   <span class="hljs-built_in">ECHO</span>.<br><br>   <span class="hljs-built_in">ECHO</span>. * * * *  ClearLastUpdated <span class="hljs-keyword">For</span> Windows  * * * *<br><br>   <span class="hljs-built_in">ECHO</span>. * *<br><br>   <span class="hljs-built_in">ECHO</span>. * <span class="hljs-number">1</span> 清理*.lastUpdated *<br><br>   <span class="hljs-built_in">ECHO</span>. * *<br><br>   <span class="hljs-built_in">ECHO</span>. * <span class="hljs-number">2</span> 查看*.lastUpdated *<br><br>   <span class="hljs-built_in">ECHO</span>. * *<br><br>   <span class="hljs-built_in">ECHO</span>. * <span class="hljs-number">3</span> 退 出 *<br><br>   <span class="hljs-built_in">ECHO</span>. * *<br><br>   <span class="hljs-built_in">ECHO</span>. * * * * * * * * * * * * * * * * * * * * * * * *<br><br>   <span class="hljs-built_in">ECHO</span>.<br><br>   <span class="hljs-built_in">ECHO</span>.请输入选择项目的序号：<br><br>   <span class="hljs-built_in">set</span> /p ID=<br><br>   <span class="hljs-keyword">IF</span> &quot;<span class="hljs-variable">%id%</span>&quot;==&quot;<span class="hljs-number">1</span>&quot; <span class="hljs-keyword">GOTO</span> cmd1<br><br>   <span class="hljs-keyword">IF</span> &quot;<span class="hljs-variable">%id%</span>&quot;==&quot;<span class="hljs-number">2</span>&quot; <span class="hljs-keyword">GOTO</span> cmd2<br><br>   <span class="hljs-keyword">IF</span> &quot;<span class="hljs-variable">%id%</span>&quot;==&quot;<span class="hljs-number">3</span>&quot; <span class="hljs-keyword">EXIT</span><br><br>   <span class="hljs-built_in">PAUSE</span><br><br>   :cmd1<br><br>   <span class="hljs-built_in">ECHO</span>. 开始清理<br><br>   <span class="hljs-variable">%CLEAR_PATH%</span><br><br>   <span class="hljs-built_in">cd</span> <span class="hljs-variable">%CLEAR_DIR%</span><br><br>   <span class="hljs-keyword">for</span> /r <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (*.lastUpdated) <span class="hljs-keyword">do</span> <span class="hljs-built_in">del</span> <span class="hljs-variable">%%i</span><br><br>   <span class="hljs-built_in">ECHO</span>.OK<br><br>   <span class="hljs-built_in">PAUSE</span><br><br>   <span class="hljs-keyword">GOTO</span> MENU<br><br>   :cmd2<br><br>   <span class="hljs-built_in">ECHO</span>. 查看*.lastUpdated文件<br><br>   <span class="hljs-variable">%CLEAR_PATH%</span><br><br>   <span class="hljs-built_in">cd</span> <span class="hljs-variable">%CLEAR_DIR%</span><br><br>   <span class="hljs-keyword">for</span> /r <span class="hljs-variable">%%i</span> <span class="hljs-keyword">in</span> (*.lastUpdated) <span class="hljs-keyword">do</span> <span class="hljs-built_in">echo</span> <span class="hljs-variable">%%i</span><br><br>   <span class="hljs-built_in">ECHO</span>.OK<br><br>   <span class="hljs-built_in">PAUSE</span><br><br>   <span class="hljs-keyword">GOTO</span> MENU<br><br></code></pre></td></tr></table></figure></p><p>   <img src="/image/image-20231021161615994.png" alt="image-20231021161615994"></p><h3 id="6-Maven工程Build构建配置"><a href="#6-Maven工程Build构建配置" class="headerlink" title="6. Maven工程Build构建配置"></a>6. Maven工程Build构建配置</h3><p>项目构建是指将源代码、依赖库和资源文件等转换成可执行或可部署的应用程序的过程，在这个过程中包括编译源代码、链接依赖库、打包和部署等多个步骤。</p><p>默认情况下，构建不需要额外配置，都有对应的缺省配置。当然了，我们也可以在pom.xml定制一些配置，来修改默认构建的行为和产物！</p><p>例如：</p><ol><li><p> 指定构建打包文件的名称，非默认名称</p></li><li><p> 制定构建打包时，指定包含文件格式和排除文件</p></li><li><p> 打包插件版本过低，配置更高版本插件</p></li></ol><p>构建配置是在pom.xml &#x2F; build标签中指定！</p><p><strong>指定打包命名</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!-- 默认的打包名称：artifactid+verson.打包方式 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>定义打包名称<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>  <br><br></code></pre></td></tr></table></figure><p><strong>指定打包文件</strong></p><p>如果在java文件夹中添加java类，会自动打包编译到classes文件夹下！</p><p>但是在java文件夹中添加xml文件，默认不会被打包！</p><p>默认情况下，按照maven工程结构放置的文件会默认被编译和打包！</p><p>除此之外、我们可以使用resources标签，指定要打包资源的文件夹要把哪些静态资源打包到 classes根目录下！</p><p>应用场景：mybatis中有时会将用于编写SQL语句的映射文件和mapper接口都写在src&#x2F;main&#x2F;java下的某个包中，此时映射文件就不会被打包，如何解决</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置要打包的资源位置--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!--设置资源所在目录--&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br><br>                <span class="hljs-comment">&lt;!--设置包含的资源类型--&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>配置依赖插件</strong></p><p>dependencies标签下引入开发需要的jar包！我们可以在build&#x2F;plugins&#x2F;plugin标签引入插件！</p><p>常用的插件：修改jdk版本、tomcat插件、mybatis分页插件、mybatis逆向工程插件等等！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- java编译插件，配jdk的编译版本 --&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- tomcat插件 --&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>         <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8090<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">uriEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">uriEncoding</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span>tomcat7<span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><font color="#ff0000">## 六、Maven依赖传递和依赖冲突</font></p><h3 id="1-Maven依赖传递特性"><a href="#1-Maven依赖传递特性" class="headerlink" title="1. Maven依赖传递特性"></a>1. Maven依赖传递特性</h3><p><strong>概念</strong></p><p>假如有Maven项目A，项目B依赖A，项目C依赖B。那么我们可以说 C依赖A。也就是说，依赖的关系为：C—&gt;B—&gt;A， 那么我们执行项目C时，会自动把B、A都下载导入到C项目的jar包文件夹中，这就是依赖的传递性。</p><p><strong>作用</strong></p><ul><li><p>  简化依赖导入过程</p></li><li><p>  确保依赖版本正确</p></li></ul><p><strong>传递的原则</strong></p><p>在 A 依赖 B，B 依赖 C 的前提下，C 是否能够传递到 A，取决于 B 依赖 C 时使用的依赖范围以及配置</p><ul><li><p>B 依赖 C 时使用 compile 范围：可以传递</p></li><li><p>B 依赖 C 时使用 test 或 provided 范围：不能传递，所以需要这样的 jar 包时，就必须在需要的地方明确配置依赖才可以。</p></li><li><p>B 依赖 C 时，若配置了以下标签，则不能传递</p></li></ul><p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.15<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><p><strong>依赖传递终止</strong></p><ul><li><p>  非compile范围进行依赖传递</p></li><li><p>  使用optional配置终止传递</p></li><li><p>  依赖冲突（传递的依赖已经存在）</p></li></ul><p><strong>案例：导入jackson依赖</strong></p><p>分析：jackson需要三个依赖</p><p><img src="/image/image_9ViibmeAvU.png"></p><p>依赖传递关系：data-bind中，依赖其他两个依赖</p><p><img src="/image/image_Wl0Lsj_BLk.png"></p><p>最佳导入：直接可以导入data-bind，自动依赖传递需要的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br></code></pre></td></tr></table></figure><h3 id="2-Maven依赖冲突特性"><a href="#2-Maven依赖冲突特性" class="headerlink" title="2. Maven依赖冲突特性"></a>2. Maven依赖冲突特性</h3><p>当直接引用或者间接引用出现了相同的jar包! 这时呢，一个项目就会出现相同的重复jar包，这就算作冲突！依赖冲突避免出现重复依赖，并且终止依赖传递！</p><p><img src="/image/image_km7_szBRUw.png"></p><p>maven自动解决依赖冲突问题能力，会按照自己的原则，进行重复依赖选择。同时也提供了手动解决的冲突的方式，不过不推荐！</p><p><strong>解决依赖冲突（如何选择重复依赖）方式：</strong></p><ol><li> 自动选择原则</li></ol><p>    -   短路优先原则（第一原则）</p><p>        A—&gt;B—&gt;C—&gt;D—&gt;E—&gt;X(version 0.0.1)</p><p>        A—&gt;F—&gt;X(version 0.0.2)</p><p>        则A依赖于X(version 0.0.2)。</p><p>    -   依赖路径长度相同情况下，则“先声明优先”（第二原则）</p><p>        A—&gt;E—&gt;X(version 0.0.1)</p><p>        A—&gt;F—&gt;X(version 0.0.2)</p><p>        在&lt;depencies&gt;&lt;&#x2F;depencies&gt;中，先声明的，路径相同，会优先选择！</p><ol start="2"><li> 手动排除</li></ol><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro01-maven-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>      <span class="hljs-comment">&lt;!-- 使用excludes标签配置依赖的排除  --&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 在exclude标签中配置一个具体的排除 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br><br>          <span class="hljs-comment">&lt;!-- 指定要排除的依赖的坐标（不需要写version） --&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><ol start="3"><li> 小案例</li></ol><p>    伪代码如下：</p><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    前提：<br><br>       A 1.1 -&gt; B 1.1 -&gt; C 1.1<br><br>       F 2.2 -&gt; B 2.2<br><br>    pom声明：<br><br>       F 2.2<br><br>       A 1.1<br><br></code></pre></td></tr></table></figure></p><p>    请问最终会导入哪些依赖和对应版本？</p><h2 id="七、Maven工程继承和聚合关系"><a href="#七、Maven工程继承和聚合关系" class="headerlink" title="七、Maven工程继承和聚合关系"></a>七、Maven工程继承和聚合关系</h2><h3 id="1-Maven工程继承关系"><a href="#1-Maven工程继承关系" class="headerlink" title="1. Maven工程继承关系"></a>1. Maven工程继承关系</h3><ol><li> 继承概念</li></ol><p>    Maven 继承是指在 Maven 的项目中，让一个项目从另一个项目中继承配置信息的机制。继承可以让我们在多个项目中共享同一配置信息，简化项目的管理和维护工作。</p><ol start="2"><li> 继承作用</li></ol><p>    在父工程中统一管理项目中的依赖信息。</p><p>    它的背景是：</p><p>    -   对一个比较大型的项目进行了模块拆分。</p><p>    -   一个 project 下面，创建了很多个 module。</p><p>    -   每一个 module 都需要配置自己的依赖信息。</p><p>    它背后的需求是：</p><p>    -   在每一个 module 中各自维护各自的依赖信息很容易发生出入，不易统一管理。</p><p>    -   使用同一个框架内的不同 jar 包，它们应该是同一个版本，所以整个项目中使用的框架版本需要统一。</p><p>    -   使用框架时所需要的 jar 包组合（或者说依赖信息组合）需要经过长期摸索和反复调试，最终确定一个可用组合。这个耗费很大精力总结出来的方案不应该在新的项目中重新摸索。</p><p>        通过在父工程中为整个项目维护依赖信息的组合既保证了整个项目使用规范、准确的 jar 包；又能够将以往的经验沉淀下来，节约时间和精力。</p><ol start="3"><li> 继承语法</li></ol><p>    -   父工程</p><p>        <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro03-maven-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>          <span class="hljs-comment">&lt;!-- 当前工程作为父工程，它要去管理子工程，所以打包方式必须是 pom --&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><p>    -   子工程</p><p>        <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>        <span class="hljs-comment">&lt;!-- 使用parent标签指定当前工程的父工程 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><br>          <span class="hljs-comment">&lt;!-- 父工程的坐标 --&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro03-maven-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 子工程的坐标 --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 如果子工程坐标中的groupId和version与父工程一致，那么可以省略 --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- &lt;groupId&gt;com.atguigu.maven&lt;/groupId&gt; --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pro04-maven-module<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; --&gt;</span><br><br></code></pre></td></tr></table></figure></p><ol start="4"><li> 父工程依赖统一管理</li></ol><p>    -   父工程声明版本</p><p>        <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>        <span class="hljs-comment">&lt;!-- 使用dependencyManagement标签配置对依赖的管理 --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 被管理的依赖并没有真正被引入到工程 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>              <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><p>    -   子工程引用版本</p><p>        <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>        <span class="hljs-comment">&lt;!-- 子工程引用父工程中的依赖信息时，可以把版本号去掉。  --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 把版本号去掉就表示子工程中这个依赖的版本由父工程决定。 --&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 具体来说是由父工程的dependencyManagement来决定。 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-expression<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><h3 id="2-Maven工程聚合关系"><a href="#2-Maven工程聚合关系" class="headerlink" title="2. Maven工程聚合关系"></a>2. Maven工程聚合关系</h3><ol><li> 聚合概念</li></ol><p>    Maven 聚合是指将多个项目组织到一个父级项目中，以便一起构建和管理的机制。聚合可以帮助我们更好地管理一组相关的子项目，同时简化它们的构建和部署过程。</p><ol start="2"><li> 聚合作用</li></ol><p>    1.  管理多个子项目：通过聚合，可以将多个子项目组织在一起，方便管理和维护。</p><p>    2.  构建和发布一组相关的项目：通过聚合，可以在一个命令中构建和发布多个相关的项目，简化了部署和维护工作。</p><p>    3.  优化构建顺序：通过聚合，可以对多个项目进行顺序控制，避免出现构建依赖混乱导致构建失败的情况。</p><p>    4.  统一管理依赖项：通过聚合，可以在父项目中管理公共依赖项和插件，避免重复定义。</p><ol start="3"><li> 聚合语法</li></ol><p>    父项目中包含的子项目列表。</p><p>    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>parent-project<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>child-project1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>child-project2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p><ol start="4"><li> 聚合演示</li></ol><p>    通过触发父工程构建命令、引发所有子模块构建！产生反应堆！</p><h2 id="八、Maven私服"><a href="#八、Maven私服" class="headerlink" title="八、Maven私服"></a>八、Maven私服</h2><h3 id="1-Maven私服简介"><a href="#1-Maven私服简介" class="headerlink" title="1. Maven私服简介"></a>1. Maven私服简介</h3><p>①私服简介</p><p>Maven 私服是一种特殊的Maven远程仓库，它是架设在局域网内的仓库服务，用来代理位于外部的远程仓库（中央仓库、其他远程公共仓库）。</p><blockquote><p>当然也并不是说私服只能建立在局域网，也有很多公司会直接把私服部署到公网，具体还是得看公司业务的性质是否是保密的等等，因为局域网的话只能在公司用，部署到公网的话员工在家里也可以办公使用。</p></blockquote><p>建立了 Maven 私服后，当局域网内的用户需要某个构件时，会按照如下顺序进行请求和下载。</p><p>请求本地仓库，若本地仓库不存在所需构件，则跳转到第 2 步；</p><p>请求 Maven 私服，将所需构件下载到本地仓库，若私服中不存在所需构件，则跳转到第 3 步。</p><p>请求外部的远程仓库，将所需构件下载并缓存到 Maven 私服，若外部远程仓库不存在所需构件，则 Maven 直接报错。</p><p>此外，一些无法从外部仓库下载到的构件，也能从本地上传到私服供其他人使用。</p><p><img src="/image/image-20231021164631791.png" alt="image-20231021164631791"></p><p>②Maven私服的优势</p><ol><li>节省外网带宽</li></ol><p>   消除对外部远程仓库的大量重复请求（会消耗很大量的带宽），降低外网带宽压力。</p><ol start="2"><li>下载速度更快</li></ol><p>   Maven私服位于局域网内，从私服下载构建更快更稳定。</p><ol start="3"><li>便于部署第三方构件</li></ol><p>   有些构件无法从任何一个远程仓库中获得（如：公司或组织内部的私有构件、Oracle的JDBC驱动等），建立私服之后，就可以将这些构件部署到私服中，供内部Maven项目使用。</p><ol start="4"><li>提高项目的稳定性，增强对项目的控制</li></ol><p>   如果不建立私服，那么Maven项目的构件就高度依赖外部的远程仓库，若外部网络不稳定，则项目的构建过程也会变得不稳定。建立私服后，即使外部网络状况不佳甚至中断，只要私服中已经缓存了所需的构件，Maven也能够正常运行。私服软件（如：Nexus）提供了很多控制功能（如：权限管理、RELEASE&#x2F;SNAPSHOT版本控制等），可以对仓库进行一些更加高级的控制。</p><ol start="5"><li>降低中央仓库得负荷压力</li></ol><p>   由于私服会缓存中央仓库得构件，避免了很多对中央仓库的重复下载，降低了中央仓库的负荷。</p><p>③常见的Maven私服产品</p><ol><li><p>Apache的Archiva</p></li><li><p>JFrog的Artifactory</p></li><li><p>Sonatype的Nexus（[ˈneksəs]）（当前最流行、使用最广泛）</p></li></ol><h3 id="2-Nexus下载安装"><a href="#2-Nexus下载安装" class="headerlink" title="2. Nexus下载安装"></a>2. Nexus下载安装</h3><p>下载地址：<a href="https://help.sonatype.com/repomanager3/product-information/download">https://help.sonatype.com/repomanager3/product-information/download</a></p><p>解压，以管理员身份打开CMD，进入bin目录下，执行.&#x2F;nexus &#x2F;run命令启动</p><p>访问 Nexus 首页</p><p>首页地址：<a href="http://localhost:8081/%EF%BC%8C8081%E4%B8%BA%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E5%8F%B7">http://localhost:8081/，8081为默认端口号</a></p><p><img src="/image/img001.612496a3.png" alt="images"></p><h3 id="3-初始设置"><a href="#3-初始设置" class="headerlink" title="3. 初始设置"></a>3. 初始设置</h3><p><img src="/image/img002.e1ac8197.png" alt="images"></p><p><img src="/image/image-20231031171116756.png" alt="image-20231031171116756"></p><p>这里参考提示：</p><ul><li><p>用户名：admin</p></li><li><p>密码：查看 <strong>E:\Server\nexus-3.61.0-02-win64\sonatype-work\nexus3\admin.password</strong> 文件</p></li></ul><p><img src="/image/image-20231031171242874.png" alt="image-20231031171242874"></p><p>继续执行初始化：</p><p><img src="/image/img005.4b81e5ab.png" alt="images"></p><p><img src="/image/img006.43ebb0ac.png" alt="images"></p><p>匿名登录，启用还是禁用？由于启用匿名登录后，后续操作比较简单，这里我们演示禁用匿名登录的操作：</p><p><img src="/image/image-20231031171607378.png" alt="image-20231031171607378"></p><p>初始化完毕：</p><p><img src="/image/image-20231031171708085.png" alt="image-20231031171708085"></p><h3 id="4-Nexus上的各种仓库"><a href="#4-Nexus上的各种仓库" class="headerlink" title="4. Nexus上的各种仓库"></a>4. Nexus上的各种仓库</h3><p><img src="/image/img009.7f737ed7.png" alt="images"></p><p>| 仓库类型 | 说明                                           |</p><p>| ——– | ———————————————- |</p><p>| proxy    | 某个远程仓库的代理                             |</p><p>| group    | 存放：通过 Nexus 获取的第三方 jar 包           |</p><p>| hosted   | 存放：本团队其他开发人员部署到 Nexus 的 jar 包 |</p><p>| 仓库名称        | 说明                                                         |</p><p>| ————— | ———————————————————— |</p><p>| maven-central   | Nexus 对 Maven 中央仓库的代理                                |</p><p>| maven-public    | Nexus 默认创建，供开发人员下载使用的组仓库                   |</p><p>| maven-releases  | Nexus 默认创建，供开发人员部署自己 jar 包的宿主仓库 要求 releases 版本 |</p><p>| maven-snapshots | Nexus 默认创建，供开发人员部署自己 jar 包的宿主仓库 要求 snapshots 版本 |</p><p>初始状态下，这几个仓库都没有内容：</p><p><img src="/image/img010.e3573d0b.png" alt="images"></p><h3 id="5-通过-Nexus-下载-jar-包"><a href="#5-通过-Nexus-下载-jar-包" class="headerlink" title="5. 通过 Nexus 下载 jar 包"></a>5. 通过 Nexus 下载 jar 包</h3><p>修改本地maven的核心配置文件settings.xml，设置新的本地仓库地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-comment">&lt;!-- 配置一个新的 Maven 本地仓库 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:/maven-repository-new<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>把我们原来配置阿里云仓库地址的 mirror 标签改成下面这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-mine<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus mine<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>这里的 url 标签是这么来的：</p><p><img src="/image/img012.5a3b1f11.png" alt="images"></p><p><img src="/image/image-20231031172137288.png" alt="image-20231031172137288"></p><p>把上图中看到的地址复制出来即可。如果我们在前面允许了匿名访问，到这里就够了。但如果我们禁用了匿名访问，那么接下来我们还要继续配置 settings.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-mine<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>这里需要<strong>格外注意</strong>：server 标签内的 id 标签值必须和 mirror 标签中的 id 值一样。</p><p>找一个用到框架的 Maven 工程，执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>mvn clean compile<br><br></code></pre></td></tr></table></figure><p>下载过程日志：</p><blockquote><p>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom">http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom</a></p></blockquote><blockquote><p>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom">http://localhost:8081/repository/maven-public/com/jayway/jsonpath/json-path/2.4.0/json-path-2.4.0.pom</a> (2.6 kB at 110 kB&#x2F;s)</p></blockquote><blockquote><p>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom</a></p></blockquote><blockquote><p>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/json-smart/2.3/json-smart-2.3.pom</a> (9.0 kB at 376 kB&#x2F;s)</p></blockquote><blockquote><p>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom</a></p></blockquote><blockquote><p>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom">http://localhost:8081/repository/maven-public/net/minidev/minidev-parent/2.3/minidev-parent-2.3.pom</a> (8.5 kB at 404 kB&#x2F;s)</p></blockquote><blockquote><p>Downloading from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom">http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom</a></p></blockquote><blockquote><p>Downloaded from nexus-mine: <a href="http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom">http://localhost:8081/repository/maven-public/net/minidev/accessors-smart/1.2/accessors-smart-1.2.pom</a> (12 kB at 463 kB&#x2F;s)</p></blockquote><p>下载后，Nexus 服务器上就有了 jar 包：</p><p><img src="/image/img014.cc0e87c3.png" alt="images"></p><p>若下载速度太慢，可以设置私服中中央仓库的地址为阿里云仓库地址</p><p><img src="/image/image-20231031175035345.png" alt="image-20231031175035345"></p><p>修改为：<a href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></p><p><img src="/image/image-20231031175134745.png" alt="image-20231031175134745"></p><h3 id="6-将-jar-包部署到-Nexus"><a href="#6-将-jar-包部署到-Nexus" class="headerlink" title="6. 将 jar 包部署到 Nexus"></a>6. 将 jar 包部署到 Nexus</h3><p>maven工程中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-mine<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>注意：这里 snapshotRepository 的 id 标签必须和 settings.xml 中指定的 mirror 标签的 id 属性一致。</p><p>执行部署命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><br>mvn deploy<br><br></code></pre></td></tr></table></figure><blockquote><p>Uploading to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml</a></p></blockquote><blockquote><p>Uploaded to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/1.0-SNAPSHOT/maven-metadata.xml</a> (786 B at 19 kB&#x2F;s)</p></blockquote><blockquote><p>Uploading to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml</a></p></blockquote><blockquote><p>Uploaded to nexus-mine: <a href="http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml">http://localhost:8081/repository/maven-snapshots/com/atguigu/demo/demo07-redis-data-provider/maven-metadata.xml</a> (300 B at 6.5 kB&#x2F;s)</p></blockquote><blockquote><p>[INFO] ————————————————————————</p></blockquote><blockquote><p>[INFO] Reactor Summary:</p></blockquote><blockquote><p>[INFO]</p></blockquote><blockquote><p>[INFO] demo-imperial-court-ms-show 1.0-SNAPSHOT ……….. SUCCESS [ 1.875 s]</p></blockquote><blockquote><p>[INFO] demo09-base-entity …………………………… SUCCESS [ 21.883 s]</p></blockquote><blockquote><p>[INFO] demo10-base-util …………………………….. SUCCESS [ 0.324 s]</p></blockquote><blockquote><p>[INFO] demo08-base-api ……………………………… SUCCESS [ 1.171 s]</p></blockquote><blockquote><p>[INFO] demo01-imperial-court-gateway …………………. SUCCESS [ 0.403 s]</p></blockquote><blockquote><p>[INFO] demo02-user-auth-center ………………………. SUCCESS [ 2.932 s]</p></blockquote><blockquote><p>[INFO] demo03-emp-manager-center …………………….. SUCCESS [ 0.312 s]</p></blockquote><blockquote><p>[INFO] demo04-memorials-manager-center ……………….. SUCCESS [ 0.362 s]</p></blockquote><blockquote><p>[INFO] demo05-working-manager-center …………………. SUCCESS [ 0.371 s]</p></blockquote><blockquote><p>[INFO] demo06-mysql-data-provider ……………………. SUCCESS [ 6.779 s]</p></blockquote><blockquote><p>[INFO] demo07-redis-data-provider 1.0-SNAPSHOT ………… SUCCESS [ 0.273 s]</p></blockquote><p><img src="/image/img015.b413af9d.png" alt="images"></p><h3 id="7-引用别人部署的-jar-包"><a href="#7-引用别人部署的-jar-包" class="headerlink" title="7. 引用别人部署的 jar 包"></a>7. 引用别人部署的 jar 包</h3><p>maven工程中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-mine<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus-mine<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://localhost:8081/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="九、Maven综合案例"><a href="#九、Maven综合案例" class="headerlink" title="九、Maven综合案例"></a>九、Maven综合案例</h2><h3 id="1-项目需求和结构分析"><a href="#1-项目需求和结构分析" class="headerlink" title="1. 项目需求和结构分析"></a>1. 项目需求和结构分析</h3><p><img src="/image/image123.png" alt="img"></p><p>需求案例：搭建一个电商平台项目，该平台包括用户服务、订单服务、通用工具模块等。</p><p>项目架构：</p><ol><li>用户服务：负责处理用户相关的逻辑，例如用户信息的管理、用户注册、登录等。</li></ol><p>   - spring-context 6.0.6</p><p>   - spring-core 6.0.6</p><p>   - spring-beans 6.0.6</p><p>   - common-service</p><ol start="2"><li>订单服务：负责处理订单相关的逻辑，例如订单的创建、订单支付、退货、订单查看等。</li></ol><p>   - spring-context 6.0.6</p><p>   - spring-core 6.0.6</p><p>   - spring-beans 6.0.6</p><p>   - spring-security 6.0.6</p><p>   - common-service</p><ol start="3"><li>通用模块：负责存储其他服务需要通用工具类，其他服务依赖此模块。</li></ol><p>   - commons-io 2.11.0</p><p>   - junit 5.9.2</p><h3 id="2-项目搭建和统一构建"><a href="#2-项目搭建和统一构建" class="headerlink" title="2. 项目搭建和统一构建"></a>2. 项目搭建和统一构建</h3><h4 id="①父模块-micro-shop"><a href="#①父模块-micro-shop" class="headerlink" title="①父模块 (micro-shop)"></a>①父模块 (micro-shop)</h4><p>创建工程：</p><p><img src="/image/image-20231023112630117.png" alt="image-20231023112630117"></p><p>pom.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-shop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--知识点：父工程的打包方式为pom--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>6.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jackson.version</span>&gt;</span>2.15.0<span class="hljs-tag">&lt;/<span class="hljs-name">jackson.version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commons.version</span>&gt;</span>2.11.0<span class="hljs-tag">&lt;/<span class="hljs-name">commons.version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>5.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <br><br>    <span class="hljs-comment">&lt;!-- 依赖管理 --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>            <span class="hljs-comment">&lt;!-- spring-context会依赖传递core/beans --&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br>            <span class="hljs-comment">&lt;!-- jackson-databind会依赖传递core/annotations --&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jackson.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br>            <span class="hljs-comment">&lt;!-- commons-io --&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;commons.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br>            <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;junit.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br>  <br><br>    <span class="hljs-comment">&lt;!-- 统一更新子工程打包插件--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- jdk17 和 war包版本插件不匹配 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>可选操作：删除src目录</p><h4 id="②通用模块-common-service"><a href="#②通用模块-common-service" class="headerlink" title="②通用模块 (common-service)"></a>②通用模块 (common-service)</h4><p>创建工程：</p><p><img src="/image/image-20231023114531521.png" alt="image-20231023114531521"></p><p><img src="/image/image-20231023114649705.png" alt="image-20231023114649705"></p><p>pom.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-shop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>common-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--知识点：打包方式默认就是jar，因此可以省略--&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置spring-context，继承父工程版本，自动传递 core / beans --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置jackson-databind，继承父工程版本，自动传递 core / annotations --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置commons-io，继承父工程版本 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置junit，继承父工程版本 --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h4 id="③用户模块-user-service"><a href="#③用户模块-user-service" class="headerlink" title="③用户模块 (user-service)"></a>③用户模块 (user-service)</h4><p>创建工程：</p><p><img src="/image/image-20231023115404302.png" alt="image-20231023115404302"></p><p><img src="/image/image-20231023115707282.png" alt="image-20231023115707282"></p><p>pom.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-shop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>user-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- web工程打包方式为war --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>common-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>依赖传递结果：</p><p><img src="/image/image-20231023120621402.png" alt="image-20231023120621402"></p><h4 id="④订单模块-order-service"><a href="#④订单模块-order-service" class="headerlink" title="④订单模块 (order-service)"></a>④订单模块 (order-service)</h4><p>创建工程，并使用插件转为web工程：</p><p><img src="/image/image-20231023120733029.png" alt="image-20231023120733029"></p><p>pom.xml配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>micro-shop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>order-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- web工程打包方式为war --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>17<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 配置common-service，所需依赖会传递到当前工程（仅限compile范围） --&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.atguigu<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>common-service<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>此时，查看父工程的pom.xml，会发现其中已经自动聚合了子工程：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>common-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>user-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>order-service<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>Maven引用依赖默认为jar，如果引入pom类型的依赖需要显示指定<type>pom<type></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitmq 节点重新加入集群</title>
    <link href="/article/1b5d87d5.html"/>
    <url>/article/1b5d87d5.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li>节点清除rabbitmq配置（踢出的节点操作）</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">停止rabbitmq-server的服务<br>systemctl stop rabbitmq-server<br>rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/rabbitmq/</span>* <span class="hljs-regexp">/var/</span>log/*<br></code></pre></td></tr></table></figure><ul><li>拷贝正常节点 （从正常节点拷贝到需要踢出的节点操作）</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/rabbitmq/</span>.erlang.cookie 权限<span class="hljs-number">400</span><br>权限 rabbitmq rabbitmq<br></code></pre></td></tr></table></figure><ul><li>在集群正常节点将故障节点踢出（踢出的节点操作）</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">在新的rabbitmq集群主节点踢出<span class="hljs-symbol">rabbit@</span>controller7325节点<br>rabbitmqctl  -n <span class="hljs-symbol">rabbit@</span>controller7326  forget_cluster_node <span class="hljs-symbol">rabbit@</span>controller7325<br></code></pre></td></tr></table></figure><ul><li>重新加入到集群内（踢出的节点操作）</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">systemctl  <span class="hljs-keyword">start</span> rabbitmq-<span class="hljs-keyword">server</span><br>rabbitmqctl stop_app<br>rabbitmqctl <span class="hljs-keyword">reset</span><br>rabbitmqctl join_cluster &quot;rabbit@controller7326&quot;<br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><ul><li>完成后重新检查rabbitmq集群状态</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">rabbitmqctl cluster_status</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tonyenc php解密</title>
    <link href="/article/2c3e9697.html"/>
    <url>/article/2c3e9697.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /># 解密<p>拿到文件很晕，都是乱码，应该不是常规的混淆，大概率是通过so来解密，先找到php目录</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[root@acmepbx:<span class="hljs-regexp">/opt/</span>bin]<span class="hljs-comment">#find / -name php.ini</span><br><span class="hljs-regexp">/opt/</span>php<span class="hljs-regexp">/etc/</span>php.ini<br></code></pre></td></tr></table></figure><p>Shell</p><p>找到扩展配置目录  </p><p>tonyenc.ini这个文件很可疑<br>内容为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">extension</span><span class="hljs-operator">=</span>tonyenc.so<br></code></pre></td></tr></table></figure><p>Shell</p><p><a href="https://www.darkin.cn/usr/uploads/2023/04/163031832.png"></a><br>网上搜了一下这个so的文件名，直接搜到了加密项目<br><a href="https://github.com/lihancong/tonyenc">https://github.com/lihancong/tonyenc</a><br><a href="https://www.darkin.cn/usr/uploads/2023/04/293100129.png"></a><br>这个密钥很关键，我们可以在ida进行查找<br><a href="https://www.darkin.cn/usr/uploads/2023/04/141066593.png"></a><br>在解密之前我们需要确认github这个项目和目标so的逻辑是否相同，直接把正确的key修改，根据文档在Linux下编译替换原有的so，打开网页测试代码是否正常运行，或者可以调用enc方法加密同一个文件测试。<br>经过测试，我编译的so可以正常使用，这样的话直接用github的解密方法吧<br>解密逻辑比较简单，我们可以直接单独写个程序解密<br><a href="https://www.darkin.cn/usr/uploads/2023/04/3039153348.png"></a><br><a href="https://www.darkin.cn/usr/uploads/2023/04/3764255853.png"></a><br>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> tonyenc_header[] = &#123;<br>        <span class="hljs-number">0x16</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x4f</span>,<br>        <span class="hljs-number">0x68</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x36</span>,<br>        <span class="hljs-number">0x91</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x88</span>,<br>&#125;;<br><span class="hljs-type">char</span> tonyenc_key[] = &#123;<br>        <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x52</span>, <span class="hljs-number">0x00</span>,<br>        <span class="hljs-number">0x58</span>, <span class="hljs-number">0x9f</span>, <span class="hljs-number">0x6f</span>, <span class="hljs-number">0x93</span>,<br>        <span class="hljs-number">0x3e</span>, <span class="hljs-number">0x2e</span>, <span class="hljs-number">0x7a</span>, <span class="hljs-number">0xfa</span>,<br>        <span class="hljs-number">0xa6</span>, <span class="hljs-number">0x33</span>, <span class="hljs-number">0xf3</span>, <span class="hljs-number">0xb6</span>,<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">write_change_policy</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename, <span class="hljs-type">char</span>* buf_policy)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE* fp = <span class="hljs-literal">NULL</span>;<br>    fp = <span class="hljs-built_in">fopen</span>(filename, <span class="hljs-string">&quot;w+&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!fp) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fwrite</span>(buf_policy, <span class="hljs-number">1</span>, <span class="hljs-built_in">strlen</span>(buf_policy), fp) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">fclose</span>(fp);<br>    &#125;<br>    <span class="hljs-built_in">fclose</span>(fp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tonyenc_decode</span><span class="hljs-params">(<span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">size_t</span> i, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &amp; <span class="hljs-number">1</span>) &#123;<br>            p += tonyenc_key[p] + i;<br>            p %= <span class="hljs-built_in">sizeof</span>(tonyenc_key);<br>            <span class="hljs-type">char</span> t = tonyenc_key[p];<br>            data[i] = ~data[i] ^ t;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tonyenc_ext_fopen</span><span class="hljs-params">(FILE* fp, <span class="hljs-keyword">struct</span> stat* stat_buf,<span class="hljs-type">char</span>* outname)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span>* p_data;<br>    <span class="hljs-type">size_t</span> data_len;<br>    <span class="hljs-type">size_t</span> write_len;<br>    data_len = stat_buf-&gt;st_size - <span class="hljs-built_in">sizeof</span>(tonyenc_header);<br>    p_data = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(data_len);<br>    <span class="hljs-built_in">fseek</span>(fp, <span class="hljs-built_in">sizeof</span>(tonyenc_header), SEEK_SET);<br>    <span class="hljs-built_in">fread</span>(p_data, data_len, <span class="hljs-number">1</span>, fp);<br>    <span class="hljs-built_in">fclose</span>(fp);<br>    <span class="hljs-built_in">tonyenc_decode</span>(p_data, data_len);<br>    <span class="hljs-built_in">write_change_policy</span>(outname, p_data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_buf;<br>    <span class="hljs-type">int</span> data_len;<br>    <span class="hljs-type">char</span>* filename;<br>    FILE* fp;<br>    filename = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//printf(argv[1]);</span><br>    fp = <span class="hljs-built_in">fopen</span>(filename, <span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-built_in">fstat</span>(<span class="hljs-built_in">fileno</span>(fp), &amp;stat_buf);<br>    data_len = stat_buf.st_size;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;data_lenth:%d&quot;</span>, data_len);<br>    <span class="hljs-built_in">tonyenc_ext_fopen</span>(fp, &amp;stat_buf, <span class="hljs-built_in">strcat</span>(filename , <span class="hljs-string">&quot;.dec&quot;</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure><p>C</p><p>成功解密:<br><a href="https://www.darkin.cn/usr/uploads/2023/04/1202843109.png"></a><br>写了个python批量调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> codecs<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> frida<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">findfile</span>(<span class="hljs-params">target_dir, target_suffix=<span class="hljs-string">&quot;php&quot;</span></span>):<br>    find_res = []<br>    target_suffix_dot = <span class="hljs-string">&quot;.&quot;</span> + target_suffix<br>    walk_generator = os.walk(target_dir)<br>    <span class="hljs-keyword">for</span> root_path, dirs, files <span class="hljs-keyword">in</span> walk_generator:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) &lt; <span class="hljs-number">1</span>:<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>            file_name, suffix_name = os.path.splitext(file)<br>            <span class="hljs-keyword">if</span> target_suffix==<span class="hljs-string">&quot;all&quot;</span>:<br>                find_res.append(os.path.join(root_path, file))<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> suffix_name == target_suffix_dot:<br>                    find_res.append(os.path.join(root_path, file))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(find_res))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_hex</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(filename, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        file_hex = f.read().<span class="hljs-built_in">hex</span>()<br>    f.close()<br>    <span class="hljs-keyword">return</span> file_hex<br><br>rlist=[]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getfile</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> findfile(<span class="hljs-string">r&quot;J:\phpstudy_pro\WWW&quot;</span>):<br>        <span class="hljs-keyword">if</span> read_hex(i)[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>]==<span class="hljs-string">&quot;16886f&quot;</span>:<br>            rlist.append(i)<br>getfile()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> rlist:<br>    <span class="hljs-built_in">print</span>(i)<br>    os.system(<span class="hljs-string">&quot;dec.exe %s&quot;</span>%i)<br></code></pre></td></tr></table></figure><p>Python</p><p>全解开后破解授权验证就很简单了<br><a href="https://www.darkin.cn/usr/uploads/2023/04/712484247.png"></a></p><h1 id="重新加密"><a href="#重新加密" class="headerlink" title="重新加密"></a>重新加密</h1><p><a href="https://windows.php.net/downloads/releases/archives/">https://windows.php.net/downloads/releases/archives/</a><br><a href="https://www.darkin.cn/usr/uploads/2023/04/1180440772.png"></a></p><blockquote><p>转载<a href="https://www.leolei.cn/archives/20.html">https://www.leolei.cn/archives/20.html</a></p></blockquote><p>说明：7.2使用VC15编译，本文以PHP7.0.26举例 使用Visual Studio 2017</p><p>需要从 官网 下载 PHP7.0.26 的源代码包和已编译的 PHP 程序，再分别解压，得到两个目录(假设在 C 盘)：</p><p>C:\php-7.0.26-src</p><p>C:\php-7.0.26-nts-Win32-VC14-x64</p><p>如何编译</p><p>1）拿到要编译的代码，在 VS 2017 菜单中选择「文件」-「新建」-「从现有代码创建项目」，然后在弹出窗口中选择你要编译的代码，类型选择「动态库(dll)」。</p><p>2）此时 VS 2017 打开了项目，把工具栏中的「Debug」改为「Release」，「x86」改为「x64」，在菜单中选择「项目」-「属性」。然后在弹出窗口的左侧「常规」栏目下，「配置类型」选择为「动态库(.dll)」：</p><p>3）然后在左侧「C&#x2F;C++」-「常规」栏目下，「附加包含目录」中，加入：</p><p>C:\php-7.0.26-src<br>C:\php-7.0.26-src\main<br>C:\php-7.0.26-src\TSRM<br>C:\php-7.0.26-src\Zend</p><p>4）接着在左侧「C&#x2F;C++」-「预处理器」栏目下，「预处理器定义」中，加入：</p><p>ZEND_DEBUG&#x3D;0<br>PHP_EXTENSION<br>PHP_WIN32<br>ZEND_WIN32<br>HAVE_XXX&#x3D;1<br>COMPILE_DL_XXX<br>ZTS</p><p>注意，要把上面的 XXX 改为大写的扩展名 (如扩展叫 tonyenc 就把 XXX 改成 TONYENC)，否则 PHP 将无法识别扩展。ZTS用于告诉编译器开启线程安全（如果去掉就是不开启）。注意，线程安全的开启与否，取决于前面下载到的 C:\php-7.0.26-nts-Win32-VC14-x64，它如果启用了线程安全编译，这里就开启线程安全。</p><p>5）在左侧「链接器」-「输入」栏目下，「附加依赖项」中，加入：C:\php-7.0.26-nts-Win32-VC14-x64\dev\php7.lib，即前面下载得到的已编译的 PHP 程序。</p><p>6）点确定，然后菜单中选择「生成」-「生成解决方案」，恭喜你，编译器报错：无法打开包括文件 ..&#x2F;main&#x2F;config.w32.h，这时把 C:\php-7.0.26-src\win32\build\config.w32.h.in 复制到 C:\php-7.0.26-src\main\config.w32.h (注意没有了后面的 in)，然后在 config.w32.h 中加入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHP_COMPILER_ID <span class="hljs-string">&quot;VC14&quot;</span></span><br></code></pre></td></tr></table></figure><p>Dos</p><p>这将指明运行库是 VC14，与前面下载到的已编译 PHP 程序匹配，重新生成下解决方案，这样就能成功编译了！</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA 进行AES加密</title>
    <link href="/article/a4d9967a.html"/>
    <url>/article/a4d9967a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br></pre></td><td class="code"><pre><code class="hljs r">`private` `static` `final` `String SYMBOLS =` `&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;``;` `// 数字和26个字母组成`<br><br>`private` `static` `final` `Random RANDOM =` `new` `SecureRandom();`<br><br>`/**`<br><br> `* 获取长度为 6 的随机字母+数字`<br><br> `* @return 随机数字`<br><br> `*/`<br><br>`public` `static` `String getRandomNumber() &#123;`<br><br>    `char``[] nonceChars =` `new` `char``[``<span class="hljs-number">16</span>``<span class="hljs-punctuation">]</span>;`  `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>指定长度为<span class="hljs-number">6</span>位<span class="hljs-operator">/</span>自己可以要求设置`<br><br>    `<span class="hljs-keyword">for</span>` `<span class="hljs-punctuation">(</span>``int` `index <span class="hljs-operator">=</span>` `0``; index <span class="hljs-operator">&lt;</span> nonceChars.length; <span class="hljs-operator">+</span><span class="hljs-operator">+</span>index<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span>`<br><br>        `nonceChars<span class="hljs-punctuation">[</span>index<span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> SYMBOLS.charAt<span class="hljs-punctuation">(</span>RANDOM.nextInt<span class="hljs-punctuation">(</span>SYMBOLS.length<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>    `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-built_in">return</span>` `new` `String<span class="hljs-punctuation">(</span>nonceChars<span class="hljs-punctuation">)</span>;`<br><br>`<span class="hljs-punctuation">&#125;</span>`<br><br>`import` `org.apache.commons.lang3.RandomStringUtils;`<br><br>`import` `org.apache.commons.lang3.StringUtils;`<br><br>`import` `org.slf4j.Logger;`<br><br>`import` `org.slf4j.LoggerFactory;`<br><br>`import` `org.springframework.util.Base64Utils;`<br><br>`import` `javax.crypto.Cipher;`<br><br>`import` `javax.crypto.spec.IvParameterSpec;`<br><br>`import` `javax.crypto.spec.SecretKeySpec;`<br><br>`<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br> `<span class="hljs-operator">*</span> AES加密工具类`<br><br> `<span class="hljs-operator">*</span>`<br><br> `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>author ACGkaka`<br><br> `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>since <span class="hljs-number">2021</span><span class="hljs-operator">-</span><span class="hljs-number">06</span><span class="hljs-operator">-</span><span class="hljs-number">18</span> <span class="hljs-number">19</span><span class="hljs-operator">:</span><span class="hljs-number">11</span><span class="hljs-operator">:</span><span class="hljs-number">03</span>`<br><br> `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>`public` `<span class="hljs-built_in">class</span>` `AESUtil <span class="hljs-punctuation">&#123;</span>`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> 日志相关`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `private` `static` `final` `Logger LOGGER <span class="hljs-operator">=</span> LoggerFactory.getLogger<span class="hljs-punctuation">(</span>AESUtil.``<span class="hljs-built_in">class</span>``<span class="hljs-punctuation">)</span>;`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> 编码`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `private` `static` `final` `String ENCODING <span class="hljs-operator">=</span>` `<span class="hljs-string">&quot;UTF-8&quot;</span>``;`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> 算法定义`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `private` `static` `final` `String AES_ALGORITHM <span class="hljs-operator">=</span>` `<span class="hljs-string">&quot;AES&quot;</span>``;`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> 指定填充方式`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `private` `static` `final` `String CIPHER_PADDING <span class="hljs-operator">=</span>` `<span class="hljs-string">&quot;AES/ECB/PKCS5Padding&quot;</span>``;`<br><br>    `private` `static` `final` `String CIPHER_CBC_PADDING <span class="hljs-operator">=</span>` `<span class="hljs-string">&quot;AES/CBC/PKCS5Padding&quot;</span>``;`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> 偏移量<span class="hljs-punctuation">(</span>CBC中使用，增强加密算法强度<span class="hljs-punctuation">)</span>`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `private` `static` `final` `String IV_SEED <span class="hljs-operator">=</span>` `<span class="hljs-string">&quot;1234567812345678&quot;</span>``;`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> AES加密`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param content 待加密内容`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param aesKey  密码`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span><span class="hljs-built_in">return</span>`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `public` `static` `String encrypt<span class="hljs-punctuation">(</span>String content<span class="hljs-punctuation">,</span> String aesKey<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isBlank<span class="hljs-punctuation">(</span>content<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES encrypt: the content is null!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断秘钥是否为<span class="hljs-number">16</span>位`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isNotBlank<span class="hljs-punctuation">(</span>aesKey<span class="hljs-punctuation">)</span> <span class="hljs-operator">&amp;&amp;</span> aesKey.length<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">==</span>` `16``<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `try` `<span class="hljs-punctuation">&#123;</span>`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>对密码进行编码`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> bytes <span class="hljs-operator">=</span> aesKey.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置加密算法，生成秘钥`<br><br>                `SecretKeySpec skeySpec <span class="hljs-operator">=</span>` `new` `SecretKeySpec<span class="hljs-punctuation">(</span>bytes<span class="hljs-punctuation">,</span> AES_ALGORITHM<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-string">&quot;算法/模式/补码方式&quot;</span>`<br><br>                `Cipher cipher <span class="hljs-operator">=</span> Cipher.getInstance<span class="hljs-punctuation">(</span>CIPHER_PADDING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择加密`<br><br>                `cipher.init<span class="hljs-punctuation">(</span>Cipher.ENCRYPT_MODE<span class="hljs-punctuation">,</span> skeySpec<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>根据待加密内容生成字节数组`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> encrypted <span class="hljs-operator">=</span> cipher.doFinal<span class="hljs-punctuation">(</span>content.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>返回base64字符串`<br><br>                `<span class="hljs-built_in">return</span>` `Base64Utils.encodeToString<span class="hljs-punctuation">(</span>encrypted<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>` `catch` `<span class="hljs-punctuation">(</span>Exception e<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span>`<br><br>                `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES encrypt exception:&quot;</span>` `<span class="hljs-operator">+</span> e.getMessage<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `throw` `new` `RuntimeException<span class="hljs-punctuation">(</span>e<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-punctuation">&#125;</span>``<span class="hljs-keyword">else</span>` `<span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES encrypt: the aesKey is null or error!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> 解密`<br><br>     `<span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param content 待解密内容`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param aesKey  密码`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span><span class="hljs-built_in">return</span>`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `public` `static` `String decrypt<span class="hljs-punctuation">(</span>String content<span class="hljs-punctuation">,</span> String aesKey<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isBlank<span class="hljs-punctuation">(</span>content<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES decrypt: the content is null!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断秘钥是否为<span class="hljs-number">16</span>位`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isNotBlank<span class="hljs-punctuation">(</span>aesKey<span class="hljs-punctuation">)</span> <span class="hljs-operator">&amp;&amp;</span> aesKey.length<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">==</span>` `16``<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `try` `<span class="hljs-punctuation">&#123;</span>`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>对密码进行编码`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> bytes <span class="hljs-operator">=</span> aesKey.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置解密算法，生成秘钥`<br><br>                `SecretKeySpec skeySpec <span class="hljs-operator">=</span>` `new` `SecretKeySpec<span class="hljs-punctuation">(</span>bytes<span class="hljs-punctuation">,</span> AES_ALGORITHM<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-string">&quot;算法/模式/补码方式&quot;</span>`<br><br>                `Cipher cipher <span class="hljs-operator">=</span> Cipher.getInstance<span class="hljs-punctuation">(</span>CIPHER_PADDING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择解密`<br><br>                `cipher.init<span class="hljs-punctuation">(</span>Cipher.DECRYPT_MODE<span class="hljs-punctuation">,</span> skeySpec<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>先进行Base64解码`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> decodeBase64 <span class="hljs-operator">=</span> Base64Utils.decodeFromString<span class="hljs-punctuation">(</span>content<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>根据待解密内容进行解密`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> decrypted <span class="hljs-operator">=</span> cipher.doFinal<span class="hljs-punctuation">(</span>decodeBase64<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>将字节数组转成字符串`<br><br>                `<span class="hljs-built_in">return</span>` `new` `String<span class="hljs-punctuation">(</span>decrypted<span class="hljs-punctuation">,</span> ENCODING<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>` `catch` `<span class="hljs-punctuation">(</span>Exception e<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span>`<br><br>                `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES decrypt exception:&quot;</span>` `<span class="hljs-operator">+</span> e.getMessage<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `throw` `new` `RuntimeException<span class="hljs-punctuation">(</span>e<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-punctuation">&#125;</span>``<span class="hljs-keyword">else</span>` `<span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES decrypt: the aesKey is null or error!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> AES_CBC加密`<br><br>     `<span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param content 待加密内容`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param aesKey  密码`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span><span class="hljs-built_in">return</span>`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `public` `static` `String encryptCBC<span class="hljs-punctuation">(</span>String content<span class="hljs-punctuation">,</span> String aesKey<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isBlank<span class="hljs-punctuation">(</span>content<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES_CBC encrypt: the content is null!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断秘钥是否为<span class="hljs-number">16</span>位`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isNotBlank<span class="hljs-punctuation">(</span>aesKey<span class="hljs-punctuation">)</span> <span class="hljs-operator">&amp;&amp;</span> aesKey.length<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">==</span>` `16``<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `try` `<span class="hljs-punctuation">&#123;</span>`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>对密码进行编码`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> bytes <span class="hljs-operator">=</span> aesKey.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置加密算法，生成秘钥`<br><br>                `SecretKeySpec skeySpec <span class="hljs-operator">=</span>` `new` `SecretKeySpec<span class="hljs-punctuation">(</span>bytes<span class="hljs-punctuation">,</span> AES_ALGORITHM<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-string">&quot;算法/模式/补码方式&quot;</span>`<br><br>                `Cipher cipher <span class="hljs-operator">=</span> Cipher.getInstance<span class="hljs-punctuation">(</span>CIPHER_CBC_PADDING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>偏移`<br><br>                `IvParameterSpec iv <span class="hljs-operator">=</span>` `new` `IvParameterSpec<span class="hljs-punctuation">(</span>IV_SEED.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择加密`<br><br>                `cipher.init<span class="hljs-punctuation">(</span>Cipher.ENCRYPT_MODE<span class="hljs-punctuation">,</span> skeySpec<span class="hljs-punctuation">,</span> iv<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>根据待加密内容生成字节数组`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> encrypted <span class="hljs-operator">=</span> cipher.doFinal<span class="hljs-punctuation">(</span>content.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>返回base64字符串`<br><br>                `<span class="hljs-built_in">return</span>` `Base64Utils.encodeToString<span class="hljs-punctuation">(</span>encrypted<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>` `catch` `<span class="hljs-punctuation">(</span>Exception e<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span>`<br><br>                `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES_CBC encrypt exception:&quot;</span>` `<span class="hljs-operator">+</span> e.getMessage<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `throw` `new` `RuntimeException<span class="hljs-punctuation">(</span>e<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-punctuation">&#125;</span>``<span class="hljs-keyword">else</span>` `<span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES_CBC encrypt: the aesKey is null or error!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-operator">/</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> AES_CBC解密`<br><br>     `<span class="hljs-operator">*</span>`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param content 待解密内容`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span>param aesKey  密码`<br><br>     `<span class="hljs-operator">*</span> <span class="hljs-operator">@</span><span class="hljs-built_in">return</span>`<br><br>     `<span class="hljs-operator">*</span><span class="hljs-operator">/</span>`<br><br>    `public` `static` `String decryptCBC<span class="hljs-punctuation">(</span>String content<span class="hljs-punctuation">,</span> String aesKey<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isBlank<span class="hljs-punctuation">(</span>content<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES_CBC decrypt: the content is null!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断秘钥是否为<span class="hljs-number">16</span>位`<br><br>        `<span class="hljs-keyword">if</span>``<span class="hljs-punctuation">(</span>StringUtils.isNotBlank<span class="hljs-punctuation">(</span>aesKey<span class="hljs-punctuation">)</span> <span class="hljs-operator">&amp;&amp;</span> aesKey.length<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">==</span>` `16``<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span>`<br><br>            `try` `<span class="hljs-punctuation">&#123;</span>`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>对密码进行编码`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> bytes <span class="hljs-operator">=</span> aesKey.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>设置解密算法，生成秘钥`<br><br>                `SecretKeySpec skeySpec <span class="hljs-operator">=</span>` `new` `SecretKeySpec<span class="hljs-punctuation">(</span>bytes<span class="hljs-punctuation">,</span> AES_ALGORITHM<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>偏移`<br><br>                `IvParameterSpec iv <span class="hljs-operator">=</span>` `new` `IvParameterSpec<span class="hljs-punctuation">(</span>IV_SEED.getBytes<span class="hljs-punctuation">(</span>ENCODING<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span> <span class="hljs-string">&quot;算法/模式/补码方式&quot;</span>`<br><br>                `Cipher cipher <span class="hljs-operator">=</span> Cipher.getInstance<span class="hljs-punctuation">(</span>CIPHER_CBC_PADDING<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>选择解密`<br><br>                `cipher.init<span class="hljs-punctuation">(</span>Cipher.DECRYPT_MODE<span class="hljs-punctuation">,</span> skeySpec<span class="hljs-punctuation">,</span> iv<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>先进行Base64解码`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> decodeBase64 <span class="hljs-operator">=</span> Base64Utils.decodeFromString<span class="hljs-punctuation">(</span>content<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>根据待解密内容进行解密`<br><br>                `byte``<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> decrypted <span class="hljs-operator">=</span> cipher.doFinal<span class="hljs-punctuation">(</span>decodeBase64<span class="hljs-punctuation">)</span>;`<br><br>                `<span class="hljs-operator">/</span><span class="hljs-operator">/</span>将字节数组转成字符串`<br><br>                `<span class="hljs-built_in">return</span>` `new` `String<span class="hljs-punctuation">(</span>decrypted<span class="hljs-punctuation">,</span> ENCODING<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>` `catch` `<span class="hljs-punctuation">(</span>Exception e<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span>`<br><br>                `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES_CBC decrypt exception:&quot;</span>` `<span class="hljs-operator">+</span> e.getMessage<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>;`<br><br>                `throw` `new` `RuntimeException<span class="hljs-punctuation">(</span>e<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-punctuation">&#125;</span>`<br><br>        `<span class="hljs-punctuation">&#125;</span>``<span class="hljs-keyword">else</span>` `<span class="hljs-punctuation">&#123;</span>`<br><br>            `LOGGER.info<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;AES_CBC decrypt: the aesKey is null or error!&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>            `<span class="hljs-built_in">return</span>` `null``;`<br><br>        `<span class="hljs-punctuation">&#125;</span>`<br><br>    `<span class="hljs-punctuation">&#125;</span>`<br><br>    `public` `static` `void` `main<span class="hljs-punctuation">(</span>String<span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> args<span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span>`<br><br>        `<span class="hljs-operator">/</span><span class="hljs-operator">/</span> AES支持三种长度的密钥：<span class="hljs-number">128</span>位、<span class="hljs-number">192</span>位、<span class="hljs-number">256</span>位。`<br><br>        `<span class="hljs-operator">/</span><span class="hljs-operator">/</span> 代码中这种就是<span class="hljs-number">128</span>位的加密密钥，<span class="hljs-number">16</span>字节 <span class="hljs-operator">*</span> <span class="hljs-number">8</span>位<span class="hljs-operator">/</span>字节 <span class="hljs-operator">=</span> <span class="hljs-number">128</span>位。`<br><br>        `String random <span class="hljs-operator">=</span> RandomStringUtils.random<span class="hljs-punctuation">(</span>``16``<span class="hljs-punctuation">,</span>` `<span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz1234567890&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;随机key:&quot;</span>` `<span class="hljs-operator">+</span> random<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;---------加密---------&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>        `String aesResult <span class="hljs-operator">=</span> encrypt<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;测试AES加密12&quot;</span>``<span class="hljs-punctuation">,</span> random<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;aes加密结果:&quot;</span>` `<span class="hljs-operator">+</span> aesResult<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;---------解密---------&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>        `String decrypt <span class="hljs-operator">=</span> decrypt<span class="hljs-punctuation">(</span>aesResult<span class="hljs-punctuation">,</span> random<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;aes解密结果:&quot;</span>` `<span class="hljs-operator">+</span> decrypt<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;--------AES_CBC加密解密---------&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>        `String cbcResult <span class="hljs-operator">=</span> encryptCBC<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;测试AES加密12456&quot;</span>``<span class="hljs-punctuation">,</span> random<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;aes_cbc加密结果:&quot;</span>` `<span class="hljs-operator">+</span> cbcResult<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;---------解密CBC---------&quot;</span>``<span class="hljs-punctuation">)</span>;`<br><br>        `String cbcDecrypt <span class="hljs-operator">=</span> decryptCBC<span class="hljs-punctuation">(</span>cbcResult<span class="hljs-punctuation">,</span> random<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span>``<span class="hljs-string">&quot;aes解密结果:&quot;</span>` `<span class="hljs-operator">+</span> cbcDecrypt<span class="hljs-punctuation">)</span>;`<br><br>        `System.out.println<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>;`<br><br>    `<span class="hljs-punctuation">&#125;</span>`<br><br>`<span class="hljs-punctuation">&#125;</span>`<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>AES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 实现b2a_hex，a2b_hex</title>
    <link href="/article/d9c680b0.html"/>
    <url>/article/d9c680b0.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-number">1.</span> <span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">byte</span>[] <span class="hljs-built_in">hexStringToByteArray</span>(<span class="hljs-type">String</span> s) &#123;<br>    <br><span class="hljs-number">2.</span>         <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">length</span>();<br>    <br><span class="hljs-number">3.</span>         <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-type">byte</span>[len / <span class="hljs-number">2</span>];<br>    <br><span class="hljs-number">4.</span>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i += <span class="hljs-number">2</span>) &#123;<br>    <br><span class="hljs-number">5.</span>             data[i / <span class="hljs-number">2</span>] = (<span class="hljs-type">byte</span>) ((Character.<span class="hljs-built_in">digit</span>(s.<span class="hljs-built_in">charAt</span>(i), <span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-number">4</span>)<br>    <br><span class="hljs-number">6.</span>                                  + Character.<span class="hljs-built_in">digit</span>(s.<span class="hljs-built_in">charAt</span>(i+<span class="hljs-number">1</span>), <span class="hljs-number">16</span>));<br>    <br><span class="hljs-number">7.</span>         &#125;<br>    <br><span class="hljs-number">8.</span>         <span class="hljs-keyword">return</span> data;<br>    <br><span class="hljs-number">9.</span>     &#125;<br>    <br><span class="hljs-number">10.</span>     <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">byteToHexString</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> </span>&#123;<br>    <br><span class="hljs-number">11.</span>         StringBuffer sb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuffer</span>(bytes.length);<br>    <br><span class="hljs-number">12.</span>         <span class="hljs-type">String</span> sTemp;<br>    <br><span class="hljs-number">13.</span>         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; bytes.length; i++) &#123;<br>    <br><span class="hljs-number">14.</span>             sTemp = Integer.<span class="hljs-built_in">toHexString</span>(<span class="hljs-number">0xFF</span> &amp; bytes[i]);<br>    <br><span class="hljs-number">15.</span>             <span class="hljs-keyword">if</span> (sTemp.<span class="hljs-built_in">length</span>() &lt; <span class="hljs-number">2</span>)<br>    <br><span class="hljs-number">16.</span>                 sb.<span class="hljs-built_in">append</span>(<span class="hljs-number">0</span>);<br>    <br><span class="hljs-number">17.</span>             sb.<span class="hljs-built_in">append</span>(sTemp);<br>    <br><span class="hljs-number">18.</span>         &#125;<br>    <br><span class="hljs-number">19.</span>         <span class="hljs-keyword">return</span> sb.<span class="hljs-built_in">toString</span>();<br>    <br><span class="hljs-number">20.</span>     &#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis命令</title>
    <link href="/article/d43a4e4c.html"/>
    <url>/article/d43a4e4c.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><ol><li>使用redis-cli -c 参数从任意节点登录的，不管数据再哪个节点上，get 读取数据时都会重定向到数据所在master节点上读取。</li><li>CLUSTER HELP 查看CLUSTER具体命令</li><li>CLUSTER KEYSLOT DEMO 计算DEMO的key的hash值</li><li>redis-cli –cluster create 192.168.1.2:7001 192.168.1.2:7002 192.168.1.3:7003 192.168.1.3:7004 192.168.1.4:7005 192.168.1.4:7006 –cluster-replicas 1 创建集群</li></ol>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka主题，分区，副本介绍</title>
    <link href="/article/4961b213.html"/>
    <url>/article/4961b213.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>今天分享一下kafka的主题(topic)，分区(partition)和副本(replication)，主题是Kafka中很重要的部分，消息的生产和消费都要以主题为基础，一个主题可以对应多个分区，一个分区属于某个主题，一个分区又可以对应多个副本，副本分为leader和follower。</p><p>副本的作用是保证数据的高可用，一个副本在一个broker节点上，broker就是一个台机器或者一个kafka实例，当某个副本出现故障后，还可以使用其他副本的数据，如果只有一个副本，那么就无法保证高可用。</p><p>主题，分区实际上只是逻辑概念，真正消息存储的地方是副本的日志文件上，所以主题分区的作用是在逻辑上更加规范的管理日志文件。</p><p>主题，分区，副本关系如图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6752e3eeb73469d876a6f5a10ac2154~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p><h2 id="创建主题分区"><a href="#创建主题分区" class="headerlink" title="创建主题分区"></a>创建主题分区</h2><p>可以使用kafka-topics.sh创建topic，也可以使用Kafka AdminClient创建，当我们往Kafka发送消息的时候，如果指定的topic不存在，那么就会创建一个分区数为1的topic，不过这样做并不合适，我们应该规划好主题的分区，副本，然后在创建topic，这样对管理topic更加好。</p><p>kafka broker端默认设置了<code>allow.auto.create.topics=true</code>，所以会自动创建topic，为了更加规范和合理管理topic，我们可以将其设置为false，当然，一般情况下中我们肯定会进行手动创建topic，但是以防不确定因素，将其设置为false更保险一些。</p><h4 id="使用kafka-topics-sh创建主题"><a href="#使用kafka-topics-sh创建主题" class="headerlink" title="使用kafka-topics.sh创建主题"></a>使用kafka-topics.sh创建主题</h4><p>css</p><p>复制代码</p><p><code>bin/kafka-topics.sh --create --bootstrap-server 127.0.0.1:9092 --replication-factor 1 --partitions 2 --topic pig</code></p><h4 id="使用Kafka-AdminClient"><a href="#使用Kafka-AdminClient" class="headerlink" title="使用Kafka AdminClient"></a>使用Kafka AdminClient</h4><p>创建topic名字为pig，分区数为1，副本数为1的分区。</p><p>ini</p><p>复制代码</p><p><code>Properties properties = new Properties(); properties.setProperty(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;127.0.0.1:9092&quot;); AdminClient adminClient = AdminClient.create(properties); //创建topic NewTopic newTopic = new NewTopic(&quot;pig&quot;, 4, (short) 2); CreateTopicsResult result = adminClient.createTopics(Collections.singleton(newTopic));</code></p><p>需要注意的是，如果使用的是单机kafka，所以只有一个broker，如果副本设置大于1，那么就会抛出异常，因为一个副本对应一个broker。</p><p>创建了主题分区后，会在配置我们配置的日志目录(<code>log.dirs</code>)下生成对应的分区副本文件夹。</p><h2 id="分区，副本详解"><a href="#分区，副本详解" class="headerlink" title="分区，副本详解"></a>分区，副本详解</h2><p>上面创建了分区数为4，副本为2的topic，使用命令 <code>bin/kafka-topics.sh --describe --topic musk --bootstrap-server 127.0.0.1:9092</code>查看分区情况。</p><p>如下名为<code>musk</code>的topic，分区数(PartitionCount)为4，副本数(ReplicationFactor)为2，有三个<code>broker</code>，kafka会将副本合理的划分到不同的机器上。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf03894c3a534c4e86aa163fbaf04dab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p><p>里面的数字0，1，2代表broker的唯一标识，因为在配置kafka集群的时候，三台机器的broker.id分别为0，1，2。</p><p>可知分区0的副本Leader在<code>机器2</code>上，副本follower在<code>机器1</code>上面，<code>机器0</code>上不存在分区0的副本,分区1的副本Leader在<code>机器1</code>上，副本follower在<code>机器0</code>上面，<code>机器2</code>上不存在分区1的副本，分区2和分区3以此类推。</p><blockquote><p>从上面可以看出kafka要创建4个分区，每个分区对应两个副本，所以就存在8个副本，8个副本要平均分配到3台机器上上，所以就按照<code>3:3:2</code>的比例分配副本，是按照平均分配的方式进行分配的。</p></blockquote><p>下面我们创建分区数为4，副本为3的分区，如图所示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a65744507af548628fee9e2f1857210b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp"></p><p>可以看出，副本平均分配到了0，1，2三台机器上，每个分区有3个副本，所以4个分区有一共有12个副本。</p><p>可以看出是4个分区，每个分区3个副本，所以就有12个副本，12个副本分配到3台机器上面，所以比例是<code>4:4:4</code>。</p><h2 id="AR，ISR，OSR"><a href="#AR，ISR，OSR" class="headerlink" title="AR，ISR，OSR"></a>AR，ISR，OSR</h2><p>AR 集合（Assigned Replica set）：AR 集合是指已经被分配到的分区副本集合。在 Kafka 集群中，每个分区都有若干个副本，其中一个是 leader 副本，负责处理读写请求，其他的是 follower 副本，用于备份数据和提高可用性。AR 集合就是所有被分配到的副本的集合，包括 leader 和 follower 副本。</p><p>ISR 集合（In-Sync Replica set）：ISR 集合是指当前处于同步状态的副本集合。ISR 集合是 AR 集合的子集，即 ISR 集合中的副本与 leader 副本保持同步。如果一个 follower 副本与 leader 副本失去同步，那么它将从 ISR 集合中移除。</p><p>OSR 集合（Out-of-Sync Replica set）：OSR 集合是指当前处于不同步状态的副本集合。OSR 集合是 AR 集合的另一个子集，即 OSR 集合中的副本与 leader 副本失去同步。这些副本可能正在追赶 leader，或者发生了某些错误导致与 leader 失去同步。在某些情况下，如果 ISR 集合缩小到了一个不可接受的程度，就需要将 OSR 集合中的副本加入 ISR 集合中，以保证可用性。</p><blockquote><p>今天的分享就到这里，感谢你的观看，我们下期见！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springmvc 的作用 上传图片立即显示</title>
    <link href="/article/3ba10fab.html"/>
    <url>/article/3ba10fab.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p>转载自：<a href="https://blog.csdn.net/weixin/_42950079/article/details/88813630">https://blog.csdn.net/weixin\_42950079/article/details/88813630</a></p><p>我们都知道web项目需要部署到tomcat服务器中运行</p><p>那么，我们又是如何通过tomcat来访问存放在本地磁盘中的图片呢？，通过tomcat访问本地图片，需要配置虚拟路径，下面介绍两种配置虚拟路径的方式：</p><p>1、使用 IDEA 设置 虚拟路径<br>2、在 Tomcat 中设置 虚拟路径<br>如果不配置虚拟路径，我们使用Spring MVC上传的图片就无法正常显示，我在学习使用Spring MVC上传图片时就遇到过这样的问题，图片上传成功了，但无法让图片在浏览器中显示</p><h1 id="第一种：使用-IDEA-设置-虚拟路径"><a href="#第一种：使用-IDEA-设置-虚拟路径" class="headerlink" title="第一种：使用 IDEA 设置 虚拟路径"></a>第一种：使用 IDEA 设置 虚拟路径</h1><p>1、先创建一个Spring MVC项目，将项目部署到tomcat中</p><p>2、 在Output directory目录下创建 image 文件夹，用来保存上传的图片，在编写文件上传代码时，就可以通过request.getServletContext().getRealPath(“&#x2F;image&#x2F;“); 获取到该目录，然后指定图片上传到该目录中</p><p>request.getServletContext().getRealPath(“”); 方法用于获取Output directory目录的路径</p><p>如果指定其它目录保存上传的图片，比如在WEB-INF目录下创建一个image文件夹来保存上传的图片，就不能通过String path&#x3D;request.getServletContext().getRealPath(“&#x2F;image&#x2F;“); 方法来获取该目录，它是用来获取Output directory目录的路径的</p><p>而是通过String path&#x3D;”E:\ideaUI\javaworkspace\springmvcTest\web\WEB-INF\image”; 来指定图片保存目录</p><p> <img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702095151267-1116514114.png"></p><p><img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702101240267-552918868.png"></p><p>3、Run → Edit Configurations . . . → Deployment → + → External Source . . .</p><p><img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702101252412-224344527.png"></p><p>4、选择保存上传图片的磁盘路径，并设置虚拟路径为&#x2F;img<br>   配置成功后，就可以通过 localhost：8080&#x2F;img&#x2F;图片名称全称 访问到图片</p><p> <img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702101324941-579734131.png"></p><h1 id="第二种：在-Tomcat-中设置-虚拟路径"><a href="#第二种：在-Tomcat-中设置-虚拟路径" class="headerlink" title="第二种：在 Tomcat 中设置 虚拟路径"></a>第二种：在 Tomcat 中设置 虚拟路径</h1><p>1、进入tomcat安装目录，找到conf文件夹下的server.xml文件</p><p><img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702101405666-1676849834.png"></p><p>2、在标签中添加 <Context path="/img" docBase="E:\\ideaUI\\javaworkspace\\springmvcTest\\out\\artifacts\\springmvcTest\_war\_exploded\\image" reloadable="true"/> 设置虚拟路径</p><p>path&#x3D;”&#x2F;img”  → 是虚拟路径<br>docBase&#x3D;“E:\ideaUI\javaworkspace\springmvcTest\out\artifacts\springmvcTest_war_exploded\image”   → 是磁盘中保存图片的真实目录</p><p><img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702101419382-1124377410.png"></p><p>3、Run → Edit Configurations . . . → 勾选 Deploy applications configured in Tomcat instance</p><p><img src="https://img2018.cnblogs.com/blog/1418529/201907/1418529-20190702101445323-1411097593.png"></p><h1 id="第三种-修改上传文件路径为Artifacts的输出目录。"><a href="#第三种-修改上传文件路径为Artifacts的输出目录。" class="headerlink" title="第三种 修改上传文件路径为Artifacts的输出目录。"></a>第三种 修改上传文件路径为Artifacts的输出目录。</h1><p>D:&#x2F;adopt-master&#x2F;target&#x2F;adopt&#x2F;static&#x2F;images&#x2F;animal&#x2F;</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis集群节点显示noaddr</title>
    <link href="/article/175c32e0.html"/>
    <url>/article/175c32e0.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p>1.当集群使用kill命令杀死某个主节点后，再启动此节点无法加入到集群中<br>显示no addr<br>78641a9cf0098e1c5c07821266dcd1feae21bcd3 :0 slave,noaddr - 1530942381678 1530942361875 0 disconnected</p><p>排查原因:<br>    kill之后再启动执行命令时路径和原先不一致，redis.conf dir 配置.&#x2F;  数据位置变了<br>解决方案：<br>    redis.conf 配置dir目录，让数据存储在固定目录，再启动时就可以读取此目录下配置</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小米手机Root方法 - 知乎</title>
    <link href="/article/5cd588af.html"/>
    <url>/article/5cd588af.html</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /># 小米手机Root方法 - 知乎<blockquote><h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><p>原文出处： 小米手机安装面具教程（Xiaomi手机获取root权限）。根据作者自身的操作结果有所改动。 演示环境： 手机机型： 小米 8 SE 手机系统：MIUI12.5.1稳定版（安卓10） 电脑系统：Windows7 64位演示步骤： 一…</p></blockquote><hr><p>原文出处：<a href="https://link.zhihu.com/?target=https://magiskcn.com/">小米手机安装面具教程（Xiaomi手机获取root权限）</a>。</p><p>根据作者自身的操作结果有所改动。</p><p>演示环境：</p><p>手机机型：<strong>小米 8 SE</strong><br>手机系统：MIUI12.5.1稳定版（安卓10）<br>电脑系统：Windows7 64位</p><p>演示步骤：</p><p>一、<strong>Bootloader</strong>解锁：<a href="https://link.zhihu.com/?target=https://magiskcn.com/xiaomi-unlock">Xiaomi-unlock</a><br><em>如果你的手机不能解锁BL，推荐</em> <em>**<a href="https://link.zhihu.com/?target=https://magiskcn.com/gsxnj">光速虚拟机</a>**（不用解锁BL也可以刷面具）</em></p><p><em>作者手机已经之前已经解锁，所以这步省略，成功之后每次启动手机页面最上端中间会有个解开的锁的logo。</em></p><p>二、下载<strong>系统安装包</strong>：<a href="https://link.zhihu.com/?target=https://magiskcn.com/get-miui">Get-miui</a></p><p>作者提示：系统包分卡刷包和线刷包，我都下载了，不过后面我是线刷的】</p><p>三、解包提取boot：<a href="https://link.zhihu.com/?target=https://magiskcn.com/payload-dumper-go">Payload-dumper-go</a>（如果系统包有 <strong>boot.img</strong>，可以跳过此步骤）</p><p>作者提示：这步多半是多余的，不管我下载的卡刷包和线刷包，解压之后包里都有boot.img，可以直接用。</p><p>四、手机插电脑，文件传输模式，复制 <strong>boot.img</strong> 和 <strong>系统包</strong> 到手机 <strong>Download</strong> 目录</p><p>作者提示：我只复制了boot.img到手机<strong>Download</strong> 目录，手机位置也不是固定的，可以自己新建在根目录位置。</p><p>五、1.连击LOGO（开启系统更新扩展功能）- 2.手动选择安装包 – 3.选择系统包升级<br><em>（这里是保证</em> <em><strong>系统包版本</strong></em> <em>和</em> <em><strong>手机系统版本</strong></em> <em>一致，如果版本一致可以跳过）</em></p><p><img src="https://pic3.zhimg.com/v2-0f8753d50d123fea8525c80857180dee_b.jpg"></p><p>作者提示：这步我没有做，后面启动不起来可能跟这步有关系。</p><p>六、手机下载安装<strong>Magisk</strong> app：<a href="https://link.zhihu.com/?target=https://magiskcn.com/magisk-download">Magisk-download</a></p><p>七、1.安装 – 2.选项 <strong>都不勾</strong>（勾了会卡米，部分手机没有选项）- 3.选择并修补一个文件</p><p><img src="https://pic2.zhimg.com/v2-b9e012189b784d0ea027927a5ec9e119_b.jpg"></p><p>八、4.选择<strong>boot.img</strong> – 5.开始 – 6.修补成功</p><p><img src="https://pic4.zhimg.com/v2-b5c59f4dee9d77783cca2c5eef62460b_b.jpg"></p><p>九、修补成功，会在 <strong>Download</strong> 目录生成（<strong>magisk_patched-版本_随机.img</strong>）文件，每次生成的随机字符都不一样，使用的时候请输入生成的名字。</p><p><img src="https://pic2.zhimg.com/v2-d5ea535fe343a49bcf9a93b01d1e6a7d_b.jpg"></p><p>十、电脑下载 <strong>adb-fastboot</strong>：<a href="https://link.zhihu.com/?target=https://mrzzoxo.lanzoub.com/b02plghuh">lanzoub.com&#x2F;b02plghuh</a>（解压出来）</p><p>十一、手机插电脑，文件传输模式，把 <strong>boot.img</strong> 和 <strong>magisk_patched-版本_随机.img</strong> 两个文件复制到 <strong>adb-fastboot</strong> 目录</p><p><img src="https://pic4.zhimg.com/v2-e6e57a7570af6742796f6f955055289f_b.jpg"></p><p>十二、手机重启到 <strong>fastboot</strong> 模式（按电源键重启 马上按住 音量键 –）插上电脑</p><p>十三、打开“<strong>打开CMD命令行.bat</strong>”，输入下面的命令</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">fastboot flash boot magisk_patched-版本<span class="hljs-literal">_</span>随机.img<br></code></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/v2-fee3db9851312a67e7781b0024b5542b_b.jpg"></p><p>作者提示：这步我自己操作碰到问题。电脑上点击bat文件不运行，折腾一番后用cmd，直接输入，总算是成功了。如果有同样碰到此问题，可以cmd中直接先运行adb试试。</p><p>十四、出现下面这三行代码，就是成功刷入了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Sending</span> &#x27;boot&#x27; (<span class="hljs-number">131072</span> KB) OKAY<span class="hljs-meta"> [ 3.311s]</span><br><span class="hljs-attribute">Writing</span> &#x27;boot&#x27; OKAY<span class="hljs-meta"> [ 0.441s]</span><br><span class="hljs-attribute">Finished</span>. Total time: <span class="hljs-number">3</span>.<span class="hljs-number">794</span>s<br></code></pre></td></tr></table></figure><p>十五、重启手机（开机有震动基本没问题了）耐心等手机开机。（显示Magisk的版本，就是刷好了的）</p><p><img src="https://pic2.zhimg.com/v2-d8b9963983cc8659d6aab67060db9431_b.jpg"></p><p>作者提示：见证奇迹的时刻到了。可惜，我的没成功，启动后一直停留在mi字界面，成功变砖。咋整？最后这几步又重新试了几次，最后还是不行。还好操作之前已经备份好了数据，直接上线刷包，用小米flash工具直接刷，刚开始右下角选的保留数据，开机还是不行，所以干脆清除数据，果断重新刷机，然后成功开机了。猜想失败的原因是miui版本低了，本身手机上的版本相对较高。</p><p><strong>温馨提示</strong><br>如果刷模块不兼容或者其他骚操作导致不能开机，可以把我们前面提取的<strong>boot.img</strong>通过<strong>fastboot</strong>刷回去，恢复原系统，一般都能正常开机！<br><strong>boot.img</strong>保留一份在电脑，避免出问题了可以自救下！还原boot指令</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">fastboot flash <span class="hljs-keyword">boot</span> <span class="hljs-keyword">boot</span>.img<br></code></pre></td></tr></table></figure><p>后期系统更新，直接下载全量完整包升级，然后重复上面的步骤就可以继续愉快的使用<strong>Magisk</strong>了！</p><p>最后总结：手机不是卡的不能用的情况，不要瞎搞机，首先这个步骤走下来，新手可能就会花掉一天的时间，耗时耗力，二是即使ROOT成功，对普通用户来讲，没多少个卵用，还会被提示各种风险。总的来说对于普通用户而言，弊大于利，不建议Root。搞机有风险，后果需自负。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络搜寻</tag>
      
      <tag>Root</tag>
      
      <tag>(Android)</tag>
      
      <tag>root方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓开发day01</title>
    <link href="/article/2dae291a.html"/>
    <url>/article/2dae291a.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li>安卓AS调试安装后自动打开，Run&#x2F;Debug Configurations 设置 app的Launch 选择DefaultActivity</li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chown和chmod区别</title>
    <link href="/article/cd33d05d.html"/>
    <url>/article/cd33d05d.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><p><code>chown</code>和<code>chmod</code>是两个在Linux和UNIX系统中使用的命令，用于修改文件和目录的权限和所有者。它们的主要区别如下：</p><ol><li><p>chown（Change Owner）：</p><ul><li><code>chown</code>命令用于更改文件或目录的所有者（即用户）。</li><li>它可以将文件或目录的所有权转移给不同的用户。</li><li>语法：<code>chown [options] owner[:group] file(s)</code></li><li>示例：<code>chown user1:group1 file.txt</code></li></ul></li><li><p>chmod（Change Mode）：</p><ul><li><code>chmod</code>命令用于更改文件或目录的访问权限。</li><li>它可以设置文件或目录的读、写和执行权限，以及特殊权限（如SUID、SGID和Sticky位）。</li><li>语法：<code>chmod [options] mode file(s)</code></li><li>示例：<code>chmod 755 file.txt</code></li></ul></li></ol><p>主要区别：</p><ul><li><code>chown</code>用于更改文件或目录的所有者，而<code>chmod</code>用于更改文件或目录的权限。</li><li><code>chown</code>需要提供新的所有者的用户名（以及可选的组名），而<code>chmod</code>需要提供新的权限模式。</li><li><code>chown</code>只能由文件或目录的所有者或超级用户执行，而<code>chmod</code>可以由文件或目录的所有者、所属组、其他用户或超级用户执行。</li><li><code>chown</code>更改所有者信息不会影响文件或目录的权限，而<code>chmod</code>更改权限不会影响文件或目录的所有者。</li></ul><p>总结起来，<code>chown</code>用于更改文件或目录的所有者，而<code>chmod</code>用于更改文件或目录的权限。它们是不同的命令，用于不同的目的。</p><p>在Linux系统中，文件和目录的权限用一串字符表示，其中包括10个字符：第一个字符表示文件类型，后续九个字符表示对应的权限。</p><p>对于目录，第一个字符是<code>d</code>，表示它是一个目录。对于文件，第一个字符可以是其他类型的标识符，如<code>-</code>表示普通文件。</p><p>后续的九个字符是分为三组，每组三个字符，分别表示文件所有者的权限、文件所属组的权限和其他用户的权限。这三组字符的顺序是固定的，依次是读取（<code>r</code>）、写入（<code>w</code>）和执行（<code>x</code>）的权限。</p><p>权限字符的含义如下：</p><ul><li><code>r</code>：读取权限，表示可以读取文件的内容或查看目录的内容列表。</li><li><code>w</code>：写入权限，表示可以修改文件的内容或在目录中创建、删除或重命名文件。</li><li><code>x</code>：执行权限，对于文件表示可以执行它作为可执行程序，对于目录表示可以进入目录。</li></ul><p>如果对应位置的字符是<code>-</code>，表示相应的权限被禁止。</p><p>例如，一个目录的权限为<code>drwxr-xr-x</code>，解读如下：</p><ul><li>第一个字符<code>d</code>表示它是一个目录。</li><li>后续九个字符可以分为三组：<code>rwx</code>、<code>r-x</code>和<code>r-x</code>。</li><li><code>rwx</code>表示文件所有者具有读取、写入和执行的权限。</li><li><code>r-x</code>表示文件所属组具有读取和执行的权限，但没有写入的权限。</li><li><code>r-x</code>表示其他用户具有读取和执行的权限，但没有写入的权限。</li></ul><p>总结起来，<code>drwxr-xr-x</code>表示一个目录，文件所有者具有完全权限，文件所属组和其他用户具有读取和执行的权限，但没有写入的权限。</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian中使用网页剪报 - 哔哩哔哩</title>
    <link href="/article/2e271d30.html"/>
    <url>/article/2e271d30.html</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer" /><h1 id="obsidian中使用网页剪报-哔哩哔哩"><a href="#obsidian中使用网页剪报-哔哩哔哩" class="headerlink" title="obsidian中使用网页剪报 - 哔哩哔哩"></a>obsidian中使用网页剪报 - 哔哩哔哩</h1><blockquote><h2 id="Excerpt"><a href="#Excerpt" class="headerlink" title="Excerpt"></a>Excerpt</h2><h2 id="背景：平时经常使用网页剪报来做一些记录，但是切换到obsidian后，没有剪报有些不习惯，于是找了下相关的插件，安装后记录-插件下载：obsidian插件：advanced-obsidian-uri这个插件用来控制obsidian-uri相关操作。markdownload这个插件用来将浏览器中的内容剪切为markdown格式。-安装配置obsidian中的advanced-obsidian-uri插件能一键安装，这里就不说了，主要是chrome中markdownload插件的"><a href="#背景：平时经常使用网页剪报来做一些记录，但是切换到obsidian后，没有剪报有些不习惯，于是找了下相关的插件，安装后记录-插件下载：obsidian插件：advanced-obsidian-uri这个插件用来控制obsidian-uri相关操作。markdownload这个插件用来将浏览器中的内容剪切为markdown格式。-安装配置obsidian中的advanced-obsidian-uri插件能一键安装，这里就不说了，主要是chrome中markdownload插件的" class="headerlink" title="背景：平时经常使用网页剪报来做一些记录，但是切换到obsidian后，没有剪报有些不习惯，于是找了下相关的插件，安装后记录## 插件下载：obsidian插件：advanced obsidian uri这个插件用来控制obsidian uri相关操作。markdownload这个插件用来将浏览器中的内容剪切为markdown格式。## 安装配置obsidian中的advanced obsidian uri插件能一键安装，这里就不说了，主要是chrome中markdownload插件的"></a>背景：平时经常使用网页剪报来做一些记录，但是切换到obsidian后，没有剪报有些不习惯，于是找了下相关的插件，安装后记录## 插件下载：<strong>obsidian插件：</strong>advanced obsidian uri这个插件用来控制obsidian uri相关操作。<strong>markdownload</strong>这个插件用来将浏览器中的内容剪切为markdown格式。## 安装配置obsidian中的advanced obsidian uri插件能一键安装，这里就不说了，主要是chrome中markdownload插件的</h2></blockquote><hr><p><strong>## 背景：</strong>  </p><p>平时经常使用网页剪报来做一些记录，但是切换到obsidian后，没有剪报有些不习惯，于是找了下相关的插件，安装后记录</p><p><strong>## 插件下载：</strong></p><p><strong>**obsidian插件：**</strong></p><p>advanced obsidian uri</p><p>这个插件用来控制obsidian uri相关操作。</p><p><img src="https://i0.hdslb.com/bfs/article/157fe16638857a03442126c65b7039507f55b83e.png@1256w_1142h_!web-article-pic.avif"></p><p><strong>**markdownload**</strong>  </p><p>这个插件用来将浏览器中的内容剪切为markdown格式。</p><p><img src="https://i0.hdslb.com/bfs/article/f40d3bd258ea67975bece878517d8ec3ea313ab3.png@1256w_1144h_!web-article-pic.avif"></p><p><strong>## 安装配置</strong>  </p><p>obsidian中的advanced obsidian uri插件能一键安装，这里就不说了，主要是chrome中markdownload插件的配置。</p><p>在chrome 扩展程序中扩展程序选项配置markdownload插件设置。</p><p><img src="https://i0.hdslb.com/bfs/article/2b45f85d31b050823b7b5595e80aef10fabe1703.png@1256w_894h_!web-article-pic.avif"></p><p>配置中需要更改的主要是两个地方：</p><p>1、开启chrome markdownload插件与obsidian联动功能，配置网页剪切保存位置，这是核心，否则不能自动保存到obsidian中。</p><p><img src="https://i0.hdslb.com/bfs/article/218db792a3e7b644cad53833f2c9f1e259a201cf.png@1256w_402h_!web-article-pic.avif"></p><p>2、开启剪切模板，开启后会有一个固定格式，跟写代码时配置的代码文档格式一样。（我个人喜欢配上）</p><p><img src="https://i0.hdslb.com/bfs/article/2fdf96490624ffbde9e02fd324ae507977020b44.png@1256w_296h_!web-article-pic.avif"></p><p>其他的比如背景什么的就看个人喜好去调整下。</p><p><strong>## 实施效果</strong></p><p>**全网页剪切**：在要剪切的页面上右键-》markdownload插件-》send tab to obsidian</p><p><img src="https://i0.hdslb.com/bfs/article/9664d263fda3f792c495434ab6da496df10e697a.png@1256w_1308h_!web-article-pic.avif"></p><p>**部分文字剪切**:选中要剪切的文字，右键-》markdownload插件-》send text  selection to obsidian</p><p><img src="https://i0.hdslb.com/bfs/article/c7040b64297097656d88a088b7cf1f611374267f.png@1256w_1062h_!web-article-pic.avif"><br>{<br>  “backmatter”: “”,<br>  “bulletListMarker”: “-“,<br>  “codeBlockStyle”: “fenced”,<br>  “contextMenus”: true,<br>  “disallowedChars”: “[]#^”,<br>  “downloadImages”: true,<br>  “downloadMode”: “downloadsApi”,<br>  “emDelimiter”: “<em>“,<br>  “fence”: “&#96;&#96;&#96;”,<br>  “frontmatter”: “—\ncreated: {date:YYYY-MM-DDTHH:mm:ss} (UTC {date:Z})\ntags: [{keywords},网络搜寻]\nsource: {baseURI}\nauthor: {byline}\ntitle: {pageTitle}\n—\n\n# {pageTitle}\n\n&gt; ## Excerpt\n&gt; {excerpt}\n\n—“,<br>  “headingStyle”: “atx”,<br>  “hr”: “</em>__”,<br>  “imagePrefix”: “{pageTitle}&#x2F;“,<br>  “imageRefStyle”: “inlined”,<br>  “imageStyle”: “base64”,<br>  “includeTemplate”: true,<br>  “linkReferenceStyle”: “full”,<br>  “linkStyle”: “inlined”,<br>  “mdClipsFolder”: null,<br>  “obsidianFolder”: “使用教程”,<br>  “obsidianIntegration”: true,<br>  “obsidianVault”: “obsidian”,<br>  “saveAs”: false,<br>  “strongDelimiter”: “**”,<br>  “title”: “{pageTitle}”,<br>  “turndownEscape”: true<br>}</p>]]></content>
    
    
    
    <tags>
      
      <tag>MARKDOWN</tag>
      
      <tag>插件下载</tag>
      
      <tag>插件设置</tag>
      
      <tag>CHROME</tag>
      
      <tag>写代码</tag>
      
      <tag>个人喜好</tag>
      
      <tag>浏览器</tag>
      
      <tag>网络搜寻</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka两种集群详解和搭建教程</title>
    <link href="/article/d6131b35.html"/>
    <url>/article/d6131b35.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" />Kafka是一个能够支持高并发以及流式消息处理的消息中间件，并且Kafka天生就是支持集群的，今天就主要来介绍一下如何搭建Kafka集群。<p>Kafka目前支持使用Zookeeper模式搭建集群以及KRaft模式（即无Zookeeper）模式这两种模式搭建集群，这两种模式各有各的好处，今天就来分别介绍一下这两种方式。</p><h2 id="1，Kafka集群中的节点类型"><a href="#1，Kafka集群中的节点类型" class="headerlink" title="1，Kafka集群中的节点类型"></a>1，Kafka集群中的节点类型</h2><p>我们首先需要了解一下，一个Kafka集群是由下列几种类型的节点构成的，它们充当着不同的作用：</p><ul><li><strong><code>Broker</code>节点</strong>：即<strong>代理节点</strong>，是Kafka中的工作节点，充当消息队列的角色，<strong>负责储存和处理消息</strong>，每个Broker都是一个独立的Kafka服务器，可以在不同的机器上运行，除此之外Broker还负责分区（partition）的管理，将主题（topic）划分为多个分区，并分布在集群的不同Broker上</li><li><strong><code>Controller</code>节点</strong>：即<strong>控制器节点</strong>，是集群中的特殊节点，负责储存和管理整个<strong>集群元数据</strong>和<strong>状态</strong>，它能够监控整个集群中的Broker，在需要时还能够进行平衡操作</li><li><strong>混合节点</strong>：即同时担任Broker和Controller节点角色的节点</li></ul><h2 id="2，两种模式集群的搭建方式"><a href="#2，两种模式集群的搭建方式" class="headerlink" title="2，两种模式集群的搭建方式"></a>2，两种模式集群的搭建方式</h2><p>接下来，我就来介绍一下两种模式的集群架构和搭建方式，即Zookeeper模式集群和KRaft模式集群。</p><h3 id="1-Zookeeper模式集群"><a href="#1-Zookeeper模式集群" class="headerlink" title="(1) Zookeeper模式集群"></a>(1) Zookeeper模式集群</h3><p>这是一种比较简单，相对“传统”的搭建方式了！在这种模式下，每个Kafka节点都是依赖于Zookeeper的，使用Zookeeper存储集群中所有节点的元数据。</p><p>只要所有的Kafka节点连接到<strong>同一个Zookeeper上面</strong>（或者同一个Zookeeper集群），<strong>这些Kafka节点就构成了一个集群</strong>。所以说就算是只有一个Kafka节点在运行，这一个节点也可以称作一个集群。</p><p>在Zookeeper模式集群中，Zookeeper节点（或者集群）就充当了Controller的角色，而所有的Kafka节点就充当着Broker的角色。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b59e81dddf064aa6af65004ab79fb081~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>下面就来介绍一下搭建过程，这里我在4台Linux虚拟机上分别运行Zookeeper和Kafka来模拟一个集群，一共一个Zookeeper节点和三个Kafka节点构成，如下：</p><table><thead><tr><th align="center">节点名</th><th align="center">地址和端口</th></tr></thead><tbody><tr><td align="center">Zookeeper节点</td><td align="center"><code>zookeeper:2181</code></td></tr><tr><td align="center">Kafka节点1</td><td align="center"><code>kafka1:9092</code></td></tr><tr><td align="center">Kafka节点2</td><td align="center"><code>kafka2:9092</code></td></tr><tr><td align="center">Kafka节点3</td><td align="center"><code>kafka3:9092</code></td></tr></tbody></table><p>上述地址例如<code>kafka1</code>等等，是通过修改虚拟机的主机名（hostname）实现的，这样虚拟机之间可以直接通过这些主机名相互访问，<strong>这个主机名我们就可以视作实际在服务器上面搭建时，服务器的外网地址或者域名</strong>，这里就不再赘述如何修改虚拟机的主机名了，需要保证上述所有虚拟机在一个虚拟机网段中并且能够互相<code>ping</code>通，即上述所有虚拟机需要两两之间可以通过网络互相访问。</p><p>运行Kafka和Zookeeper都需要Java 8及其以上运行环境，大家要首先在虚拟机中安装并配置好。</p><h4 id="①-搭建Zookeeper"><a href="#①-搭建Zookeeper" class="headerlink" title="① 搭建Zookeeper"></a>① 搭建Zookeeper</h4><p>首先我们要运行起一个Zookeeper节点，这里就不再赘述Zookeeper节点如何搭建了！搭建可以查看<a href="https://link.juejin.cn/?target=https://zookeeper.apache.org/doc/r3.8.1/zookeeperStarted.html" title="https://zookeeper.apache.org/doc/r3.8.1/zookeeperStarted.html">官方文档</a>，或者使用<a href="https://link.juejin.cn/?target=https://hub.docker.com/_/zookeeper" title="https://hub.docker.com/_/zookeeper">Docker的方式</a>搭建。</p><p>搭建完成并运行Zookeeper之后，我们会把所有的Kafka节点都配置到这一个Zookeeper节点上。</p><h4 id="②-配置并运行所有Kafka节点"><a href="#②-配置并运行所有Kafka节点" class="headerlink" title="② 配置并运行所有Kafka节点"></a>② 配置并运行所有Kafka节点</h4><p>首先去<a href="https://link.juejin.cn/?target=https://kafka.apache.org/downloads" title="https://kafka.apache.org/downloads">Kafka官网下载</a>最新版并解压，然后将解压出来的Kafka<strong>分别复制到三台虚拟机中</strong>。</p><p>然后修改<strong>每台虚拟机</strong>的Kafka目录中的配置文件，配置文件位于解压的Kafka文件夹中的<code>config/server.properties</code>，使用文本编辑器打开，并找到下列配置项进行配置：</p><ul><li><code>broker.id</code> 表示每个节点的<code>id</code>，<strong>每个节点需要设置为不一样的整数</strong>，我这里分别设置为<code>1</code>，<code>2</code>和<code>3</code></li><li><code>zookeeper.connect</code> 表示<strong>要使用的Zookeeper的地址和端口</strong>，我这里都配置为<code>zookeeper:2181</code></li><li><code>advertised.listeners</code> 表示<strong>这个Kafka节点的外网地址</strong>，这里分别配置为<code>PLAINTEXT://kafka1:9092</code>，<code>PLAINTEXT://kafka2:9092</code>和<code>PLAINTEXT://kafka3:9092</code>，需要注意的是这个配置项必须要配置为其所在服务器的外网地址，如果说你是在一台服务器上面配置Kafka并要通过外网访问，这个配置就需要配置为服务器外网地址（域名），并且都以<code>PLAINTEXT://</code>开头</li></ul><p>注意上述<code>advertised.listeners</code>这个配置项默认情况下是被注释掉了的，大家需要去仔细找一下并去掉注释（开头的<code>#</code>）然后再进行配置。</p><p>三台虚拟机配置完成后，分别使用终端进入到Kafka目录下并启动，执行下列命令：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-server-start.sh config/server.properties</code></p><p>在上述三台虚拟机上面都通过这个命令启动Kafka，如图则启动成功：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ea9ecb836134fd59d4ec003f01c9267~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>到此，整个集群就搭建完成了！大家需要保证上述三台虚拟机中的终端不被关闭。</p><h4 id="③-创建话题测试"><a href="#③-创建话题测试" class="headerlink" title="③ 创建话题测试"></a>③ 创建话题测试</h4><p>我们先在<code>kafka1</code>的虚拟机上面再开一个终端并进入Kafka目录，执行下列命令创建Topic：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-topics.sh --create --topic my-topic --bootstrap-server localhost:9092</code></p><p>然后去<code>kafka2</code>的虚拟机上面再开一个终端并进入Kafka目录，执行下列命令列出Topic：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-topics.sh --list --bootstrap-server localhost:9092</code></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/309a0e640f974307bb760ffd82963821~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>可见我们在第一个节点上创建了话题，但是在第二个节点上仍然可以获取这个话题，说明集群创建成功，数据在集群之间可以共享。</p><h3 id="2-KRaft模式集群"><a href="#2-KRaft模式集群" class="headerlink" title="(2) KRaft模式集群"></a>(2) KRaft模式集群</h3><p>在上述传统方案中，Kafka需要依赖Zookeeper完成元数据存放和共享，这样也就暴露出了一些问题：</p><ul><li>搭建Kafka集群时还需要额外搭建Zookeeper，增加了运维成本</li><li>Zookeeper是强一致性的组件（符合CP理论），如果集群中数据发生变化，那么必须要等到其它节点都同步，至少超过一半同步完成，这样节点数多性能差</li></ul><p>那么KRaft模式是新版本Kafka中推出的集群模式，这种模式下就完全不需要Zookeeper了！<strong>只需要数个Kafka节点就可以直接构成集群</strong>，在这时<strong>集群中的Kafka节点既有可能是Controller节点也可能是Broker节点</strong>，在这个模式中，我们不仅可以手动配置某个节点的角色（是Controller还是Broker），还可以使其同时担任Broker和Controller角色（混合节点）。</p><p>在KRaft模式中，集群的节点会通过<strong>投票选举</strong>的方式，选择出一个主要的Controller节点，这个节点也称作<strong>领导者</strong>，它将负责维护整个集群的元数据和状态信息，那么其它的Controller节点或者混合节点就称之为<strong>追随者</strong>，它们会从领导者同步集群元数据和状态信息。如果领导者宕机了，所有的节点会重新投票选举一个新的领导者。</p><p>在选举过程中，所有的节点都会参与投票过程，而候选节点只会是Controller节点或者混合节点（即Broker节点不会被选举为领导者）。</p><p>需要注意的是，在默认情况下Kafka集群中的Broker节点和Controller节点通常会监听不同的端口：</p><ul><li>Broker节点是Kafka集群中的数据节点（消息队列），它们负责接收客户端的消息和传递消息给客户端，默认情况下，每个Broker节点会监听<code>9092</code>端口，该端口用于与客户端进行通信，客户端可以将消息发送到这个端口，或者从这个端口接收消息，这个端口可以称作<strong>客户端通信端口</strong></li><li>Controller节点是Kafka集群中的控制器节点，负责管理集群的状态和元数据，Controller节点监听的端口通常是<code>9093</code>，该端口用于集群中其他节点获取元数据或在混合节点选举新的Controller时进行通信，通过该端口，其他节点可以与Controller节点交互，获取集群的元数据信息或参与控制器的选举过程，这个端口可以称作<strong>控制器端口</strong></li><li>混合节点（即同时担任Broker和Controller角色的节点）中，这两个端口都会被使用，默认情况下混合节点将监听<code>9092</code>端口接收和传递消息给客户端，并监听<code>9093</code>端口用于与其他节点进行元数据交换和控制器选举通信，可见混合节点会同时使用两个端口分别作为<strong>客户端通信端口</strong>与<strong>控制器端口</strong></li></ul><p>所以需要根据实际情况配置网络设置和防火墙规则，以确保Kafka集群中的节点能够在正确的端口上进行通信。上述提到的两种端口也是可以修改的，当然不建议修改。</p><p>同样地，就算是你只是搭建了一个Kafka节点，这一个节点也仍然被视为一个Kafka集群，并且KRaft模式下如果只需要建立一个节点，那么这个节点必须是混合节点。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fce47477bec44e28304e28243280e4e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>下面同样是开启三台虚拟机，搭建三个Kafka节点构成的KRaft模式集群如下：</p><table><thead><tr><th align="center">节点名</th><th align="center">地址</th><th align="center">节点类型</th><th align="center">客户端通信端口</th><th align="center">控制器端口</th></tr></thead><tbody><tr><td align="center">Kafka节点1</td><td align="center"><code>kafka1</code></td><td align="center">混合节点</td><td align="center"><code>9092</code></td><td align="center"><code>9093</code></td></tr><tr><td align="center">Kafka节点2</td><td align="center"><code>kafka2</code></td><td align="center">混合节点</td><td align="center"><code>9092</code></td><td align="center"><code>9093</code></td></tr><tr><td align="center">Kafka节点3</td><td align="center"><code>kafka3</code></td><td align="center">混合节点</td><td align="center"><code>9092</code></td><td align="center"><code>9093</code></td></tr></tbody></table><p>这里就不再赘述下载Kafka的过程了！</p><h4 id="①-修改配置文件"><a href="#①-修改配置文件" class="headerlink" title="① 修改配置文件"></a>① 修改配置文件</h4><p>在KRaft模式下，配置文件位于Kafka目录中的<code>config/kraft/server.properties</code>，使用文本编辑器打开并找到下列配置以修改：</p><ul><li><code>node.id</code> 表示这个**节点的<code>id</code>**，一个集群中每个节点<code>id</code>不能重复，需要是不小于<code>1</code>的整数，这里三台虚拟机的配置分别为<code>1</code>，<code>2</code>和<code>3</code>（类似上述Zookeeper的<code>broker.id</code>配置）</li><li><code>controller.quorum.voters</code> 设定<strong>投票者列表</strong>，即需要<strong>配置所有的Controller节点<code>id</code>及其地址端口</strong>，配置格式为<code>节点1的id@节点1地址:节点1端口,节点2的id@节点2地址:节点2端口,节点3的id@节点3地址:节点3端口...</code>，这里的端口需要是<strong>控制器端口</strong>，默认都是<code>9093</code>，上面也提到过了，默认不需要修改，我这里三台虚拟机的都配置为<code>1@kafka1:9093,2@kafka2:9093,3@kafka3:9093</code>（实际在服务器上搭建时替换为服务器的外网地址或者域名）</li><li><code>advertised.listeners</code> 表示<strong>这个Kafka节点的外网地址</strong>，这里分别配置为<code>PLAINTEXT://kafka1:9092</code>，<code>PLAINTEXT://kafka2:9092</code>和<code>PLAINTEXT://kafka3:9092</code>（和上述Zookeeper模式中的一样，实际在服务器上搭建时替换为服务器的外网地址或者域名）</li></ul><p>上述是必须要进行配置的，还有下面配置是可以选择性配置的：</p><ul><li><code>process.roles</code> 表示设定这个<strong>节点的类型</strong>，设定为<code>broker</code>表示设定这个节点为Broker节点，同样地设定<code>controller</code>表示设定为Controller节点，默认是<code>broker,controller</code>表示这个节点会自动切换节点类型，这里先保持默认不变，下面再来详细讨论</li></ul><h4 id="②-生成集群ID并使用集群ID格式化数据目录"><a href="#②-生成集群ID并使用集群ID格式化数据目录" class="headerlink" title="② 生成集群ID并使用集群ID格式化数据目录"></a>② 生成集群ID并使用集群ID格式化数据目录</h4><p>在KRaft模式下，一个集群需要设定一个<code>id</code>，我们可以使用自带的命令生成，先进入上述任意一台虚拟机并使用终端进入Kafka目录中，执行下列命令生成一个UUID：</p><p>arduino</p><p>复制代码</p><p><code>bin/kafka-storage.sh random-uuid</code></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2db785f21f7041f597aa1c70088f828a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image.png"></p><p>我们这里记录下这个ID以备用。</p><blockquote><p>这个集群ID事实上是一个长度16位的字符串通过Base64编码后得来的，因此你也可以不使用上述命令，直接自定义一个16位长度的纯英文和数字组成的字符串，然后将这个字符串编码为Base64格式作为这个集群ID也可以。可以使用<a href="https://link.juejin.cn/?target=https://c.runoob.com/front-end/693/" title="https://c.runoob.com/front-end/693/">菜鸟工具</a>中的在线Base64编码工具。</p></blockquote><p>然后在上述三台虚拟机中，都使用终端进入Kafka目录后，执行下列命令：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-storage.sh format -t 生成的集群ID -c config/kraft/server.properties</code></p><p>这样，三个Kafka节点都使用了这一个ID完成了集群元数据配置，表示这三个Kafka节点构成一个集群。</p><h4 id="③-启动Kafka"><a href="#③-启动Kafka" class="headerlink" title="③ 启动Kafka"></a>③ 启动Kafka</h4><p>同样地，在三台虚拟机中，都使用终端进入Kafka目录后，执行下列命令：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-server-start.sh config/kraft/server.properties</code></p><p>三台虚拟机全部启动后，这个集群才启动完毕。</p><h4 id="④-创建话题测试"><a href="#④-创建话题测试" class="headerlink" title="④ 创建话题测试"></a>④ 创建话题测试</h4><p>同样地，现在第一个虚拟机的Kafka目录下执行下列命令：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-topics.sh --create --topic my-topic-kraft --bootstrap-server localhost:9092</code></p><p>然后在第二个虚拟机的Kafka目录下查看话题：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-topics.sh --list --bootstrap-server localhost:9092</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2753c5435163415eb7f62c7694f9221f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="image-20230612212505591"></p><p>可见集群节点之间可以互相通信。</p><blockquote><p>无论是在虚拟机还是服务器上，都要保证<code>9092</code>和<code>9093</code>端口开放，且所有虚拟机&#x2F;服务器之间都能够两两互相访问（网络连通）！</p></blockquote><h2 id="3，重要配置介绍"><a href="#3，重要配置介绍" class="headerlink" title="3，重要配置介绍"></a>3，重要配置介绍</h2><p>无论是那种模式的集群，我们都涉及到了许多配置项，大家通过上述的搭建示例也能够了解到每个配置项的意义，这里就专门来着重介绍一下，Kafka中一些重要的配置项。</p><h3 id="1-listeners"><a href="#1-listeners" class="headerlink" title="(1) listeners"></a>(1) <code>listeners</code></h3><p>这个配置项用于<strong>指定Kafka服务器监听客户端连接的地址和端口</strong>，当 Kafka 服务器启动时，它将监听<code>listeners</code>配置项中指定的地址和端口，等待客户端的连接请求。</p><p>一般情况下这个配置以<code>PLAINTEXT://</code>或者<code>CONTROLLER://</code>开头，意义如下：</p><ul><li>若这个节点是Broker节点，则以<code>PLAINTEXT://</code>开头</li><li>若这个节点是Controller节点，则以<code>CONTROLLER://</code>开头</li><li>若这个节点是混合节点，则需要同时配置两者开头的地址</li></ul><p>这个配置项<strong>通常不需要修改</strong>，下面给出几个配置示例：</p><ul><li><code>PLAINTEXT://:9092</code> 本节点作为Broker节点，监听本机<strong>所有可用网卡</strong>的<code>9092</code>端口（使用<code>9092</code>端口作为<strong>客户端通信端口</strong>），也是默认配置</li><li><code>PLAINTEXT://127.0.0.1:9092</code> 本节点作为Broker节点，监听本地的<code>9092</code>端口，这样仅接受来自本地的请求</li><li><code>CONTROLLER://:10000</code> 本节点作为Controller节点，监听本机<strong>所有可用网卡</strong>的<code>10000</code>端口（使用<code>10000</code>端口作为<strong>控制器端口</strong>）</li><li><code>PLAINTEXT://:9092,CONTROLLER://:9093</code> 本节点作为混合节点，监听本机<strong>所有可用网卡</strong>的<code>9092</code>和<code>9093</code>端口，其中<code>9092</code>作为<strong>客户端通信端口</strong>，<code>9093</code>作为<strong>控制器端口</strong></li></ul><h3 id="2-advertise-listeners"><a href="#2-advertise-listeners" class="headerlink" title="(2) advertise.listeners"></a>(2) <code>advertise.listeners</code></h3><p>这个配置容易和<code>listeners</code>混淆，事实上它们是有较大的区别的。</p><p>该配置项指定Kafka服务器<strong>广播给客户端的地址和端口</strong>，通常配置为<strong>Kafka所在服务器的外网地址</strong>。</p><p>当客户端（生产者或消费者）尝试连接到Kafka服务器时，它首先会获取Kafka服务器广播的地址和端口，也就是<code>advertise.listeners</code>配置所指定的地址和端口，然后才会使用<code>advertise.listeners</code>配置所指定的地址和端口来建立与Kafka服务器的连接。</p><p>相信这时大家会有个疑问：既然客户端要连接Kafka（例如Spring Boot集成Kafka客户端），那一定是已经知道了Kafka对外的地址端口了，那为什么连接的时候还需要获取一下广播的地址端口再进行连接呢？这样是不是有一些多此一举？</p><p>事实上，Kafka设计这个配置是为了解决下面较为复杂的网络场景：</p><ul><li><strong>多网络接口的主机部署</strong>：在一个多网络接口的主机部署Kafka时，Kafka服务器可能会监听多个地址和端口，这些地址和端口可能与客户端实际访问的地址和端口不同，<code>advertise.listeners</code>允许服务器指定一个公开的、可访问的地址和端口，以便客户端能够正确连接</li><li><strong>NAT&#x2F;代理环境</strong>：在某些网络环境下，Kafka服务器位于一个私有网络中，客户端位于一个公共网络中，两者之间可能存在网络地址转换（NAT）或代理，在这种情况下，Kafka服务器的内部地址和端口对客户端来说是不可访问的。通过使用<code>advertise.listeners</code>，Kafka服务器可以将一个公共地址和端口广播给客户端，使得客户端能够通过公共网络连接到服务器</li><li><strong>容器环境</strong>：例如你把Kafka放在Docker容器中运行，按照默认配置，Kafka服务端只会监听容器网络的<code>9092</code>端口，我们知道外部不能直接访问容器的网络，而是需要使用网络映射，假设你把Kafka容器的<code>9092</code>端口映射至了宿主机<code>9095</code>端口，也就是说外部需要通过<code>9095</code>端口访问到Kafka容器的<code>9092</code>端口，那么你就配置<code>advertise.listeners</code>为<code>PLAINTEXT://服务器外网地址:9095</code>，客户端就可以正确访问容器中的Kafka了</li></ul><p>总之，这个配置设置为<strong>Kafka服务器所在的外网地址即可</strong>！例如<code>PLAINTEXT://69.54.112.239:9092</code>。</p><h3 id="3-process-roles"><a href="#3-process-roles" class="headerlink" title="(3) process.roles"></a>(3) <code>process.roles</code></h3><p>这是KRaft模式下专门的配置，用于配置这个节点的类型，可以配置为下列值：</p><ul><li><code>broker</code> 表示这个节点是Broker节点，充当消息队列的角色</li><li><code>controller</code> 表示这个节点是Controller节点，充当元数据存放和管理的角色</li><li><code>broker,controller</code> 表示这个节点同时担任Broker和Controller的角色，也称作<strong>混合节点</strong></li></ul><p>如果没有配置这个选项，则Kafka会以Zookeeper模式运行。</p><p>这里有下列注意事项：</p><ul><li>如果设定节点为<code>controller</code>：<ul><li>则<strong>不能</strong>配置<code>advertised.listeners</code>，可以将其注释掉或者删掉</li><li><code>listeners</code>需要配置为<code>CONTROLLER://</code>开头，建议配置为<code>CONTROLLER://:9093</code></li></ul></li><li>如果设定节点为<code>broker</code>：<ul><li>则需要配置<code>advertised.listeners</code>为服务器外网地址和端口，这和Zookeeper模式中相同</li><li><code>listeners</code>需要配置为<code>PLAINTEXT://</code>开头，建议配置为<code>PLAINTEXT://:9092</code></li></ul></li><li>如果设定节点为混合节点：<ul><li>同样需要配置<code>advertised.listeners</code>为服务器外网地址和端口</li><li><code>listeners</code>需要同时配置<code>CONTROLLER://</code>和<code>PLAINTEXT://</code>，建议配置为<code>PLAINTEXT://:9092,CONTROLLER://:9093</code></li></ul></li></ul><p>在开发环境或者小规模集群，可以全部使用混合节点，如果是生产环境就建议设定好每个节点的类型了！并且通常需要先启动Controller节点再启动Broker节点。</p><blockquote><p>事实上，我们发现Kafka的KRaft配置目录<code>config/kraft</code>下有三个配置文件，其中<code>server.properties</code>是混合节点的配置模板，而<code>broker.properties</code>和<code>controller.properties</code>分别是Broker节点和Controller节点的配置模板，大家如果要设定节点类型，可以直接使用对应的配置文件，将对应配置文件需要修改的部分修改一下，然后将上述格式化数据目录命令和启动命令中的配置文件路径改变一下即可，这样可以省略我们设定<code>process.roles</code>和<code>listeners</code>或者控制器节点删除<code>advertise.listeners</code>配置的操作。</p></blockquote><h3 id="4-controller-quorum-voters"><a href="#4-controller-quorum-voters" class="headerlink" title="(4) controller.quorum.voters"></a>(4) <code>controller.quorum.voters</code></h3><p>该配置项用于配置集群中Controller节点选举过程中的投票者，集群中<strong>所有的Controller节点都需要被罗列在这个配置项中</strong>，其配置格式为<code>id1@host1:port1,id2@host2:port2,id3@host3:port3...</code>。</p><p>有的同学可能认为这里需要把集群中<strong>所有节点</strong>都写进去，事实上这是错误的，这里只需要写<strong>所有的Controller节点和混合节点</strong>的<code>id</code>、地址和端口即可，这个配置中配置的端口当然是<strong>控制器端口</strong>。</p><p>上述集群搭建的例子中，由于所有的节点都是混合节点，因此就全部写在其中了！如果我们手动设定每个节点的类型，例如：</p><table><thead><tr><th align="center">节点名</th><th align="center">节点<code>id</code></th><th align="center">地址</th><th align="center">服务器通信端口</th><th align="center">控制器端口</th><th align="center">节点类型</th></tr></thead><tbody><tr><td align="center">Kafka节点1</td><td align="center"><code>1</code></td><td align="center"><code>kafka1</code></td><td align="center">&#x2F;</td><td align="center"><code>9093</code></td><td align="center">Controller</td></tr><tr><td align="center">Kafka节点2</td><td align="center"><code>2</code></td><td align="center"><code>kafka2</code></td><td align="center"><code>9092</code></td><td align="center">&#x2F;</td><td align="center">Broker</td></tr><tr><td align="center">Kafka节点3</td><td align="center"><code>3</code></td><td align="center"><code>kafka3</code></td><td align="center"><code>9092</code></td><td align="center">&#x2F;</td><td align="center">Broker</td></tr></tbody></table><p>那么所有节点的<code>controller.quorum.voters</code>都需要配置为<code>1@kafka1:9093</code>。</p><p>事实上，所有的节点都是通过这个配置中的节点列表，来得知所有的控制器节点信息（以获取集群元数据）并得到投票候选者的，因此集群中所有节点，不论是Broker还是Controller，还是混合节点，都需要配置这一项。</p><h3 id="5-其它配置"><a href="#5-其它配置" class="headerlink" title="(5) 其它配置"></a>(5) 其它配置</h3><p>除了上述我们涉及到的一些配置之外，还有下列配置大家可以进行修改：</p><ul><li><code>socket.send.buffer.bytes</code> 每次发送的数据包的最大大小（单位：字节）</li><li><code>socket.receive.buffer.bytes</code> 每次接收的数据包的最大大小（单位：字节）</li><li><code>socket.request.max.bytes</code> 接收的最大请求大小（单位：字节）</li><li><code>num.partitions</code> 每个<code>Topic</code>的默认分区数</li></ul><p>上述无论是哪个模式的集群，都可以在配置文件中找到这些配置，如果找不到可手动加入。除了修改配置文件之外，我们还可以在启动Kafka的命令中指定配置和值，例如：</p><p>bash</p><p>复制代码</p><p><code>bin/kafka-server-start.sh config/server.properties --override zookeeper.connect=127.0.0.1:2181 --override broker.id=1</code></p><p>上述命令在启动时通过命令指定了<code>zookeeper.connect</code>配置值为<code>127.0.0.1:2181</code>，以及<code>broker.id</code>为<code>1</code>，可见在后面追加<code>--override 配置名=值</code>即可，注意命令行中指定的配置值会覆盖掉配置文件中的配置值！</p><h2 id="4，总结"><a href="#4，总结" class="headerlink" title="4，总结"></a>4，总结</h2><p>本文介绍了Kafka的两种集群模式结构及其搭建方式，其中一些概念尤其是KRaft模式可能需要大家多读几遍，并结合实际操作才能明白。</p><p>参考文档：</p><ul><li>Kafka快速开始：<a href="https://link.juejin.cn/?target=https://kafka.apache.org/quickstart" title="https://kafka.apache.org/quickstart">传送门</a></li><li>Kafka所有配置：<a href="https://link.juejin.cn/?target=https://kafka.apache.org/documentation/%23configuration" title="https://kafka.apache.org/documentation/#configuration">传送门</a></li><li>KRaft模式集群配置：<a href="https://link.juejin.cn/?target=https://kafka.apache.org/documentation/%23kraft" title="https://kafka.apache.org/documentation/#kraft">传送门</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis6.0+版本修改密码无效</title>
    <link href="/article/2bab8fa4.html"/>
    <url>/article/2bab8fa4.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><meta name="referrer" content="no-referrer" /><p>1、问题描述<br>在搭建redis主从集群的时候，一直出现密码问题，之前设置的是默认密码123456.后来发现即使修改了默认密码之后密码还是需要写原来的才能登入，甚至注释requirepass后，还是需要123456的密码。<br>看了很多文章，要么没法解决，要么下次登入后还是一样的问题，不是一次性能解决的<br>2、解决方案：</p><p>修改redis.conf 中的 user default on nopass ~* &amp;* +@all<br>注意默认改成这个nopass！！！<br>没改之前是一长串加密的东西，我猜就是123456，改成nopass，或者改成自己特定的密码，或者直接删除generated by config rewrite 下面这些东西，问题解决！</p><p>3、成功无密码登入<br>先看一下线程 ps aux | grep redis ,查出号码后kill，重启一下redis（也重启下xshell），大功告成！！</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL实现多个模糊查询和删除指令</title>
    <link href="/article/c7577f7f.html"/>
    <url>/article/c7577f7f.html</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL实现多个模糊查询和删除指令"><a href="#MySQL实现多个模糊查询和删除指令" class="headerlink" title="MySQL实现多个模糊查询和删除指令"></a>MySQL实现多个模糊查询和删除指令</h1><p>MySQL单表多字段模糊查询的是指实现在单表中对多字段进行多个关键字的模糊查询</p><p>查询不存在某些关键词的记录指令：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">select \* from \`表名\` where \`字段名\` not regexp <span class="hljs-emphasis">&#x27;关键词1|关键词2|关键词3&#x27;</span>;<br></code></pre></td></tr></table></figure><p>查询存在某些关键词的记录指令：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br>select \* from \`表名\` where \`字段名\` regexp <span class="hljs-emphasis">&#x27;关键词1|关键词2|关键词3&#x27;</span>;<br></code></pre></td></tr></table></figure><p>删除不包含指定关键词的记录指令：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-string">\`表\`</span> where <span class="hljs-string">\`字段\`</span>  <span class="hljs-keyword">not</span> like <span class="hljs-string">&#x27;%关键词%&#x27;</span><br></code></pre></td></tr></table></figure><p>删除包含指定关键词的记录指令：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> \`表\` <span class="hljs-keyword">where</span> \`字段\` <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%关键词1%&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%关键词2%&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%关键词3%&#x27;</span><br></code></pre></td></tr></table></figure><p>AND  </p><p>MySQL单表多字段模糊查询也可以通过下面这个SQL查询实现</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">SELECT \* FROM \`magazine\` WHERE CONCAT(\`title\`,\`tag\`,\`description\`) LIKE ‘%关键字%’<br></code></pre></td></tr></table></figure><p>但是这样有个问题，如果这三个字段中有值为NULL，则返回的也是NULL，那么这一条记录可能就会被错过，那么要用IFNULL进行判断，则sql改为：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">SELECT</span> \* FROM \<span class="hljs-string">`magazine\`</span> <span class="hljs-keyword">WHERE</span> CONCAT(IFNULL(\<span class="hljs-string">`title\`</span>,<span class="hljs-string">&#x27;&#x27;</span>),IFNULL(\<span class="hljs-string">`tag\`</span>,<span class="hljs-string">&#x27;&#x27;</span>),IFNULL(\<span class="hljs-string">`description\`</span>,<span class="hljs-string">&#x27;&#x27;</span>)) LIKE ‘%关键字%’<br><br></code></pre></td></tr></table></figure><p> 类似于如此则可以进行简单的多字段模糊搜索了。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql转sqllite数据表</title>
    <link href="/article/c7875919.html"/>
    <url>/article/c7875919.html</url>
    
    <content type="html"><![CDATA[<h2 id="mysql怎么转换为sqlite"><a href="#mysql怎么转换为sqlite" class="headerlink" title="mysql怎么转换为sqlite"></a>mysql怎么转换为sqlite</h2><p>需要先安装工具：Navicat Premium （支持MySQL、Oracle、PostgreSQL、SQLite 及 SQL Serve 的数据库管理工具）</p><p><strong>第一步：先把mysql导出成txt文件</strong></p><p>记住“包含列表的标题” 复选框要勾选， 否则生成的txt没有键。</p><p><strong>第二步：打开 Navicate Premium ，新建SQLite 连接</strong></p><p><img src="https://img.php.cn/upload/image/505/834/242/1652953790978024.png" alt="10.png" title="1652953790978024.png"></p><p>这里的数据库文件是用来存储数据的文件，可以直接用记事本新建一个后最为db 的文件。</p><p><img src="https://img.php.cn/upload/image/747/724/546/1652953838356473.png" alt="31.png" title="1652953838356473.png"></p><p><strong>第三步、把第一步导出的txt文件导入到第二步新建的SQLite数据库中</strong></p><p>点击表，右键“导入向导”，选择“文本文件”，然后一路下一步就可以了。</p><p><img src="https://img.php.cn/upload/image/635/713/577/1652953857746636.png" alt="32.png" title="1652953857746636.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>sqllite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xxl-job知识点</title>
    <link href="/article/65a98f40.html"/>
    <url>/article/65a98f40.html</url>
    
    <content type="html"><![CDATA[<p> 最近对分布式任务调度系统比较感兴趣，于是了解了下网上的开源项目。</p><p>发现有一个国内的开源项目xxl-job写的还不错，开源代码比较简单易懂的、文档也比较齐全。</p><p>首先是xxl-job系统的架构介绍：</p><p><img src="https://pic4.zhimg.com/v2-70a6d9e0c3c658a7e10376666130d763_r.jpg"></p><p>xxl-job就是一个中心化管理系统，系统主要通过MySQL管理各种定时任务信息，当到了定时任务的触发时间，就把任务信息从db中拉进内存，对任务执行器发起触发请求。这个任务执行器，既可以是bean、groovy脚本、python脚本等，也可以是外部的http接口。</p><p>相比起当当网开源的elastic-job-lite（基于zookeeper作为协调器的“无中心”架构），这种中心化管理的系统其实更简单、易于维护。</p><p>下面核心介绍下我感兴趣的几个特性的实现原理：</p><p><strong>1、定时触发任务是如何实现的？：使用时间轮实现</strong></p><ul><li><p>xxl_job_info表是记录定时任务的db表，里面有个trigger_next_time（Long）字段，表示下一次触发的时间点</p></li><li><p>任务时间被修改 &#x2F; 每一次任务触发后，可以根据cronb表达式计算下一次触发时间戳：Date nextValidTime &#x3D; new CronExpression(jobInfo.getJobCron()).getNextValidTimeAfter(new Date())），更新trigger_next_time字段</p></li><li><p>定时执行任务逻辑：</p></li><li><p>定时任务scheduleThread：不断从db把5秒内要执行的任务读出，立即触发 &#x2F; 放到时间轮等待触发，并更新trigger_next_time</p></li><li><p>获取当前时间now</p></li><li><p>轮询db，找出trigger_next_time在距now 5秒内的任务</p></li><li><p>（0）对到达now时间后的任务（超出now 5秒外）：</p></li><li><p>直接跳过不执行；</p></li><li><p>重置trigger_next_time</p></li><li><p>（1）对到达now时间后的任务（超出now 5秒内）：</p></li><li><p>开线程执行触发逻辑；</p></li><li><p>若任务下一次触发时间是在5秒内，则放到时间轮内（Map&lt;Integer, List<Integer>&gt; 秒数(1-60) &#x3D;&gt; 任务id列表）；</p></li><li><p>重置trigger_next_time</p></li><li><p>（2）对未到达now时间的任务：</p></li><li><p>直接放到时间轮内；</p></li><li><p>重置trigger_next_time</p></li><li><p>定时任务ringThread：时间轮实现到点触发任务</p></li><li><p>时间轮数据结构：Map&lt;Integer, List<Integer>&gt; key是秒数(1-60) ，value是任务id列表</p></li></ul><p><img src="https://pic1.zhimg.com/80/v2-7e9f3e0f1e561c5d02c364d6d48545c0_720w.webp"></p><ul><li>获取当前时间秒数</li><li>从时间轮内移出当前秒数前2个秒数（避免处理耗时太长，跨过刻度，向前校验一个刻度）的任务列表id，一一触发任务；</li></ul><p><strong>2、当xxl-job应用本身集群部署（实现高可用HA）时，如何避免集群中的多个服务器同时调度任务？：通过mysql悲观锁实现分布式锁（for update语句）</strong></p><ul><li>setAutoCommit(false)关闭隐式自动提交事务，启动事务</li><li>select lock for update（显式排他锁，其他事务无法进入&amp;无法实现for update）</li><li>读db任务信息 -&gt; 拉任务到内存时间轮 -&gt; 更新db任务信息</li><li>commit提交事务，同时会释放for update的排他锁（悲观锁）</li></ul><p><strong>3、任务执行器注册中心是如何实现的？</strong></p><ul><li>使用db表xxl_job_group记录下执行器的信息：执行器AppName、执行器名称title、执行器地址列表address_list(多地址逗号分隔)</li></ul><p><strong>4、如何实现任务执行器的路由？</strong></p><ul><li><p>执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</p></li><li><p><strong>第一个、最后一个、轮询、随机</strong>：都是简单读address_list即可</p></li><li><p><strong>一致性HASH</strong>：TreeSet实现一致性hash算法</p></li><li><p><strong>最不经常使用、最近最久未使用</strong>：HashMap、LinkedHashMap</p></li><li><p><strong>故障转移</strong>：遍历address_list获取address时，逐个检查该address的心跳（请求返回状态）；只有心跳正常的address才返回使用</p></li><li><p><strong>忙碌转移</strong>：遍历address_list获取address时，逐个检查该address是否忙碌（请求返回状态）；只有状态为idle的address才返回使用</p></li></ul><p><strong>5、如何实现任务分片、并行执行？</strong></p><ul><li>拉出任务的执行机器列表，逐个设置index &#x2F; total，把index &#x2F; total分发到任务执行器</li><li>任务执行器可根据index &#x2F; total参数开发分片任务</li></ul><p>其他更多特性，可以自行查看代码。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>xxl-job</tag>
      
      <tag>定时任务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis集群操作命令</title>
    <link href="/article/27010637.html"/>
    <url>/article/27010637.html</url>
    
    <content type="html"><![CDATA[<h2 id="redis集群操作"><a href="#redis集群操作" class="headerlink" title="redis集群操作"></a>redis集群操作</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//集群(cluster)  </span><br><br>　　<span class="hljs-built_in">CLUSTER</span> INFO 打印集群的信息  <br><br>　　<span class="hljs-built_in">CLUSTER</span> NODES 列出集群当前已知的所有节点（node），以及这些节点的相关信息。   <br><br>　　<span class="hljs-comment">//节点(node)  </span><br><br>　　<span class="hljs-built_in">CLUSTER</span> MEET &lt;ip&gt; &lt;port&gt; 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> FORGET &lt;node_id&gt; 从集群中移除 node_id 指定的节点。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> REPLICATE &lt;node_id&gt; 将当前节点设置为 node_id 指定的节点的从节点。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> SAVECONFIG 将节点的配置文件保存到硬盘里面。   <br><br>　　<span class="hljs-comment">//槽(slot)  </span><br><br>　　<span class="hljs-built_in">CLUSTER</span> ADDSLOTS &lt;slot&gt; [slot ...] 将一个或多个槽（slot）指派（<span class="hljs-keyword">assign</span>）给当前节点。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> DELSLOTS &lt;slot&gt; [slot ...] 移除一个或多个槽对当前节点的指派。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> SETSLOT &lt;slot&gt; NODE &lt;node_id&gt; 将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> SETSLOT &lt;slot&gt; MIGRATING &lt;node_id&gt; 将本节点的槽 slot 迁移到 node_id 指定的节点中。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> SETSLOT &lt;slot&gt; IMPORTING &lt;node_id&gt; 从 node_id 指定的节点中导入槽 slot 到本节点。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> SETSLOT &lt;slot&gt; STABLE 取消对槽 slot 的导入（import）或者迁移（migrate）。   <br><br>　　<span class="hljs-comment">//键 (key)  </span><br><br>　　<span class="hljs-built_in">CLUSTER</span> KEYSLOT &lt;key&gt; 计算键 key 应该被放置在哪个槽上。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> COUNTKEYSINSLOT &lt;slot&gt; 返回槽 slot 目前包含的键值对数量。  <br><br>　　<span class="hljs-built_in">CLUSTER</span> GETKEYSINSLOT &lt;slot&gt; &lt;count&gt; 返回 count 个 slot 槽中的键。  <br></code></pre></td></tr></table></figure><p> <strong>Redis增加删除（伸缩）节点操作步骤.</strong></p><blockquote><p><strong><code>说明：</code></strong></p><ol><li>由于是练习，所以设置的是同一台服务器多个redis实例来操作的redis集群。所以下面的步骤是基于这个来做的。如果是不同的服务器步骤稍微有一点的区别。</li><li>Redis版本是6.2.6版本</li><li>如果有密码，必须保证所有实例的密码一致。</li><li>事先准备好了3主3从6个redis实例。</li></ol></blockquote><!--toc--><h2 id="一、-增加节点"><a href="#一、-增加节点" class="headerlink" title="一、 增加节点"></a>一、 增加节点</h2><p><strong>主要分两种情况</strong></p><ol><li>增加节点是主节点</li><li>增加节点是从节点</li></ol><h3 id="1、增加节点是主节点"><a href="#1、增加节点是主节点" class="headerlink" title="1、增加节点是主节点"></a>1、增加节点是主节点</h3><p><strong>需求：增加7004主节点，如果需求需要包含某个值或者某些值一并移动到新节点去，那么就需要找到移动的值的最大散列插槽的值。步骤如下：</strong></p><ol><li><strong>首先创建（复制）一个redis.conf文件。</strong>（我的是放在一个文件夹下面的，所以就直接复制文件夹了）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> ./redis7001 -r  ./redis7004<br><br></code></pre></td></tr></table></figure><p><strong><code>参数说明：</code></strong></p><ul><li><code>cp:</code>复制命令。</li><li><code>-r:</code>递归复制整个文件夹。忽略redis7004这个这个目录是否存在，没有就创建一个新的文件夹（目录）。</li></ul><ol start="2"><li><strong>修改复制的文件端口号，日志文件地址名字，还有RDB文件名（万一后期自动选举成主节点了呢）等必要的信息。</strong></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#全局搜索文件.<span class="hljs-regexp">/redis7004/</span>conf/redis.conf的所有<span class="hljs-number">7001</span>改成<span class="hljs-number">7004</span>。<br>sed -i s<span class="hljs-regexp">/7001/</span><span class="hljs-number">7004</span><span class="hljs-regexp">/g ./</span>redis7004<span class="hljs-regexp">/conf/</span>redis.conf <br><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>启动服务。</strong></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-server <span class="hljs-regexp">/www/</span>server<span class="hljs-regexp">/redis/</span>redis7004<span class="hljs-regexp">/conf/</span>redis.conf <br><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>将7004节点添加到我们的集群节点中。</strong></li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#1.命令：old_ip只要是集群中的任意一个ip即可</span><br>redis-cli -a [password] --cluster<span class="hljs-built_in"> add-node </span>[new_ip] [old_ip]<br><span class="hljs-comment">#2.例子</span><br>redis-cli -a 123456 --cluster<span class="hljs-built_in"> add-node </span>127.0.0.1:7004 127.0.0.1:7001<br><br></code></pre></td></tr></table></figure><ol start="5"><li><strong>查看是否添加到集群中成功。</strong></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#1</span>.命令<br>redis-cli -<span class="hljs-selector-tag">a</span> <span class="hljs-selector-attr">[password]</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-selector-attr">[ip]</span> cluster nodes<br>#查看集群的命令<br>redis-cli <span class="hljs-attr">--cluster</span> help<br><span class="hljs-selector-id">#2</span>.例子<br>redis-cli -<span class="hljs-selector-tag">a</span> <span class="hljs-number">123456</span> -<span class="hljs-selector-tag">p</span> <span class="hljs-number">7004</span> cluster nodes<br><br></code></pre></td></tr></table></figure><ol start="6"><li><strong>分配散列槽</strong></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#1.命令</span><br>redis-cli -a [password] --cluster reshard [new_ip]<br><span class="hljs-comment">#2.例子</span><br>redis-cli -a <span class="hljs-number">123456</span> --cluster reshard <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span><br>[root@T98899999 redis]<span class="hljs-comment"># redis-cli -a 123456 --cluster reshard 127.0.0.1:7004</span><br>Warning: Using a password with &#x27;-a&#x27; <span class="hljs-keyword">or</span> &#x27;-u&#x27; option on the command line interface may not be safe.<br>&gt;&gt;&gt; Performing Cluster Check (using <span class="hljs-keyword">node</span> <span class="hljs-title">127</span>.<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004</span>)<br>M: <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-keyword">master</span><br><span class="hljs-title">S</span>: c836695daad38bcea59eb71dece7f860eab5f15e <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8003</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-literal">slave</span><br>   replicates <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06<br>S: <span class="hljs-number">633546</span>d3d75199e202d66ac56bca7e4c387bb453 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8002</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-literal">slave</span><br>   replicates <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br>M: <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span><br>   slots:[<span class="hljs-number">0</span>-<span class="hljs-number">5460</span>] (<span class="hljs-number">5461</span> slots) <span class="hljs-keyword">master</span><br>   <span class="hljs-title">1</span> additional replica(s)<br>M: <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7002</span><br>   slots:[<span class="hljs-number">5461</span>-<span class="hljs-number">10922</span>] (<span class="hljs-number">5462</span> slots) <span class="hljs-keyword">master</span><br>   <span class="hljs-title">1</span> additional replica(s)<br>S: e236e0ec685118abc67da92ad67c2db4b3f1abc6 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8001</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-literal">slave</span><br>   replicates <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25<br>M: <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7003</span><br>   slots:[<span class="hljs-number">10923</span>-<span class="hljs-number">16383</span>] (<span class="hljs-number">5461</span> slots) <span class="hljs-keyword">master</span><br>   <span class="hljs-title">1</span> additional replica(s)<br>[OK] All nodes agree about slots configuration.<br>&gt;&gt;&gt; Check for open slots...<br>&gt;&gt;&gt; Check slots coverage...<br>[OK] All <span class="hljs-number">16384</span> slots covered.<br>How many slots do you want to move (from <span class="hljs-number">1</span> to <span class="hljs-number">16384</span>)? <span class="hljs-number">100</span><br>What is the receiving <span class="hljs-keyword">node</span> <span class="hljs-title">ID</span>? <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7<br>Please enter all the source <span class="hljs-keyword">node</span> <span class="hljs-title">IDs</span>.<br>  <span class="hljs-keyword">Type</span> &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.<br>  <span class="hljs-keyword">Type</span> &#x27;done&#x27; once you entered all the source nodes IDs.<br>Source <span class="hljs-keyword">node</span> <span class="hljs-title">#1</span>: <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br>Source <span class="hljs-keyword">node</span> <span class="hljs-title">#2</span>: done<br>Ready to move <span class="hljs-number">100</span> slots.<br>  Source nodes:<br>    M: <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span><br>       slots:[<span class="hljs-number">0</span>-<span class="hljs-number">5460</span>] (<span class="hljs-number">5461</span> slots) <span class="hljs-keyword">master</span><br>       <span class="hljs-title">1</span> additional replica(s)<br>  Destination <span class="hljs-keyword">node</span><span class="hljs-title">:</span><br><span class="hljs-title">    M</span>: <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span><br>       slots: (<span class="hljs-number">0</span> slots) <span class="hljs-keyword">master</span><br>  <span class="hljs-title">Resharding</span> plan:<br>    Moving slot <span class="hljs-number">0</span> from <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br>    Moving slot <span class="hljs-number">1</span> from <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br>    Moving slot <span class="hljs-number">2</span> from <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br>.....<br>Do you want to proceed with the proposed reshard plan (yes/no)? yes<br><br></code></pre></td></tr></table></figure><p><strong><code>说明下执行命令redis-cli -a 123456 --cluster reshard 127.0.0.1:7004时出现的询问：</code></strong></p><ul><li><code>How many slots do you want to move (from 1 to 16384)?:</code>表示需要移动槽的数量。填写自己的需要即可。</li><li><code>What is the receiving node ID?：</code>表示：那个id来接收它。即新的7004的id。</li><li><code>Source node #1:</code>从那个节点id上移动散列插槽。填写移动的7001的id。当然如果需要平均节点插槽，那么每个主节点的id都写上或者写all，然后需要移动的节点数量处理主节点数。</li><li><code>Source node #2:</code>最后时填写done结束。</li><li><code>Do you want to proceed with the proposed reshard plan (yes/no)?：</code>确定要移动这些槽的计划吗？输入yes或者no。</li></ul><blockquote><p><strong>补充说明：</strong><br>如果需要包含某个值移动到新的节点（7004）上，那么就需要查询到移动的值的散列插槽值是多少。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">redis-cli -a <span class="hljs-number">123456</span>-c -p <span class="hljs-number">7004</span><br><span class="hljs-built_in">Warning</span>: <span class="hljs-keyword">Using</span> a <span class="hljs-keyword">password</span> <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;-a&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;-u&#x27;</span> <span class="hljs-keyword">option</span> <span class="hljs-keyword">on</span> the command <span class="hljs-type">line</span> interface may <span class="hljs-keyword">not</span> be safe.<br><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">7004</span>&gt; <span class="hljs-keyword">get</span> num<br> Redirected <span class="hljs-keyword">to</span> slot [<span class="hljs-number">2765</span>] located at <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">7001</span><br> &quot;10&quot;<br><br></code></pre></td></tr></table></figure><p>可以看到num的slot槽是2765。</p></blockquote><ol start="7"><li><strong>查看是否添加成功。</strong></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redis</span>-cli -a <span class="hljs-number">123456</span> -p <span class="hljs-number">7004</span> cluster nodes<br><span class="hljs-comment">#结果，可以发现7004上有0-99共100个散列插槽</span><br> <span class="hljs-attribute">redis</span>-cli -a <span class="hljs-number">123456</span> -p <span class="hljs-number">7004</span> cluster nodes<br><span class="hljs-attribute">Warning</span>: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option <span class="hljs-literal">on</span> the command line interface may not be safe.<br><span class="hljs-attribute">c836695daad38bcea59eb71dece7f860eab5f15e</span> <span class="hljs-number">127.0.0.1:8003</span>@<span class="hljs-number">18003</span> slave <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">0</span> <span class="hljs-number">1656342598000</span> <span class="hljs-number">2</span> connected<br><span class="hljs-attribute">11c3459ccdb510973ed5e61a755aaecc923405f7</span> <span class="hljs-number">127.0.0.1:7004</span>@<span class="hljs-number">17004</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1656342595000</span> <span class="hljs-number">9</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">99</span><br><span class="hljs-attribute">633546d3d75199e202d66ac56bca7e4c387bb453</span> <span class="hljs-number">127.0.0.1:8002</span>@<span class="hljs-number">18002</span> slave <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818 <span class="hljs-number">0</span> <span class="hljs-number">1656342597000</span> <span class="hljs-number">8</span> connected<br><span class="hljs-attribute">145b99ca42e4ddf2ad7fc43bdbc410ed0729e818</span> <span class="hljs-number">127.0.0.1:7001</span>@<span class="hljs-number">17001</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1656342596000</span> <span class="hljs-number">8</span> connected <span class="hljs-number">100</span>-<span class="hljs-number">5460</span><br><span class="hljs-attribute">8140ca0e986ec863881b6dede6f7555d04fe5c06</span> <span class="hljs-number">127.0.0.1:7002</span>@<span class="hljs-number">17002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1656342598804</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461</span>-<span class="hljs-number">10922</span><br><span class="hljs-attribute">e236e0ec685118abc67da92ad67c2db4b3f1abc6</span> <span class="hljs-number">127.0.0.1:8001</span>@<span class="hljs-number">18001</span> slave <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">0</span> <span class="hljs-number">1656342597801</span> <span class="hljs-number">3</span> connected<br><span class="hljs-attribute">4efa79ebad2f410049ab59edf695d6be63ed0a25</span> <span class="hljs-number">127.0.0.1:7003</span>@<span class="hljs-number">17003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1656342595777</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923</span>-<span class="hljs-number">16383</span><br><br><br></code></pre></td></tr></table></figure><h3 id="2、增加slave节点"><a href="#2、增加slave节点" class="headerlink" title="2、增加slave节点"></a>2、增加slave节点</h3><p><strong>需求想要在master7001上增加7004子节点，步骤如下（前面的主节点前3个步骤与情况1一样的）：</strong></p><ol><li><strong>首先创建（复制）一个redis.conf文件。</strong>（我的是放在一个文件夹下面的，所以就直接复制文件夹了）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> ./redis7001 -r  ./redis7004<br><br></code></pre></td></tr></table></figure><p><strong><code>参数说明：</code></strong></p><ul><li><code>cp:</code>复制命令。</li><li><code>-r:</code>递归复制整个文件夹。忽略redis7004这个这个目录是否存在，没有就创建一个新的文件夹（目录）。</li></ul><ol start="2"><li><strong>修改复制的文件端口号，日志文件地址名字，还有RDB文件名（万一后期自动选举成主节点了呢）等必要的信息。</strong></li></ol><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#全局搜索文件.<span class="hljs-regexp">/redis7004/</span>conf/redis.conf的所有<span class="hljs-number">7001</span>改成<span class="hljs-number">7004</span>。<br>sed -i s<span class="hljs-regexp">/7001/</span><span class="hljs-number">7004</span><span class="hljs-regexp">/g ./</span>redis7004<span class="hljs-regexp">/conf/</span>redis.conf <br><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>启动服务。</strong></li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">redis-server <span class="hljs-regexp">/www/</span>server<span class="hljs-regexp">/redis/</span>redis7004<span class="hljs-regexp">/conf/</span>redis.conf <br><br></code></pre></td></tr></table></figure><ol start="4"><li>添加到集群中设置为从节点</li></ol><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#1,命令</span><br>redis-cli -a [password] --cluster<span class="hljs-built_in"> add-node </span>[old_host:old_port] -a [password] --cluster-slave [old_id]<br><span class="hljs-comment">#2.最快捷的方式（当然你首先要查看主节点的id）</span><br>redis-cli -a 123456 --cluster<span class="hljs-built_in"> add-node </span>127.0.0.1:7004 127.0.0.1:7001 -a 123456 --cluster-slave 145b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br><br></code></pre></td></tr></table></figure><p><strong><code>参数说明：</code></strong></p><ul><li><code>-a 123456 :</code> 如果redis有密码则需要加这个命令</li><li><code>127.0.0.1:7004：</code>新节点host+port</li><li><code>127.0.0.1:7001：</code>已经存在集群的任意host+端口</li><li><code>--cluster-slave：</code>表示新的节点是一个从节点，如果后面没有跟ID则随机分配到一个master下。</li><li><code>145b99ca42e4ddf2ad7fc43bdbc410ed0729e818</code>：指定master的ID</li></ul><ol start="5"><li><strong>查看是否添加成功</strong></li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@T<span class="hljs-number">98899999</span> ~]# redis-cli -a <span class="hljs-number">123456</span> -p  <span class="hljs-number">7001</span> cluster nodes<br>Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.<br><span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed<span class="hljs-number">0a25 127.0</span>.<span class="hljs-number">0.1:7003</span>@<span class="hljs-number">17003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1654181965000</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923-16383</span><br><span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc<span class="hljs-number">923405f7</span> `<span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7004@17004</span> slave` `<span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed<span class="hljs-number">0729e818</span>` <span class="hljs-number">0</span> <span class="hljs-number">1654181966807</span> <span class="hljs-number">8</span> connected<br><span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe<span class="hljs-number">5c06 127.0</span>.<span class="hljs-number">0.1:7002</span>@<span class="hljs-number">17002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1654181968816</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461-10922</span><br>e236e0ec685118abc67da92ad67c2db4b3f1abc<span class="hljs-number">6 127.0.0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001@18001</span> slave <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">0</span> <span class="hljs-number">1654181965801</span> <span class="hljs-number">3</span> connected<br>c836695daad38bcea59eb71dece7f860eab5f15e <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">8003@18003</span> slave <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">0</span> <span class="hljs-number">1654181967000</span> <span class="hljs-number">2</span> connected<br>`<span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed<span class="hljs-number">0729e818</span>` <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7001@17001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1654181964000</span> <span class="hljs-number">8</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">5460</span><br><span class="hljs-number">633546d</span>3d75199e202d66ac56bca7e4c387bb<span class="hljs-number">453 127.0</span>.<span class="hljs-number">0.1:8002</span>@<span class="hljs-number">18002</span> slave <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed<span class="hljs-number">0729e818</span> <span class="hljs-number">0</span> <span class="hljs-number">1654181967812</span> <span class="hljs-number">8</span> connected<br><br></code></pre></td></tr></table></figure><h2 id="二、删除节点"><a href="#二、删除节点" class="headerlink" title="二、删除节点"></a>二、删除节点</h2><p><strong>主要分两种情况</strong></p><ol><li>删除节点是主节点</li><li>删除节点是从节</li></ol><h3 id="1、删除主节点7004"><a href="#1、删除主节点7004" class="headerlink" title="1、删除主节点7004"></a>1、删除主节点7004</h3><p><strong><code>因为主节点是分配了slot槽的，所以需要把删除节点的solt槽移动到其他master节点中去，否则数据会丢失。</code></strong></p><p><strong>需求想要删除7004节点，步骤如下：</strong></p><ul><li><strong>数据迁移到其他主节点中 （逻辑和添加节点分配散列槽一样）</strong></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#1.查看集群节点信息 -a password 如果没有密码就不需要这个命令</span><br>redis-cli -a <span class="hljs-number">123456</span> -p <span class="hljs-number">7004</span> cluster nodes<br>Warning: Using a password with &#x27;-a&#x27; <span class="hljs-keyword">or</span> &#x27;-u&#x27; option on the command line interface may not be safe.<br>e236e0ec685118abc67da92ad67c2db4b3f1abc6 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8001</span>@<span class="hljs-number">18001</span> <span class="hljs-literal">slave</span> <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">0</span> <span class="hljs-number">1654091452576</span> <span class="hljs-number">3</span> connected<br>c836695daad38bcea59eb71dece7f860eab5f15e <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8003</span>@<span class="hljs-number">18003</span> <span class="hljs-literal">slave</span> <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">0</span> <span class="hljs-number">1654091452000</span> <span class="hljs-number">2</span> connected<br><span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7003</span>@<span class="hljs-number">17003</span> <span class="hljs-keyword">master</span> <span class="hljs-title">- 0</span> <span class="hljs-number">1654091453593</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923</span>-<span class="hljs-number">16383</span><br><span class="hljs-number">633546</span>d3d75199e202d66ac56bca7e4c387bb453 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8002</span>@<span class="hljs-number">18002</span> <span class="hljs-literal">slave</span> <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818 <span class="hljs-number">0</span> <span class="hljs-number">1654091452000</span> <span class="hljs-number">1</span> connected<br><span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span>@<span class="hljs-number">17004</span> myself,<span class="hljs-keyword">master</span> <span class="hljs-title">- 0</span> <span class="hljs-number">1654091451000</span> <span class="hljs-number">7</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">2999</span><br><span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7002</span>@<span class="hljs-number">17002</span> <span class="hljs-keyword">master</span> <span class="hljs-title">- 0</span> <span class="hljs-number">1654091453000</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461</span>-<span class="hljs-number">10922</span><br><span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span>@<span class="hljs-number">17001</span> <span class="hljs-keyword">master</span> <span class="hljs-title">- 0</span> <span class="hljs-number">1654091454597</span> <span class="hljs-number">1</span> connected <span class="hljs-number">3000</span>-<span class="hljs-number">5460</span><br><span class="hljs-comment">#2.移动slot槽:需要注意的是id顺序不要搞错了 </span><br><span class="hljs-comment">#2.1 执行命令：redis-cli -a 123456 --cluster reshard 127.0.0.1:7004</span><br><span class="hljs-comment">#2.2 会出现如下的内容：能看到你要移除节点的slots槽</span><br>redis-cli -a <span class="hljs-number">123456</span> --cluster reshard <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span><br>Warning: Using a <span class="hljs-number">123456</span> with &#x27;-a&#x27; <span class="hljs-keyword">or</span> &#x27;-u&#x27; option on the command line interface may not be safe.<br>&gt;&gt;&gt; Performing Cluster Check (using <span class="hljs-keyword">node</span> <span class="hljs-title">127</span>.<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004</span>)<br>M: <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span><br>   slots:[<span class="hljs-number">0</span>-<span class="hljs-number">2999</span>] (<span class="hljs-number">3000</span> slots) <span class="hljs-keyword">master</span><br>   <span class="hljs-title">1</span> additional replica(s)<br>S: e236e0ec685118abc67da92ad67c2db4b3f1abc6 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8001</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-literal">slave</span><br>   replicates <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25<br>S: c836695daad38bcea59eb71dece7f860eab5f15e <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8003</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-literal">slave</span><br>   replicates <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06<br>M: <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7003</span><br>   slots:[<span class="hljs-number">10923</span>-<span class="hljs-number">16383</span>] (<span class="hljs-number">5461</span> slots) <span class="hljs-keyword">master</span><br>   <span class="hljs-title">1</span> additional replica(s)<br>S: <span class="hljs-number">633546</span>d3d75199e202d66ac56bca7e4c387bb453 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8002</span><br>   slots: (<span class="hljs-number">0</span> slots) <span class="hljs-literal">slave</span><br>   replicates <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7<br>M: <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7002</span><br>   slots:[<span class="hljs-number">5461</span>-<span class="hljs-number">10922</span>] (<span class="hljs-number">5462</span> slots) <span class="hljs-keyword">master</span><br>   <span class="hljs-title">1</span> additional replica(s)<br>M: <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818 <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span><br>   slots:[<span class="hljs-number">3000</span>-<span class="hljs-number">5460</span>] (<span class="hljs-number">2641</span> slots) <span class="hljs-keyword">master</span><br><span class="hljs-title">[OK</span>] All nodes agree about slots configuration.<br>&gt;&gt;&gt; Check for open slots...<br>&gt;&gt;&gt; Check slots coverage...<br>[OK] All <span class="hljs-number">16384</span> slots covered.<br><span class="hljs-comment">#2.3表示移动slots的数量</span><br>How many slots do you want to move (from <span class="hljs-number">1</span> to <span class="hljs-number">16384</span>)?<span class="hljs-number">3000</span><br><span class="hljs-comment">#2.4 表示移动到那个节点ID（或者说那个节点ID来接受这个移动的slots）</span><br>What is the receiving <span class="hljs-keyword">node</span> <span class="hljs-title">ID</span>? <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed0729e818<br><span class="hljs-comment">#2.5 表示那个节点ID需要移动</span><br>Please enter all the source <span class="hljs-keyword">node</span> <span class="hljs-title">IDs</span>.<br>  <span class="hljs-keyword">Type</span> &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.<br>  <span class="hljs-keyword">Type</span> &#x27;done&#x27; once you entered all the source nodes IDs.<br>Source <span class="hljs-keyword">node</span> <span class="hljs-title">#1</span>: <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7<br><span class="hljs-comment">#2.6输入done</span><br>Source <span class="hljs-keyword">node</span> <span class="hljs-title">#1</span>:done<br><span class="hljs-comment">#2.7最后确认是否是想要的结果</span><br>Do you want to proceed with the proposed reshard plan (yes/no)? yes<br><span class="hljs-comment">#2.8 开始执行移动功能。等着移动完成后就可以删除节点了。</span><br>Moving slot <span class="hljs-number">1546</span> from <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span> to <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span>: <br>Moving slot <span class="hljs-number">1547</span> from <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span> to <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span>: <br>Moving slot <span class="hljs-number">1548</span> from <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span> to <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span>: <br>Moving slot <span class="hljs-number">1549</span> from <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span> to <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7001</span>: <br>省略.....<br><span class="hljs-comment">#3.可以再次执行1命令检查一下</span><br><br></code></pre></td></tr></table></figure><p><strong><code>用到的命令：</code></strong></p><ul><li><code>redis-cli -a password -p 7004 cluster nodes</code></li><li><code>redis-cli -a password --cluster reshard host:prot</code></li></ul><ol start="2"><li><strong>执行删除命令</strong>:</li></ol><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-string">#1</span>.命令<br>redis-cli -a password --cluster del-node ip:prot 删除点ID<br><span class="hljs-string">#2</span>.例子<br>[root@T98899999 ~]# redis-cli -a <span class="hljs-number">123456</span> --cluster del-node <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span> <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7<br>Warning: <span class="hljs-keyword">Using</span> a password <span class="hljs-keyword">with</span> <span class="hljs-string">&#x27;-a&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;-u&#x27;</span> option <span class="hljs-keyword">on</span> the command line <span class="hljs-keyword">interface</span> may <span class="hljs-keyword">not</span> be safe.<br>&gt;&gt;&gt; Removing node <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7 <span class="hljs-keyword">from</span> cluster <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">7004</span><br>&gt;&gt;&gt; Sending CLUSTER FORGET messages <span class="hljs-keyword">to</span> the cluster...<br>&gt;&gt;&gt; Sending CLUSTER RESET <span class="hljs-keyword">SOFT</span> <span class="hljs-keyword">to</span> the deleted node.<br><br></code></pre></td></tr></table></figure><ol start="3"><li><strong>查看是否删除成功(发现已经没有这个节点了)</strong></li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dns">[root@T<span class="hljs-number">98899999</span> ~]# redis-cli -a <span class="hljs-number">123456</span> -p <span class="hljs-number">7001</span> cluster nodes<br>Warning: Using a password with &#x27;-a&#x27; or &#x27;-u&#x27; option on the command line interface may not be safe.<br><br><span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed<span class="hljs-number">0a25 127.0</span>.<span class="hljs-number">0.1:7003</span>@<span class="hljs-number">17003</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1654095165860</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923-16383</span><br><br><span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe<span class="hljs-number">5c06 127.0</span>.<span class="hljs-number">0.1:7002</span>@<span class="hljs-number">17002</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1654095164857</span> <span class="hljs-number">2</span> connected <span class="hljs-number">5461-10922</span><br><br>e236e0ec685118abc67da92ad67c2db4b3f1abc<span class="hljs-number">6 127.0.0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001@18001</span> slave <span class="hljs-number">4</span>efa79ebad2f410049ab59edf695d6be63ed0a25 <span class="hljs-number">0</span> <span class="hljs-number">1654095163854</span> <span class="hljs-number">3</span> connected<br><br>c836695daad38bcea59eb71dece7f860eab5f15e <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">8003@18003</span> slave <span class="hljs-number">8140</span>ca0e986ec863881b6dede6f7555d04fe5c06 <span class="hljs-number">0</span> <span class="hljs-number">1654095164000</span> <span class="hljs-number">2</span> connected<br><br><span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed<span class="hljs-number">0729e818</span> <span class="hljs-number">127.0.0.1</span>:<span class="hljs-number">7001@17001</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1654095164000</span> <span class="hljs-number">8</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">5460</span><br><br><span class="hljs-number">633546d</span>3d75199e202d66ac56bca7e4c387bb<span class="hljs-number">453 127.0</span>.<span class="hljs-number">0.1:8002</span>@<span class="hljs-number">18002</span> slave <span class="hljs-number">145</span>b99ca42e4ddf2ad7fc43bdbc410ed<span class="hljs-number">0729e818</span> <span class="hljs-number">0</span> <span class="hljs-number">1654095164000</span> <span class="hljs-number">8</span> connected<br><br></code></pre></td></tr></table></figure><ol start="4"><li><strong>关闭服务：先查看ps进程，然后kill掉进程</strong></li></ol><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tap">[root@T98899999 ~]<span class="hljs-comment"># ps -ef|grep  redis-server</span><br>root    <span class="hljs-number"> 1751233 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月26 ?       00:06:51 redis-server *:6379<br>root    <span class="hljs-number"> 2244353 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月27 ?       00:05:55 redis-server 0.0.0.0:7001 [cluster]<br>root    <span class="hljs-number"> 2244355 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月27 ?       00:06:00 redis-server 0.0.0.0:7002 [cluster]<br>root    <span class="hljs-number"> 2244357 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月27 ?       00:05:56 redis-server 0.0.0.0:7003 [cluster]<br>root    <span class="hljs-number"> 2244359 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月27 ?       00:05:53 redis-server 0.0.0.0:8001 [cluster]<br>root    <span class="hljs-number"> 2244361 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月27 ?       00:05:53 redis-server 0.0.0.0:8002 [cluster]<br>root    <span class="hljs-number"> 2244367 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月27 ?       00:05:56 redis-server 0.0.0.0:8003 [cluster]<br>root    <span class="hljs-number"> 2749064 </span>     <span class="hljs-number"> 1 </span><span class="hljs-number"> 0 </span>5月30 ?       00:02:17 redis-server 0.0.0.0:7004 [cluster]<br>root    <span class="hljs-number"> 3875558 </span>3762488 <span class="hljs-number"> 0 </span>22:54 pts/4    00:00:00 grep --color=auto redis-server<br>[root@T98899999 ~]<span class="hljs-comment"># kill -9 2749064</span><br><br></code></pre></td></tr></table></figure><h3 id="2、删除slave节点"><a href="#2、删除slave节点" class="headerlink" title="2、删除slave节点"></a>2、删除slave节点</h3><p><strong>删除从节点就比较简单了。步骤如下：</strong></p><ol><li><strong>执行删除命令</strong></li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment">#1.命令</span><br>redis-cli -a password --cluster del-<span class="hljs-keyword">node</span> ip:<span class="hljs-title">prot</span> 删除点ID<br><span class="hljs-comment">#2.例子</span><br>redis-cli -a <span class="hljs-number">123456</span> --cluster del-<span class="hljs-keyword">node</span> <span class="hljs-title">127</span>.<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">7004</span> <span class="hljs-number">11</span>c3459ccdb510973ed5e61a755aaecc923405f7<br><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>关闭服务：先查看ps -ef|grep redis-server，然后执行kill命令。</strong></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多款视频 APP 源码（前端+后端）打包出售</title>
    <link href="/article/d06cc010.html"/>
    <url>/article/d06cc010.html</url>
    
    <content type="html"><![CDATA[<h2 id="视频-APP-源码（前端-后端）打包"><a href="#视频-APP-源码（前端-后端）打包" class="headerlink" title="视频 APP 源码（前端+后端）打包"></a>视频 APP 源码（前端+后端）打包</h2><p class="note note-error">这些源码是本人网络收集到的，实属不易，不过开源的东西都是免费的，我也不收费，源码免费，但是环境搭建和疑难解答收费，如果自己动手能力强可以免费送源码。疑难解答每个 APP10 元，需要的+V:fyyy566</p><h2 id="绿豆视频（AS-PHP）"><a href="#绿豆视频（AS-PHP）" class="headerlink" title="绿豆视频（AS+PHP）"></a>绿豆视频（AS+PHP）</h2><p class="note note-primary">前后端源码都有，还有一款改版+了聚合直播（你懂的直播聚合）这个单独付费 5 元。</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/6b618c2993684403b26bfb3ccf6154200336394f7cc429d4bf1cd9077c2418e5.png" alt="图 2">  </p><h2 id="瑞丰萝卜视频（AS-PHP）"><a href="#瑞丰萝卜视频（AS-PHP）" class="headerlink" title="瑞丰萝卜视频（AS+PHP）"></a>瑞丰萝卜视频（AS+PHP）</h2><p class="note note-primary">不知道绿豆和萝卜谁先出的，基础代码一模一样，后台通用，三套样式</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/3ddd92ed3901924c44bcc4cde53aeb1aef9e6b43ac1e5d6bddfab0d35d88c0ae.png" alt="图 1">  </p><h2 id="乐檬-TV-AS-PHP"><a href="#乐檬-TV-AS-PHP" class="headerlink" title="乐檬 TV(AS+PHP)"></a>乐檬 TV(AS+PHP)</h2><p class="note note-primary">bug 多，自己修复了一些，但是还是不完美</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/ae421587d74b924ef21f7b6f272c3478e47ca3c937add785e2e10f655377489e.png" alt="图 3">  </p><h2 id="神马-TV（AS-PHP-易如意）"><a href="#神马-TV（AS-PHP-易如意）" class="headerlink" title="神马 TV（AS+PHP+易如意）"></a>神马 TV（AS+PHP+易如意）</h2><p class="note note-primary">github 有最基础的开源版本吗，对接原生苹果 CMS, 也有一款 5.4 的优化的 AS 源码</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/1f749d9dcbd1dce3f54a238021e255cbf46da77220264a22a0aae5006ecf0a9e.png" alt="图 4">  </p><h2 id="骡马-TV-php-安卓无壳）"><a href="#骡马-TV-php-安卓无壳）" class="headerlink" title="骡马 TV(php+安卓无壳）"></a>骡马 TV(php+安卓无壳）</h2><p class="note note-primary">神马和骆驼杂交的一款，只有安卓壳，没有 AS 源码</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/5a2398a1e1472bfebb8dd0d406f039b779150d42dbde1ed60d0dfe7efb481ea5.png" alt="图 5">  </p><h2 id="骆驼直播（AS-PHP-无壳-APP）"><a href="#骆驼直播（AS-PHP-无壳-APP）" class="headerlink" title="骆驼直播（AS+PHP+无壳 APP）"></a>骆驼直播（AS+PHP+无壳 APP）</h2><p class="note note-primary">一款直播 APP，有开发版本源码，很老的，不过能用，对接的是老版本的 PHP 源码，还有一款 EZ 魔改的后台+无壳的 APP</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/60f57af8bb55f67b796746730b376eb95436a9a0037dae58f1f973074528192c.png" alt="图 7">  </p><h2 id="TV-BOX-AS"><a href="#TV-BOX-AS" class="headerlink" title="TV_BOX(AS)"></a>TV_BOX(AS)</h2><p class="note note-primary">开源的源码，稳定接口渠道分享 5 元</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/5c8ed4e6f9b1bb5cfca737db0cbc45f838c16b64d8007b487806654042a09964.png" alt="图 6">  </p><p style="font-size:30px;color:red">50 元所有打包，帮助搭建，+TV 软件网站分享，+m3u8 直播源分享100 元以上功能+接受定制开发。</p>]]></content>
    
    
    <categories>
      
      <category>影视</category>
      
    </categories>
    
    
    <tags>
      
      <tag>视频 APP</tag>
      
      <tag>CMS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA无法导入java基础包的问题</title>
    <link href="/article/c7f64ee6.html"/>
    <url>/article/c7f64ee6.html</url>
    
    <content type="html"><![CDATA[<h2 id="IDEA无法导入java基础包的问题"><a href="#IDEA无法导入java基础包的问题" class="headerlink" title="IDEA无法导入java基础包的问题"></a>IDEA无法导入java基础包的问题</h2><p>今天用IDEA智能导包发现Map关联出来的包不是java.util下面。百度好久发现了答案</p><p>  之前有一段时间在使用IDEA的时候，发现通过快捷键Alt + Enter导入并没有提示有java.util.Date的包，仅仅只有java.sql.Date的包。于是每次使用都需要通过手写import java.util.Date;来进行导包。博主在好生不爽了一段时间后，终于在网上找到了解决办法，本文就是用来记录一下解决过程的。<br>  <img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/ce44dbcdfe5af996f11cc4562cba666fca790740442bafebeba9a975ae7196f6.png" alt="图 1">  </p><p> 找到设置（Alt + Shift + S），搜索“Auto Import”。如下图所示，只需要把java.util.Date导入提示的排除设置删除即可。<br><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/f349b7d8e48ae0fb3f16809ffa24dd030c7e02b1b4a9927b76d7ba9d70ccf617.png" alt="图 2">  </p><p>同理，因为一般项目中很少使用得到java.sql.Date，所以我们可以添加这么一条设置，用于排除java.sql.Date的导入提示。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDEA</tag>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我经历的技术架构转变</title>
    <link href="/article/20083f70.html"/>
    <url>/article/20083f70.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="大学时代"><a href="#大学时代" class="headerlink" title="大学时代"></a>大学时代</h2><p class="note note-primary">只有毕业了才会怀念那些美好的学生时代</p><p>大学计算机专业入门课程应该就是<code>C语言</code>,后来学习了<code>JAVA</code>，从此开启了撸码，大三应该才开始有正规的编程课，老师给我们介绍了一些技术知识，然后带着我们做些小DEMO，当时的技术栈应该是用了<code>Spring+Hibernate+Struts2</code>框架。</p><h2 id="菜鸟时代"><a href="#菜鸟时代" class="headerlink" title="菜鸟时代"></a>菜鸟时代</h2><p class="note note-primary">那些让你痛苦的才会让你成长</p><p>毕业以后第一次面试竟然被无情pass掉了，就当时看来应该是我的八股文没有背熟练，后来辗转来到了第一家创业公司，当时我们是在一栋居民楼里办公，老板和技术总监都是山大博士，项目经理是研究生准备读博。待了大约两年，小公司好处就是能多学东西。前前后后接触了好多项目，锻炼了自己的能力。</p><ul><li>类似仓储管理系统：<code>Spring+Struts2+JSF(加强版的JSP)+JPA</code></li><li>某车商公众号:<code>SSM框架+jsp（锻炼了自己前端能力）</code></li><li>某车商停车位系统：<code>SSM,VUE,nativeJS</code></li><li>被外包去了某家上市公司：<code>Dubbo+SSM</code></li></ul><h2 id="摸鱼时代"><a href="#摸鱼时代" class="headerlink" title="摸鱼时代"></a>摸鱼时代</h2><p class="note note-primary">偷得浮生半日闲</p>从第一家公司离开后，来到了一个和HW外包的大公司，在这里待了大约一年半左右，让我对程序员有了更多理解，业务是企业生存来源，80%的程序员在做业务，我总觉得自己是那20%，应该也是之后离职的主要因素。项目固定，一个老的项目多个模块，不停的往上堆新的业务逻辑。能用就行。<ul><li>A模块：类似SSH框架，大厂自己封装的。</li><li>B模块：开源Spring+Struts1</li><li>C模块：类似SSM+dubbo，大厂封的</li><li>D模块：只有前端用的<code>react</code>框架</li></ul><p>待了一段时间想出去面试看看。结果现在大街上全是问你Springboot和SpringCloud的，待不住了，又跳槽到现在这家公司，巧了。又是外包。<br>别人眼中的外包是加班狗，背锅侠。不过我到现在感觉我们人力外包要比他们自己的开发悠闲的多，可能部门原因，我们没有生产的操作权限，所以很多日常运维，节日值班也没我们啥事。平常开会啥的也不找我们。就是撸点代码。配合其他接口人对接一下数据。几乎没加过班。主要是负责维护一个其他部门（已解散）的系统，这个系统就是将开源软件管理，然后给业务部门接入。</p><ul><li>管控台：<code>Springboot+mybatis+redis+nacos+swagger</code></li><li>缓存：<code>redis</code>6节点集群</li><li>消息：<code>amq</code>：6节点集群</li><li>注册中心：<code>zk</code> 6节点集群</li><li>配置：<code>nacos</code></li><li><code>docker</code>容器化，<code>K8S</code>编排</li></ul><h2 id="时代"><a href="#时代" class="headerlink" title="??时代"></a>??时代</h2><p>总干外包不是办法，加上生活上车贷房贷压力，还是多学点东西。下一份工作争取稳定下来，无论做技术还是业务。坚持下来都挺好的。感谢网络科技时代的红利。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊 VIP 视频解析的那些事儿</title>
    <link href="/article/6f6c6959.html"/>
    <url>/article/6f6c6959.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h1 id="VIP-视频解析的那些事儿"><a href="#VIP-视频解析的那些事儿" class="headerlink" title="VIP 视频解析的那些事儿"></a>VIP 视频解析的那些事儿</h1><p>现在，各大官方影视站，不开个会员基本上啥也看不了。不过上有政策下有对策，今天我们来聊一下现在网络上免费影视站的数据来源和解析原理。</p><h2 id="视频采集"><a href="#视频采集" class="headerlink" title="视频采集"></a>视频采集</h2><p>采集顾名思义就是利用各种技术，将官方视频站上的数据采集到一块。首先我们要知道，并不是人人都是开发，就算是开发也不一定什么语言都会，环境搭建等环节会让好多人望而却步，需求是第一生产力，所以可视化软件的开发降低了很多门槛，废话不多说，现在比较出名的叫火车头采集</p><p><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/56a7c71d1c6f31e0c762b35499569b025685f3ed4e83c3ca500b386d3c2962fe.png" alt="图 1">  </p><p>其实原理很简单，就是利用网页源数据解析，获取数据定时执行，然后采集到数据库（cms 下面会提到）。这样我们首先就获取到了所有的视频数据，但是数据并不能采集到真正的视频链接，获取到的都是视频播放页面的链接，那么下面我们就要去解析页面视频啦！</p><h2 id="视频解析"><a href="#视频解析" class="headerlink" title="视频解析"></a>视频解析</h2><p>视频解析是整个流程中最重要的环节，能解析到真正的视频链接才能拿到各个应用内播放。上面提到我们采集到的是视频播放页面的链接，其实有了这个链接也就能通过数据解析，响应拦截，视频嗅探等获取到视频真正链接。但是如果我们没有会员，能访问的资源也是免费视频，会员视频是没有权限的。所以现在视频上的 VIP 视频解析，<strong>一解</strong>的原理就是，用会员账号的 cookie 去访问视频数据获取到视频链接，所以你得现有一个 VIP 哈哈哈哈哈，不过现在很多视频解析网站都是封装的一解，称作<strong>二解</strong>甚至是三，四，五。N 层嵌套。文章末尾会给大家送福利的哈哈。有了视频数据我们就可以把他拿到各种应用上去展示，就有了各式各样的视频站，APP。</p><h2 id="视频应用"><a href="#视频应用" class="headerlink" title="视频应用"></a>视频应用</h2><ol><li>影视站：现在网上有大大小小的影视站，一个影视站，从前端页面到后台管理，个人开发少说也要几个月的周期，那现在这么多影视站怎么来的呢，大多都是模板创建的，不同主题而已。比较出名的几个建站模板，苹果 CMS, 海洋 CMS，我记得我刚玩网络时就听说过海洋 CMS，到现在算来也有 10 多年了，只不过当时采集的不是正规视频。思路就是，将采集的视频保存数据库，有个管理页面，前端接口对接。</li><li>APP: 从现在接触过和了解过的大多都还是对接 CMS 主题站的接口，比较出名的有神马壳 293，骡马壳（神马和骆驼直播杂交的），乐檬。最近比较火的应该是猫 TV 的开源版 TV-BOX，基于嗅探，解析的一款产品。在此思路上衍生的 biubiu。</li></ol><h2 id="阅读福利"><a href="#阅读福利" class="headerlink" title="阅读福利"></a>阅读福利</h2><h3 id="VIP-视频在线解析"><a href="#VIP-视频在线解析" class="headerlink" title="VIP 视频在线解析"></a>VIP 视频在线解析</h3><div class="note note-info">            <ol><li><a href="http://tv.wandhi.com/go.html">http://tv.wandhi.com/go.html</a></li><li><a href="http://www.ikukk.com/">http://www.ikukk.com/</a></li></ol>          </div><h3 id="影视站"><a href="#影视站" class="headerlink" title="影视站"></a>影视站</h3><div class="note note-info">            <ol><li><a href="https://www.52bdys.com/">https://www.52bdys.com/</a></li><li>其他的小网站可以自己百度搜索电影名+“在线免费观看” eg:”庆余年在线免费观看”，搜索随便点一个链接能观看的概率 90%吧。</li></ol>          </div><h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><div class="note note-info">            <p>分享几个 APP 网站</p><ol><li><a href="https://fsylr.com/tv">https://fsylr.com/tv</a></li><li><a href="https://www.sharerw.com/a/ziyuan/">https://www.sharerw.com/a/ziyuan/</a></li><li><a href="https://www.fenxm.com/tv">https://www.fenxm.com/tv</a></li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>影视</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMS</tag>
      
      <tag>视频解析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 搭建+自动部署+开发</title>
    <link href="/article/c208d6fa.html"/>
    <url>/article/c208d6fa.html</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="hexo-搭建"><a href="#hexo-搭建" class="headerlink" title="hexo 搭建"></a>hexo 搭建</h2><h3 id="安装-nodeJs"><a href="#安装-nodeJs" class="headerlink" title="安装 nodeJs"></a>安装 nodeJs</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1. 下载安装 nodejs<br>2. 设置淘宝镜像： npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">registry</span>=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><h3 id="安装-hexo"><a href="#安装-hexo" class="headerlink" title="安装 hexo"></a>安装 hexo</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 安装 hexo npm install -g hexo-cli <br><span class="hljs-bullet">2.</span> hexo init &quot;目录名&quot;<br><span class="hljs-bullet">3.</span> hexo g （开发配置时先执行下 hexo clean 操作）<br><span class="hljs-bullet">4.</span> hexo s  访问 http://localhost:4000<br></code></pre></td></tr></table></figure><h2 id="hexo-部署-Github"><a href="#hexo-部署-Github" class="headerlink" title="hexo 部署 Github"></a>hexo 部署 Github</h2><p>###创建密钥对<br>为了方便运行 GitHub Actions 时登录 GitHub 账号，我们使用 SSH 方式登录。就是要把设备的私钥交给 GitHub Actions，公钥交给 GitHub，需要去 Settings 里去配置。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;Github 的邮箱地址&quot;</span><br>如 ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;123123123@gmail.com&quot;</span><br></code></pre></td></tr></table></figure><p>密钥对生成后默认的位置是用户文件。以 windows 为例：密钥对文件在 C:\Users\用户名里，其中 Users 可能因为系统原因显示的是用户。这个文件夹里会有一个。ssh 的目录，这个里面就是我们的密钥对。</p><p>其中 id_rsa 是私钥，id_rsa.pub 是公钥。</p><ul><li><p>配置公钥，应该已经配好，不然如何上到的项目资源，配置路径：github 网站–&gt;Settings–&gt;SSH and GPG keys<br><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/5241d4b61bba491724687b87c1de7370772562f19384e2b337414d0a0b25640b.png" alt="图 1">  </p></li><li><p>配置私钥，blog 私有仓库的 Settings-&gt;Secrets 里添加私钥，名称为 HEXO_DEPLOY_PRIVATE_KEY<br><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/424ddd690018ae4d1310bfee160d2177a345b0618d8401774f2ad0f6f613e702.png" alt="图 2"></p></li></ul><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">创建一个公有仓库，命名必须为 username<span class="hljs-selector-class">.github</span><span class="hljs-selector-class">.io</span> （username 为自己 GitHub 账号）<br>创建一个私有仓库，随意命名 （将 hexo 的源代码上传到此仓库）<br><br></code></pre></td></tr></table></figure><h3 id="创建-Github-Action"><a href="#创建-Github-Action" class="headerlink" title="创建 Github Action"></a>创建 Github Action</h3><p>进入仓库 Actions-&gt;new workflow</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">博客持续集成</span><br><br><span class="hljs-attr">on:</span> <br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br>      <br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span> <br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span> <br><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">检出仓库代码</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@master</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">安装</span> <span class="hljs-string">Node.js</span> <span class="hljs-number">11.</span><span class="hljs-string">x</span> <br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@master</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&quot;11.x&quot;</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">安装</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">依赖</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        npm install hexo-cli -g</span><br><span class="hljs-string">        npm install</span><br><span class="hljs-string"></span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">构建</span> <span class="hljs-string">Hexo</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">        hexo clean</span><br><span class="hljs-string">        hexo generate</span><br></code></pre></td></tr></table></figure><p>👆上面 nodeJs 版本需要与本地对应<br>配置部署到 Github.io 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">- name: 配置 Github 部署私钥<br>  <span class="hljs-built_in">env</span>:<br>    HEXO_DEPLOY_PRIVATE_KEY: <span class="hljs-variable">$&#123;&#123; secrets.HEXO_DEPLOY_PRIVATE_KEY &#125;</span>&#125;<br>  run: |<br>    <span class="hljs-built_in">mkdir</span> -p ~/.ssh/<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$HEXO_DEPLOY_PRIVATE_KEY</span>&quot;</span> &gt; ~/.ssh/id_rsa<br>    <span class="hljs-built_in">chmod</span> 600 ~/.ssh/id_rsa<br>    ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts<br>    <br>- name: 配置 Git 信息<br>  run: |<br>    git config --global user.name <span class="hljs-string">&#x27;名称&#x27;</span><br>    git config --global user.email <span class="hljs-string">&#x27;邮箱&#x27;</span><br><br>- name: 部署 Hexo 到 Github<br>  run: hexo deploy<br></code></pre></td></tr></table></figure><p>保存之后进到私有仓库的 Github Action 可以看到编译流程，查看是否运行成功。<br><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/4cddbb9da8d16a0bf29f093a0485064a1d765f5b2cbc6fa2929834039a9353c1.png" alt="图 3">  </p><h2 id="hexo-开发"><a href="#hexo-开发" class="headerlink" title="hexo 开发"></a>hexo 开发</h2><p>推荐使用VSCODE开发，插件多。<br><img src="https://cdn.jsdelivr.net/gh/fyyCode/imageStore/acec13dcfa48b42626bbee94fbac4ea5834ea94a9e34726359cce8529b77be7a.png" alt="图 4">  </p><h2 id="hexo-疑难解答"><a href="#hexo-疑难解答" class="headerlink" title="hexo 疑难解答"></a>hexo 疑难解答</h2><p>文章右侧的目录功能不能跳转</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">卸载hexo-toc，因为会冲突<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://blog.ctftools.com/2021/07/newpost-18/">https://blog.ctftools.com/2021/07/newpost-18/</a><br><a href="https://cloud.tencent.com/developer/article/1611808">https://cloud.tencent.com/developer/article/1611808</a><br><a href="https://hexo.fluid-dev.com/docs/guide/">https://hexo.fluid-dev.com/docs/guide/</a><br><a href="https://www.bilibili.com/read/cv12633102">https://www.bilibili.com/read/cv12633102</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
